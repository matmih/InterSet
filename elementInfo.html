<html>

<head>


<style>

#tooltip {
        position: absolute;
        width: 200px;
        height: auto;
        padding: 10px;
        background-color: white;
        -webkit-border-radius: 10px;
        -moz-border-radius: 10px;
        border-radius: 10px;
        -webkit-box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
        -moz-box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
        box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
        pointer-events: none;
		z-index: 5;
      }

      #tooltip.hidden {
        display: none;
      }

      #tooltip p {
        margin: 0;
        font-family: sans-serif;
        font-size: 18px;
        line-height: 12px;
      }
	  
	  	  .node {
  stroke: #fff;
  stroke-width: 1.5px;
}

.link {
  stroke: #999;
  stroke-opacity: .6;
  }
  
  .node {
	cursor:pointer;
}

.link {
	cursor:pointer;
}
</style>

<div id="tooltip" class="hidden">
        <p><span id="value"></p>
		<br>
		<p><span id="value1"><p>
		<br>
		<p><span id="value2"><p>
</div>

</head>

<body> 

<script> 

function loadToStructE(structure, $scope){
return Q.spread([structure,$scope], function(structure,$scope){
	for(var i=0;i<$scope.RedsSupps.redElems.length;i++){
								if(!structure.has($scope.RedsSupps.redElems[i].id)){
									var tSet=new HashSet();
									tSet.add($scope.RedsSupps.redElems[i].elementID);
									structure.set($scope.RedsSupps.redElems[i].id,tSet);
								}
								else{
								var tSet=structure.get($scope.RedsSupps.redElems[i].id);
								tSet.add($scope.RedsSupps.redElems[i].elementID);
								structure.set($scope.RedsSupps.redElems[i].id,tSet);
								}
						}
						
							console.log('Loaded to structure...');
							console.log(structure);
							console.log(structure.count());
							return structure;
							})
}

function loadToStructAttrsE(structure, $scope){
return Q.spread([structure,$scope], function(structure,$scope){
	for(var i=0;i<$scope.RedsAttrs.redAttrs.length;i++){
								if(!structure.has($scope.RedsAttrs.redAttrs[i].id)){
									var tSet=new HashSet();
									tSet.add($scope.RedsAttrs.redAttrs[i].attributeID);
									structure.set($scope.RedsAttrs.redAttrs[i].id,tSet);
								}
								else{
								var tSet=structure.get($scope.RedsAttrs.redAttrs[i].id);
								tSet.add($scope.RedsAttrs.redAttrs[i].attributeID);
								structure.set($scope.RedsAttrs.redAttrs[i].id,tSet);
								}
						}
						
							console.log('Loaded to structure...');
							console.log(structure);
							console.log(structure.count());
							return structure;
							})
}

function relateRedsE(){
console.log("Relation button pressed!");
	$("[id=attrdist]").empty();
    $("#redSupTable").remove();
    $("#redADCont").remove();
	
	 var pload=document.getElementById("loader");
  pload.style.visibility="visible";

var selectedReds = new HashSet();
var checkTable="http://localhost:8081/checkTable";
var AllRedsSupps="http://localhost:8081/redundancySupp";
var loadGraph="http://localhost:8081/graphData";
var saveGraph="http://localhost:8081/graphData";
var saveGraphG="http://localhost:8081/graphDataG";
var numredsLink="http://localhost:8081/numReds";

$('#redTable').each(function (i, row) {

        // reference all the stuff you need first
        var $row = $(row),
            $checkedBoxes = $row.find('input:checked');

        $checkedBoxes.each(function (i, checkbox) {
            // assuming you layout the elements this way, 
            // we'll take advantage of .next()
            var $checkbox = $(checkbox);
               console.log('checkbox');
			   console.log($checkbox);
			   console.log($checkbox[0].id);
			   selectedReds.add(parseInt($checkbox[0].id));
        });
    });
	
   var appElement = document.querySelector('[ng-app=redApp]');
   var $scope = angular.element(appElement).scope();
   console.log('scope');
   console.log($scope);
   console.log('checked order SOM');
   console.log($scope.checkedOrderSOM);
	
	if($scope.checkedOrderSOM.cos.length<2){
		$scope.checkedOrderSOM.cos.splice(0,$scope.checkedOrderSOM.cos.length);
		
		$('#redTable').each(function (i, row) {

        // reference all the stuff you need first
        var $row = $(row),
            $checkedBoxes = $row.find('input:checked');

        $checkedBoxes.each(function (i, checkbox) {
            // assuming you layout the elements this way, 
            // we'll take advantage of .next()
            var $checkbox = $(checkbox);
               $checkbox.attr('checked', false); 
        });
    });
		
		alert('Select at least two redescriptions!');
		return;
		}
		else{
	
		var globalThreshold = $("#jacConst").val();
		var globalNumPaths = $("#nPaths").val();
		
		if(isNaN(globalThreshold) || isNaN(globalNumPaths)){
			alert('Input must be a valid number!');
			return;
		}
		
		globalThreshold = parseFloat(globalThreshold);
		globalNumPaths = parseInt(globalNumPaths);
		console.log('Weight threshold: '+globalThreshold);
		console.log('Num paths: '+globalNumPaths);
		console.log('Checked reds: ');
		console.log($scope.checkedOrderSOM.cos);
		console.log("Reds in SOM clust");
		console.log($scope.RedsInSOMClust);
		console.log($scope.riscG.RedsInSOMClust);
		
		if(typeof $scope.graphInput=='undefined'){
		
		var options = {url: checkTable,
               method: 'GET', 
               params: {
                        }
                          };
						  
				 var promise=$scope.getCheckTable(options);//$scope.getRedundancyInfo(options);
						  promise.success(function (data) {
				$scope.TableExist=data;
                $scope.error = '';
           })
          .error(function (data, status) {
              if (status === 404) {
                $scope.error = 'REST server is offline!';
              } else {
                $scope.error = 'Error: ' + status;
              }
          }).then(function(){
		  
		  console.log($scope.TableExist);
		 // $scope.TableExist.count[0].number=0; for testing purposes only, or if insufficient memory on the server, JSON.parse, uses enormous amounts of memory
				if($scope.TableExist.count[0].number==0){
					
					options = {url: AllRedsSupps,
							method: 'GET', 
							params: {
								}
                          };
						  
						   var promise1=$scope.getRedsSupps(options);
						    promise1.success(function (data) {
							$scope.RedsSupps=data;
							$scope.error = '';
						})
							.error(function (data, status) {
							if (status === 404) {
							$scope.error = 'REST server is offline!';
						} else {
								$scope.error = 'Error: ' + status;
							}
							}).then(function(){
							
						
							var redSupps=new HashMap();
							console.log($scope.RedsSupps);
							console.log('Q');
							console.log(Q);
						
						/*var promise4=Q.all([
							eventualAdd(2, 2),
							eventualAdd(10, 20)
						]);
						
						
						Q.allSettled(promise4)
							.then(function (results) {
							results.forEach(function (result) {
							if (result.state === "fulfilled") {
								var value = result.value;
								console.log("q value: "+value);
						} else {
							var reason = result.reason;
						}
						});
					});*/
						
						var promise3 = Q.all( [
						loadToStructE(redSupps,$scope)
							])
						
						Q.allSettled(promise3).then(function(results){
						results.forEach(function(result){
						
						if (result.state === "fulfilled") {
								var redSupps = result.value;
								
							var graph= new HashMap();
							console.log("then part!");
							console.log(redSupps);
							console.log(redSupps.count());

							var i=0;
							var j=i+1;
							var numReds = redSupps.count();
							var myVar=setInterval(function() {
									/*console.log("myVar function")
									console.log(i);
									console.log(j);*/
									var perc= (i/numReds)*100;
									
							document.getElementById("graphProg").innerHTML = "Graph computation: "+perc.toFixed(2)+"%";
								
								var set1 = redSupps.get(i);
								
								for(j=i+1;j<numReds;j++){
								var set2 = redSupps.get(j);
								
								var intersection=0;
								var set1val = set1.values();
								
								for(var z=0;z<set1val.length;z++)
									if(set2.contains(set1val[z]))
										intersection=intersection+1;
										
								var edge = intersection/(set1.size()+set2.size()-intersection);
								
								if(!graph.has(i)){
									var t=new Array(numReds);
									t[i]=1.0;
									graph.set(i,t);
								}
								
								if(!graph.has(j)){
									var t=new Array(numReds);
									t[j]=1.0;
									graph.set(j,t);
								}
								
								var t=graph.get(i);
								t[j]=edge;
								graph.set(i,t);
								
								t=graph.get(j);
								t[i]=edge;
								graph.set(j,t);
								}
								
			
								if(i==(numReds-1) && j==(numReds)){
								//make the writing in parts
										clearInterval(myVar);
										document.getElementById("graphProg").innerHTML = "Graph computation: "+"100%";
										console.log(graph);
										
										var totalNumberP = parseInt(graph.count())*parseInt(graph.count());
										var numRedsinBucketP = Math.floor(2571800/parseInt(graph.count()));//2571800
										var numItersP = Math.ceil(totalNumberP/(numRedsinBucketP*parseInt(graph.count())));
										console.log('Num iters: '+numItersP);
								var promisesP=new Array();
								var retDataAll=new Array(graph.count());
								for(var parts=0;parts<numItersP;parts++){
									var startIndex = parts*numRedsinBucketP;
									var endIndex = startIndex + numRedsinBucketP;
									var size = numRedsinBucketP;
									
									if(endIndex>=graph.count()){
										var diff = endIndex - graph.count();
										size = size-diff;
									}
									
									console.log(endIndex);
									console.log(size);
									
									var retData=new Array(size/*graph.count()*/);
									
									var dat;
										
										for(var z=startIndex;z<startIndex+size/*numRedsinBucketP*//*graph.count()*/;z++)//2000
											retData[z-startIndex]=graph.get(z);
											retDataAll[z]=graph.get(z);;
											console.log("retData");
												console.log(retData);
											
											options = {url: saveGraphG,
												method: 'POST', 
												params: {
													},
											    data: { graph:  JSON.stringify(retData), start: startIndex		
											}
												};

												
												
										promisesP.push($scope.setGraphData(options));
									}
									
											
										
										
												
										//var promise5=$scope.setGraphData(options);
										
										
										/*promise5.success(function (data) {
											console.log('Data stored succesfully!');
												$scope.error = '';
										})
										.error(function (data, status) {
										if (status === 404) {
											$scope.error = 'REST server is offline!';
										} else {
												$scope.error = 'Error: ' + status;
											}
											})*/
											var promise5 = Q.all(promisesP).then(function(){
														console.log("Create parameters and define scope variable here");//put watch on it in the scope.
														retData=retDataAll;
														var inputForAlgo={};
														
														for(var i=0;i<retData.length;i++){
																var eds1={};
															for(var j=0;j<retData[i].length;j++){
																if(i==j)
																	continue;
																if(typeof retData[i][j] == 'undefined')
																	 continue;//retData[i][j]=0.0;//continue;
																	
																	eds1[j]=1.0-retData[i][j];
															}
																inputForAlgo[i]=eds1;
														}
														
														console.log("Algorithm input: ");
														console.log(inputForAlgo);
														
														var threshold1=1-globalThreshold;//1-0.2;
														var forbiden1 = new HashSet();
														
														var present = new HashSet();
														
														for(var pr=0;pr<$scope.riscG.RedsInSOMClust.redescriptions.length;pr++)
																present.add($scope.riscG.RedsInSOMClust.redescriptions[pr].id);
																
														for(var pr=0;pr<retData.length;pr++)
																if(!present.contains(pr))
																	forbiden1.add(pr+"");
														
														var pathsFinal = new PriorityQueue();
														var pathsCandidates = new PriorityQueue();
 														 var graph = new Graph(inputForAlgo,threshold1,forbiden1);
														 var inputArr = new Array();
														 
														 for(var t=0;t<$scope.checkedOrderSOM.cos.length;t++)
																inputArr[t]=$scope.checkedOrderSOM.cos[t]+"";
														 
														 var sp=graph.findShortestPath(inputArr);
														console.log('SP: ');
														console.log(sp);
														console.log('checked order: ');
														console.log($scope.checkedOrderSOM.cos);
														console.log('Forbiden nodes.');
														console.log(forbiden1.values());
														
														 /*var forbiden1=new HashSet();
																var map = {a:{b:3,c:1,d:1},b:{a:2,c:1},c:{a:4,b:1}, d:{b:3,c:1}}, threshold1=50;
																var graph = new Graph(map,threshold1,forbiden1);
																var sp=graph.findShortestPath('a','b','c');*/
													
													if(sp!=null){			
																var cost=0;
														for(var i=0;i<sp.length-1;i++){
																	cost = cost + graph.findEdge(sp[i],sp[i+1]);
															}
														
														sp.forbidenEdges=new Array();														
												
														sp.cost=cost;
														pathsFinal.push(cost,sp);
														pathsCandidates.push(cost,sp);
													}
														
														while(pathsFinal.length()<globalNumPaths){//10
																if(pathsCandidates.length()==0)
																		break;
															var tmpPath = pathsCandidates.pop();
															var startNodes = new Array();
															var endNodes = new Array();
															
															for(var i=0;i<tmpPath.forbidenEdges.length;i++){
																startNodes.push(tmpPath.forbidenEdges[i].s);
																endNodes.push(tmpPath.forbidenEdges[i].e);
															}
															
															for(var i=0;i<tmpPath.length-1;i++){
																	startNodes.push(tmpPath[i]);
																	endNodes.push(tmpPath[i+1]);
																	graph.setEdges(startNodes,endNodes);
																	
																	inputArr = new Array();
														 
														 for(var t=0;t<$scope.checkedOrderSOM.cos.length;t++)
																inputArr[t]=$scope.checkedOrderSOM.cos[t]+"";
																
																	var sp1=graph.findShortestPath(inputArr,forbiden1);
								
																	if(sp1!=null){
																	
																	sp1.forbidenEdges=new Array();
																	for(var j=0;j<startNodes.length;j++){
																		var ed={}; ed.s=startNodes[j]; ed.e=endNodes[j];
																		sp1.forbidenEdges.push(ed);
																	}
																		
																		cost=0;
																		for(var i=0;i<sp1.length-1;i++){
																			cost = cost + graph.findEdge(sp1[i],sp1[i+1]);
																	}
																	
																	sp1.cost=cost;
																	if(!pathsCandidates.contains(sp1))
																		pathsCandidates.push(cost,sp1);
																	}
																	
																	graph.restoreEdges(startNodes,endNodes);
																	startNodes.splice(startNodes.length-1,1);
																	endNodes.splice(endNodes.length-1,1);
															}
															
															if(pathsCandidates.length()==0)
																break;
															
															var spT=pathsCandidates.pop();
															if(!pathsFinal.contains(spT)){
																	pathsFinal.push(spT.cost,spT);//check if this path exists.
																	pathsCandidates.push(spT.cost,spT);
															}
															else{
																	while(pathsFinal.contains(spT)){
																		spT=pathsCandidates.pop();
																	}
																	if(spT!=null){
																	pathsFinal.push(spT.cost,spT);
																	pathsCandidates.push(spT.cost,spT);
																	}
															}
															
															//console.log('tmp path1: ');
															//console.log(spT);
														}
														
														var drawGraph={};
														drawGraph.nodes = new Array();
														drawGraph.links = new Array();
														var usedNodes = new HashSet();
														console.log('Paths: ');
														var rank=1;
														
														drawGraph.startNode = $scope.checkedOrderSOM.cos[0]+"";
														usedNodes.add($scope.checkedOrderSOM.cos[0]+"");
														drawGraph.endNode = $scope.checkedOrderSOM.cos[$scope.checkedOrderSOM.cos.length-1]+"";
														usedNodes.add($scope.checkedOrderSOM.cos[$scope.checkedOrderSOM.cos.length-1]+"");
														drawGraph.intermediary = new HashSet();
														for(var k=1;k<$scope.checkedOrderSOM.cos.length-1;k++){
															drawGraph.intermediary.add($scope.checkedOrderSOM.cos[k]+"");
															usedNodes.add($scope.checkedOrderSOM.cos[k]+"");
															}
														
														while(pathsFinal.length()>0){
															var sp = pathsFinal.pop();
															console.log(rank+'. '+sp);
															console.log(sp);
															console.log(sp.length);
															for(var i=0;i<sp.length-1;i++){
															//if(i==0)
															//drawGraph.startNode=sp[i];
																 var contained=0;
																 usedNodes.add(sp[i]);
																 for(var j=0;j<drawGraph.links.length;j++){
																	if(drawGraph.links[j].source==sp[i] && drawGraph.links[j].target==sp[i+1]){
																		contained=1;
																		break;
																	}
																}
																	
																	if(contained==0){
																		var ed={};
																		ed.source=sp[i]; ed.target=sp[i+1]; ed.group=rank; ed.value=graph.findEdge(sp[i],sp[i+1]);
																		drawGraph.nGr=rank;
																		//console.log('ed');
																		//console.log(ed);
																		drawGraph.links.push(ed);
																	}			
															}
															usedNodes.add(sp[sp.length-1]);
															//drawGraph.endNode=sp[sp.length-1];
															rank=rank+1;
														}
														
														//create edges between all present nodes not on a path as default edges, code -1, grey color
														
														var unAr=usedNodes.values();
														
														for(var un1=0;un1<unAr.length-1;un1++){
															for(var un2=un1+1;un2<unAr.length;un2++){
															 var contained=0;
																 for(var j=0;j<drawGraph.links.length;j++){
																	if((drawGraph.links[j].source==unAr[un1] && drawGraph.links[j].target==unAr[un2]) || (drawGraph.links[j].source==unAr[un2] && drawGraph.links[j].target==unAr[un1])){
																		contained=1;
																		break;
																	}
																}
																if(contained==0 && graph.findEdge(unAr[un1],unAr[un2])<=threshold1){
																var ed={};
																		ed.source=unAr[un1]; ed.target=unAr[un2]; ed.group=-1; ed.value=graph.findEdge(unAr[un1],unAr[un2]);
																		drawGraph.links.push(ed);
																}
															}
														}
														
														var selReds=new Array();//redescriptions that need to be displayed
														
														for(var i=0;i<$scope.riscG.RedsInSOMClust.redescriptions.length;i++){
																if(usedNodes.contains($scope.riscG.RedsInSOMClust.redescriptions[i].id+""))
																		selReds.push($scope.riscG.RedsInSOMClust.redescriptions[i]);
														}
														
														var una = usedNodes.values();
														
														var mapping = new HashMap();
														
														var ind=0;
														for(var i=0;i<una.length;i++){
															mapping.set(una[i],ind);
															ind=ind+1;
															}
															
														for(var i=0;i<drawGraph.links.length;i++){
																drawGraph.links[i].source=mapping.get(drawGraph.links[i].source);
																drawGraph.links[i].target=mapping.get(drawGraph.links[i].target);
															}
														
														for(var i=0;i<una.length;i++){
															var n={};
															n.id=una[i];
															
															for(var j=0;j<selReds.length;j++)
																if(selReds[j].id+""==una[i]){
																	n.lq=selReds[j].data[0];
																	n.rq=selReds[j].data[1];
																	n.js=selReds[j].data[2];
																	n.supp=selReds[j].data[3];
																	n.pVal=selReds[j].data[4];
																} //uncomment when dealing with original data

															drawGraph.nodes.push(n);
														}
														
														console.log('scope');
														console.log($scope);
														//redIds.values();
													
														$scope.RedRelationGraphE=drawGraph;	//save graphINput to scope.graphInput variable	
														$scope.checkedOrderSOM.cos=[];
														$scope.graphInput = inputForAlgo;
														
														$('#redTable').each(function (i, row) {

															var $row = $(row),
														$checkedBoxes = $row.find('input:checked');

														$checkedBoxes.each(function (i, checkbox) {

														var $checkbox = $(checkbox);
														$checkbox.attr('checked', false); 
														});
													});
	
											})
										
										
										return;
											}
											
											i=i+1;
			
								/*if(j==(numReds-1)){
									i=i+1;
									j=i+1;
										}
			
									j=j+1;*/
							}, 5);	
							}
							})
						})							
									//compute the graph, save the graph and compute the input for the algorithm, run the algorithm and draw the result.
							})
							
							}
				else{
				
				var getInParts = function(startIndex, endIndex, numReds, $scope){
				if(typeof($scope.rawGraph)=='undefined')
						$scope.rawGraph = [];
					return Q.spread([startIndex, endIndex, $scope], function(startIndex, endIndex,$scope){
							var options = {url: saveGraph,
												method: 'GET', 
												params: {
													start: JSON.stringify(startIndex),
													end: JSON.stringify(endIndex),
													nr: JSON.stringify(numReds)
													}
												};
												
									var tmpPromise = $scope.getGraphData(options);	
									
									return tmpPromise;
									
									var tmpRes;
									
									tmpPromise.success(function (data) {
											tmpRes=data;
											console.log('data');
											console.log(tmpRes);
												$scope.error = '';
										})
										.error(function (data, status) {
										if (status === 404) {
											$scope.error = 'REST server is offline!';
										} else {
												$scope.error = 'Error: ' + status;
											}
											}).then(function(){
											
											console.log('got a part of data');
											console.log(tmpRes);
											var tmp=new Array();
												
											return tmp;
											//convert to HashMap arrayList
											
											});
												
					})
				};
				
				/*var promise3 = Q.all( [
						loadToStructE(redSupps,$scope)
							])
						
						Q.allSettled(promise3).then(function(results){
						results.forEach(function(result){
						
						if (result.state === "fulfilled") {
								var redSupps = result.value;*/

				
				var optionsNR = {url: numredsLink,
								 method: 'GET',
								 params: {}
								 };
								 
				var promiseNR = $scope.generalGETRequest(optionsNR);
				
				
				promiseNR.success(function (data) {
											$scope.numReds = data;
												$scope.error = '';
										})
										.error(function (data, status) {
										if (status === 404) {
											$scope.error = 'REST server is offline!';
										} else {
												$scope.error = 'Error: ' + status;
											}
											}).then(function(){
											
											console.log('num reds:');
											console.log($scope.numReds); 
											console.log($scope.numReds.numReds[0].numReds);
											
											var numReds = $scope.numReds.numReds[0].numReds;
											//convert to HashMap arrayList
											
											var totalNumber = numReds*numReds;
											var numRedsinBucket = Math.floor(2571800/numReds);
											console.log('numRedsInBucket: '+numRedsinBucket);
											var numIters = Math.ceil(totalNumber/(numRedsinBucket*parseInt(numReds)));
											console.log('numIters: '+numIters);

									var promises=new Array();
									
									for(var parts=0;parts<numIters;parts++){
									var startIndex = parts*numRedsinBucket;
									var endIndex = (parts+1)*numRedsinBucket;
									if(endIndex>numReds)
										endIndex=numReds;
										promises.push(getInParts(startIndex,endIndex,numReds,$scope));
									}
									
									var joinedPromise = Q.all(promises).then(function(values){
									
									console.log('All data received!');
									console.log('values');
									console.log(values);
									
									
									var input = [];
									
									console.log('computing input: ');
									console.log('values length: '+values.length);
									console.log('graph length: '+values[0].data.GraphData.length);
									
									for(var iv=0;iv<values.length;iv++){
											for(var iv1=0;iv1<values[iv].data.GraphData.length;iv1++)
												input.push(values[iv].data.GraphData[iv1]);
												console.log(input.length);
									}
									
										console.log('joined input: ');
										console.log(input);
										
										values=[];
	
										console.log("Create parameters and define scope variable here");//put watch on it in the scope.
														
														var inputForAlgo={};
														
														for(var i=0;i<input.length;i++){
																var eds1={};
															for(var j=0;j<input[i].length;j++){
																if(i==j)
																	continue;
																if(typeof input[i][j] == 'undefined')
																	 continue;//retData[i][j]=0.0;//continue;
																	
																	eds1[j]=1.0-input[i][j];
															}
																inputForAlgo[i]=eds1;
														}
														
														console.log("Algorithm input: ");
														console.log(inputForAlgo);
														
														var threshold1=1-globalThreshold;//1-0.2;
														var forbiden1 = new HashSet();
														
														var present = new HashSet();
														
														for(var pr=0;pr<$scope.riscG.RedsInSOMClust.redescriptions.length;pr++)
																present.add($scope.riscG.RedsInSOMClust.redescriptions[pr].id);
																
														for(var pr=0;pr<input.length;pr++)
																if(!present.contains(pr))
																	forbiden1.add(pr+"");
														
														var pathsFinal = new PriorityQueue();
														var pathsCandidates = new PriorityQueue();
 														 var graph = new Graph(inputForAlgo,threshold1,forbiden1);
														 var inputArr = new Array();
														 
														 for(var t=0;t<$scope.checkedOrderSOM.cos.length;t++)
																inputArr[t]=$scope.checkedOrderSOM.cos[t]+"";
														 
														 var sp=graph.findShortestPath(inputArr);
														console.log('SP: ');
														console.log(sp);
														console.log('checked order: ');
														console.log($scope.checkedOrderSOM.cos);
														console.log('Forbiden nodes.');
														console.log(forbiden1.values());
														
														 /*var forbiden1=new HashSet();
																var map = {a:{b:3,c:1,d:1},b:{a:2,c:1},c:{a:4,b:1}, d:{b:3,c:1}}, threshold1=50;
																var graph = new Graph(map,threshold1,forbiden1);
																var sp=graph.findShortestPath('a','b','c');*/
													
													if(sp!=null){			
																var cost=0;
														for(var i=0;i<sp.length-1;i++){
																	cost = cost + graph.findEdge(sp[i],sp[i+1]);
															}
														
														sp.forbidenEdges=new Array();														
												
														sp.cost=cost;
														pathsFinal.push(cost,sp);
														pathsCandidates.push(cost,sp);
													}
														
														while(pathsFinal.length()<globalNumPaths){//10
																if(pathsCandidates.length()==0)
																		break;
															var tmpPath = pathsCandidates.pop();
															var startNodes = new Array();
															var endNodes = new Array();
															
															for(var i=0;i<tmpPath.forbidenEdges.length;i++){
																startNodes.push(tmpPath.forbidenEdges[i].s);
																endNodes.push(tmpPath.forbidenEdges[i].e);
															}
															
															for(var i=0;i<tmpPath.length-1;i++){
																	startNodes.push(tmpPath[i]);
																	endNodes.push(tmpPath[i+1]);
																	graph.setEdges(startNodes,endNodes);
																	
																	inputArr = new Array();
														 
														 for(var t=0;t<$scope.checkedOrderSOM.cos.length;t++)
																inputArr[t]=$scope.checkedOrderSOM.cos[t]+"";
																
																	var sp1=graph.findShortestPath(inputArr,forbiden1);
								
																	if(sp1!=null){
																	
																	sp1.forbidenEdges=new Array();
																	for(var j=0;j<startNodes.length;j++){
																		var ed={}; ed.s=startNodes[j]; ed.e=endNodes[j];
																		sp1.forbidenEdges.push(ed);
																	}
																		
																		cost=0;
																		for(var i=0;i<sp1.length-1;i++){
																			cost = cost + graph.findEdge(sp1[i],sp1[i+1]);
																	}
																	
																	sp1.cost=cost;
																	if(!pathsCandidates.contains(sp1))
																		pathsCandidates.push(cost,sp1);
																	}
																	
																	graph.restoreEdges(startNodes,endNodes);
																	startNodes.splice(startNodes.length-1,1);
																	endNodes.splice(endNodes.length-1,1);
															}
															
															if(pathsCandidates.length()==0)
																break;
															
															var spT=pathsCandidates.pop();
															if(!pathsFinal.contains(spT)){
																	pathsFinal.push(spT.cost,spT);//check if this path exists.
																	pathsCandidates.push(spT.cost,spT);
															}
															else{
																	while(pathsFinal.contains(spT)){
																		spT=pathsCandidates.pop();
																	}
																	if(spT!=null){
																	pathsFinal.push(spT.cost,spT);
																	pathsCandidates.push(spT.cost,spT);
																	}
															}
															
															//console.log('tmp path1: ');
															//console.log(spT);
														}
														
														var drawGraph={};
														drawGraph.nodes = new Array();
														drawGraph.links = new Array();
														var usedNodes = new HashSet();
														console.log('Paths: ');
														var rank=1;
														
														drawGraph.startNode = $scope.checkedOrderSOM.cos[0]+"";
														usedNodes.add($scope.checkedOrderSOM.cos[0]+"");
														drawGraph.endNode = $scope.checkedOrderSOM.cos[$scope.checkedOrderSOM.cos.length-1]+"";
														usedNodes.add($scope.checkedOrderSOM.cos[$scope.checkedOrderSOM.cos.length-1]+"");
														drawGraph.intermediary = new HashSet();
														for(var k=1;k<$scope.checkedOrderSOM.cos.length-1;k++){
															drawGraph.intermediary.add($scope.checkedOrderSOM.cos[k]+"");
															usedNodes.add($scope.checkedOrderSOM.cos[k]+"");
															}
														
														while(pathsFinal.length()>0){
															var sp = pathsFinal.pop();
															console.log(rank+'. '+sp);
															console.log(sp);
															console.log(sp.length);
															for(var i=0;i<sp.length-1;i++){
															//if(i==0)
															//drawGraph.startNode=sp[i];
																 var contained=0;
																 usedNodes.add(sp[i]);
																 for(var j=0;j<drawGraph.links.length;j++){
																	if(drawGraph.links[j].source==sp[i] && drawGraph.links[j].target==sp[i+1]){
																		contained=1;
																		break;
																	}
																}
																	
																	if(contained==0){
																		var ed={};
																		ed.source=sp[i]; ed.target=sp[i+1]; ed.group=rank; ed.value=graph.findEdge(sp[i],sp[i+1]);
																		drawGraph.nGr=rank;
																		//console.log('ed');
																		//console.log(ed);
																		drawGraph.links.push(ed);
																	}			
															}
															usedNodes.add(sp[sp.length-1]);
															//drawGraph.endNode=sp[sp.length-1];
															rank=rank+1;
														}
														
														//create edges between all present nodes not on a path as default edges, code -1, grey color
														
														var unAr=usedNodes.values();
														
														for(var un1=0;un1<unAr.length-1;un1++){
															for(var un2=un1+1;un2<unAr.length;un2++){
															 var contained=0;
																 for(var j=0;j<drawGraph.links.length;j++){
																	if((drawGraph.links[j].source==unAr[un1] && drawGraph.links[j].target==unAr[un2]) || (drawGraph.links[j].source==unAr[un2] && drawGraph.links[j].target==unAr[un1])){
																		contained=1;
																		break;
																	}
																}
																if(contained==0 && graph.findEdge(unAr[un1],unAr[un2])<=threshold1){
																var ed={};
																		ed.source=unAr[un1]; ed.target=unAr[un2]; ed.group=-1; ed.value=graph.findEdge(unAr[un1],unAr[un2]);
																		drawGraph.links.push(ed);
																}
															}
														}
														
														var selReds=new Array();//redescriptions that need to be displayed
														
														for(var i=0;i<$scope.riscG.RedsInSOMClust.redescriptions.length;i++){
																if(usedNodes.contains($scope.riscG.RedsInSOMClust.redescriptions[i].id+""))
																		selReds.push($scope.riscG.RedsInSOMClust.redescriptions[i]);
														}
														
														var una = usedNodes.values();
														
														var mapping = new HashMap();
														
														var ind=0;
														for(var i=0;i<una.length;i++){
															mapping.set(una[i],ind);
															ind=ind+1;
															}
															
														for(var i=0;i<drawGraph.links.length;i++){
																drawGraph.links[i].source=mapping.get(drawGraph.links[i].source);
																drawGraph.links[i].target=mapping.get(drawGraph.links[i].target);
															}
														
														for(var i=0;i<una.length;i++){
															var n={};
															n.id=una[i];
															
															for(var j=0;j<selReds.length;j++)
																if(selReds[j].id+""==una[i]){
																	n.lq=selReds[j].data[0];
																	n.rq=selReds[j].data[1];
																	n.js=selReds[j].data[2];
																	n.supp=selReds[j].data[3];
																	n.pVal=selReds[j].data[4];
																} //uncomment when dealing with original data

															drawGraph.nodes.push(n);
														}
														
														console.log('scope');
														console.log($scope);
														//redIds.values();
													
														$scope.RedRelationGraphE=drawGraph;	//save graphINput to scope.graphInput variable	
														$scope.checkedOrderSOM.cos=[];
														$scope.graphInput = inputForAlgo;
														
														$('#redTable').each(function (i, row) {

															var $row = $(row),
														$checkedBoxes = $row.find('input:checked');

														$checkedBoxes.each(function (i, checkbox) {

														var $checkbox = $(checkbox);
														$checkbox.attr('checked', false); 
														});
													});
									
									});
											
									});
				
						//load the graph and compute the input for the algorithm, run the algorithm and draw the result.
					
				}
		  
				});
			}
			else{
			
													console.log("Algorithm input: ");
														console.log($scope.graphInput);
													 var inputForAlgo = $scope.graphInput;
														
														var threshold1=1-globalThreshold;//1-0.2;
														var forbiden1 = new HashSet();
														
														var present = new HashSet();
														
														for(var pr=0;pr<$scope.riscG.RedsInSOMClust.redescriptions.length;pr++)
																present.add($scope.riscG.RedsInSOMClust.redescriptions[pr].id);
																
														for(var pr=0;pr<$scope.numReds.numReds[0].numReds;pr++)
																if(!present.contains(pr))
																	forbiden1.add(pr+"");
														
														var pathsFinal = new PriorityQueue();
														var pathsCandidates = new PriorityQueue();
 														 var graph = new Graph(inputForAlgo,threshold1,forbiden1);
														 var inputArr = new Array();
														 
														 for(var t=0;t<$scope.checkedOrderSOM.cos.length;t++)
																inputArr[t]=$scope.checkedOrderSOM.cos[t]+"";
														 
														 var sp=graph.findShortestPath(inputArr);
														console.log('SP: ');
														console.log(sp);
														console.log('checked order: ');
														console.log($scope.checkedOrderSOM.cos);
														console.log('Forbiden nodes.');
														console.log(forbiden1.values());
													
													if(sp!=null){			
																var cost=0;
														for(var i=0;i<sp.length-1;i++){
																	cost = cost + graph.findEdge(sp[i],sp[i+1]);
															}
														
														sp.forbidenEdges=new Array();														
												
														sp.cost=cost;
														pathsFinal.push(cost,sp);
														pathsCandidates.push(cost,sp);
													}
														
														while(pathsFinal.length()<globalNumPaths){//10
																if(pathsCandidates.length()==0)
																		break;
															var tmpPath = pathsCandidates.pop();
															var startNodes = new Array();
															var endNodes = new Array();
															
															for(var i=0;i<tmpPath.forbidenEdges.length;i++){
																startNodes.push(tmpPath.forbidenEdges[i].s);
																endNodes.push(tmpPath.forbidenEdges[i].e);
															}
															
															for(var i=0;i<tmpPath.length-1;i++){
																	startNodes.push(tmpPath[i]);
																	endNodes.push(tmpPath[i+1]);
																	graph.setEdges(startNodes,endNodes);
																	
																	inputArr = new Array();
														 
														 for(var t=0;t<$scope.checkedOrderSOM.cos.length;t++)
																inputArr[t]=$scope.checkedOrderSOM.cos[t]+"";
																
																	var sp1=graph.findShortestPath(inputArr,forbiden1);
								
																	if(sp1!=null){
																	
																	sp1.forbidenEdges=new Array();
																	for(var j=0;j<startNodes.length;j++){
																		var ed={}; ed.s=startNodes[j]; ed.e=endNodes[j];
																		sp1.forbidenEdges.push(ed);
																	}
																		
																		cost=0;
																		for(var i=0;i<sp1.length-1;i++){
																			cost = cost + graph.findEdge(sp1[i],sp1[i+1]);
																	}
																	
																	sp1.cost=cost;
																	if(!pathsCandidates.contains(sp1))
																		pathsCandidates.push(cost,sp1);
																	}
																	
																	graph.restoreEdges(startNodes,endNodes);
																	startNodes.splice(startNodes.length-1,1);
																	endNodes.splice(endNodes.length-1,1);
															}
															
															if(pathsCandidates.length()==0)
																break;
															
															var spT=pathsCandidates.pop();
															if(!pathsFinal.contains(spT)){
																	pathsFinal.push(spT.cost,spT);//check if this path exists.
																	pathsCandidates.push(spT.cost,spT);
															}
															else{
																	while(pathsFinal.contains(spT)){
																		spT=pathsCandidates.pop();
																	}
																	if(spT!=null){
																	pathsFinal.push(spT.cost,spT);
																	pathsCandidates.push(spT.cost,spT);
																	}
															}
															
															//console.log('tmp path1: ');
															//console.log(spT);
														}
														
														var drawGraph={};
														drawGraph.nodes = new Array();
														drawGraph.links = new Array();
														var usedNodes = new HashSet();
														console.log('Paths: ');
														var rank=1;
														
														drawGraph.startNode = $scope.checkedOrderSOM.cos[0]+"";
														usedNodes.add($scope.checkedOrderSOM.cos[0]+"");
														drawGraph.endNode = $scope.checkedOrderSOM.cos[$scope.checkedOrderSOM.cos.length-1]+"";
														usedNodes.add($scope.checkedOrderSOM.cos[$scope.checkedOrderSOM.cos.length-1]+"");
														drawGraph.intermediary = new HashSet();
														for(var k=1;k<$scope.checkedOrderSOM.cos.length-1;k++){
															drawGraph.intermediary.add($scope.checkedOrderSOM.cos[k]+"");
															usedNodes.add($scope.checkedOrderSOM.cos[k]+"");
															}
														
														while(pathsFinal.length()>0){
															var sp = pathsFinal.pop();
															console.log(rank+'. '+sp);
															console.log(sp);
															console.log(sp.length);
															for(var i=0;i<sp.length-1;i++){
															//if(i==0)
															//drawGraph.startNode=sp[i];
																 var contained=0;
																 usedNodes.add(sp[i]);
																 for(var j=0;j<drawGraph.links.length;j++){
																	if(drawGraph.links[j].source==sp[i] && drawGraph.links[j].target==sp[i+1]){
																		contained=1;
																		break;
																	}
																}
																	
																	if(contained==0){
																		var ed={};
																		ed.source=sp[i]; ed.target=sp[i+1]; ed.group=rank; ed.value=graph.findEdge(sp[i],sp[i+1]);
																		drawGraph.nGr=rank;
																		//console.log('ed');
																		//console.log(ed);
																		drawGraph.links.push(ed);
																	}			
															}
															usedNodes.add(sp[sp.length-1]);
															//drawGraph.endNode=sp[sp.length-1];
															rank=rank+1;
														}
														
														//create edges between all present nodes not on a path as default edges, code -1, grey color
														
														var unAr=usedNodes.values();
														
														for(var un1=0;un1<unAr.length-1;un1++){
															for(var un2=un1+1;un2<unAr.length;un2++){
															 var contained=0;
																 for(var j=0;j<drawGraph.links.length;j++){
																	if((drawGraph.links[j].source==unAr[un1] && drawGraph.links[j].target==unAr[un2]) || (drawGraph.links[j].source==unAr[un2] && drawGraph.links[j].target==unAr[un1])){
																		contained=1;
																		break;
																	}
																}
																if(contained==0 && graph.findEdge(unAr[un1],unAr[un2])<=threshold1){
																var ed={};
																		ed.source=unAr[un1]; ed.target=unAr[un2]; ed.group=-1; ed.value=graph.findEdge(unAr[un1],unAr[un2]);
																		drawGraph.links.push(ed);
																}
															}
														}
														
														var selReds=new Array();//redescriptions that need to be displayed
														
														for(var i=0;i<$scope.riscG.RedsInSOMClust.redescriptions.length;i++){
																if(usedNodes.contains($scope.riscG.RedsInSOMClust.redescriptions[i].id+""))
																		selReds.push($scope.riscG.RedsInSOMClust.redescriptions[i]);
														}
														
														var una = usedNodes.values();
														
														var mapping = new HashMap();
														
														var ind=0;
														for(var i=0;i<una.length;i++){
															mapping.set(una[i],ind);
															ind=ind+1;
															}
															
														for(var i=0;i<drawGraph.links.length;i++){
																drawGraph.links[i].source=mapping.get(drawGraph.links[i].source);
																drawGraph.links[i].target=mapping.get(drawGraph.links[i].target);
															}
														
														for(var i=0;i<una.length;i++){
															var n={};
															n.id=una[i];
															
															for(var j=0;j<selReds.length;j++)
																if(selReds[j].id+""==una[i]){
																	n.lq=selReds[j].data[0];
																	n.rq=selReds[j].data[1];
																	n.js=selReds[j].data[2];
																	n.supp=selReds[j].data[3];
																	n.pVal=selReds[j].data[4];
																} //uncomment when dealing with original data

															drawGraph.nodes.push(n);
														}
														
														console.log('scope');
														console.log($scope);
														//redIds.values();
													
														$scope.RedRelationGraphE=drawGraph;	//save graphINput to scope.graphInput variable	
														$scope.checkedOrderSOM.cos=[];
														$scope.graphInput = inputForAlgo;
														
														$('#redTable').each(function (i, row) {

															var $row = $(row),
														$checkedBoxes = $row.find('input:checked');

														$checkedBoxes.each(function (i, checkbox) {

														var $checkbox = $(checkbox);
														$checkbox.attr('checked', false); 
														});
													});
			pload.style.visibility="hidden";
			$scope.$apply();
			
				//run the algorithm and draw the result.
			}
		}
		pload.style.visibility="hidden";
}

function JSON2CSV(objArray) {
    var array = typeof objArray != 'object' ? JSON.parse(objArray) : objArray;

    var str = '';
    var line = '';

    if ($("#labels").is(':checked')) {
        var head = array[0];
        if ($("#quote").is(':checked')) {
            for (var index in array[0]) {
                var value = index + "";
                line += '"' + value.replace(/"/g, '""') + '",';
            }
        } else {
            for (var index in array[0]) {
                line += index + ',';
            }
        }

        line = line.slice(0, -1);
        str += line + '\r\n';
    }

    for (var i = 0; i < array.length; i++) {
        var line = '';

        if ($("#quote").is(':checked')) {
            for (var index in array[i]) {
                var value = array[i][index] + "";
                line += '"' + value.replace(/"/g, '""') + '",';
            }
        } else {
            for (var index in array[i]) {
                line += array[i][index] + ',';
            }
        }

        line = line.slice(0, -1);
        str += line + '\r\n';
    }
    return str;
    
}

var globalVarE;

function exportFunctionE(){
	   var redJson=JSON.stringify(globalVarE.redescriptions);

		var csv = JSON2CSV(redJson);
	   
	   var blob = new Blob([csv], {type: "text/plain;charset=utf-8"});
		saveAs(blob, "redescriptions.csv");
	   
   };
   
   
var globalVarE1;

 function exportFunctionSuppE(){
 //console.log("globalVarE1");
 //console.log(globalVarE1);
	   var redJson=JSON.stringify(globalVarE1);

		var csv = JSON2CSV(redJson);
	   
	   var blob = new Blob([csv], {type: "text/plain;charset=utf-8"});
		saveAs(blob, "redescriptionSupport.csv");
	   
   }; 


var GlScope;
var databaseConfig="http://localhost:8081/redundancyAll";
var databaseConfigOld="http://localhost:8081/redundancyinfo";
var databaseConfig1="http://localhost:8081/redundancyinfo1";
//var Q = require('q');

var AllRedsAttrs="http://localhost:8081/redundancyAttrs";
var loadGraph="http://localhost:8081/graphDataAttr";
var saveGraphAttr="http://localhost:8081/graphDataAttr";
var saveGraphAttrG="http://localhost:8081/graphDataAttrG";
	
	function filteringE(pload,$scope, elOv, atOv){

	var toDelete = new HashSet();
					
					//sort reds
					$scope.riscG.RedsInSOMClust.redescriptions.sort(function(a, b){
					
					if(a.col3==b.col3){
						
						if(a.col5==b.col5){
							
							if(a.col4==b.col4){
									
									if(a.col5==b.col5){
										return a.col6-b.col6;
									}
									else{
										return a.col5-b.col5;
									}
									
							}
							else{
								return b.col4-a.col4;
							}
						
						}
						else{
							return a.col5-b.col5;
						}
						
					}
					else{
						return b.col3-a.col3;
					}
					
					});
	
	for(i=0;i<$scope.riscG.RedsInSOMClust.redescriptions.length-1;i++)
							for(j=i+1;j<$scope.riscG.RedsInSOMClust.redescriptions.length;j++){
								
								if(toDelete.contains($scope.riscG.RedsInSOMClust.redescriptions[j].id))
											continue;
								
								var perc=(i*$scope.riscG.RedsInSOMClust.redescriptions.length+j)/($scope.riscG.RedsInSOMClust.redescriptions.length*$scope.riscG.RedsInSOMClust.redescriptions.length)*100;
							
								
												var jsEl= 1.0-$scope.graphInput[$scope.riscG.RedsInSOMClust.redescriptions[i].id+""][$scope.riscG.RedsInSOMClust.redescriptions[j].id+""];
												//console.log("jsEl: "+jsEl);
												if(jsEl*100>=elOv){
												if($scope.riscG.RedsInSOMClust.redescriptions[i].data[2]>$scope.riscG.RedsInSOMClust.redescriptions[j].data[2]){
													toDelete.add($scope.riscG.RedsInSOMClust.redescriptions[j].id);
													     }
												else
													toDelete.add($scope.riscG.RedsInSOMClust.redescriptions[i].id);
													//break;
													}	

									
												
												var jsAt= 1.0-$scope.graphInputAttrs[$scope.riscG.RedsInSOMClust.redescriptions[i].id+""][$scope.riscG.RedsInSOMClust.redescriptions[j].id+""];
												//console.log("jsAt: "+jsAt);
												if(jsAt*100>=atOv){
												if($scope.riscG.RedsInSOMClust.redescriptions[i].data[2]>$scope.riscG.RedsInSOMClust.redescriptions[j].data[2]){
													toDelete.add($scope.riscG.RedsInSOMClust.redescriptions[j].id);
													     }
												else
													toDelete.add($scope.riscG.RedsInSOMClust.redescriptions[i].id);
													//break;
													}
													
							}
							
						//while(toDelete.size()>0){
							for(i=0;i<$scope.riscG.RedsInSOMClust.redescriptions.length;i++){
								if(toDelete.contains($scope.riscG.RedsInSOMClust.redescriptions[i].id)){
									toDelete.remove($scope.riscG.RedsInSOMClust.redescriptions[i].id);
									$scope.riscG.RedsInSOMClust.redescriptions.splice(i,1);
									i--;
								}
									
						//	}		
						}
	
			//pload.style.visibility="hidden";
	}
	
	function createAttrGraph($scope, dataAttrs){
		console.log('createAttrGraph function called!');
		/*var options = {url: AllRedsAttrs,
							method: 'GET', 
							params: {
								}
                          };
						  
						   var promise1=$scope.getRedsAttrs(options);
						   console.log('promise1');
						   console.log(promise1);
						   
						    promise1.success(function (data) {
							console.log('success get attrs!');
							console.log(data);
							$scope.RedsAttrs=data;
							$scope.error = '';
						})
							.error(function (data, status) {
							console.log('error get attrs!');
							if (status === 404) {
							$scope.error = 'REST server is offline!';
						} else {
								$scope.error = 'Error: ' + status;
							}
							}).then(function(){
							console.log('attributes recieved');
							console.log($scope.RedsAttrs);
							var redAttrs=new HashMap();
							console.log($scope.RedsAttrs);
							console.log('Q');
							console.log(Q);
						
						var promise3 = Q.all( [
						loadToStructAttrsE(redAttrs,$scope) //mozda ne treba
							])
						
						Q.allSettled(promise3).then(function(results){
						results.forEach(function(result){
						
						if (result.state === "fulfilled") {
								var redAttrs = result.value;*/
								
								var redAttrs = dataAttrs;
								
							var graphAttr= new HashMap();
							console.log("then part!");
							console.log(redAttrs);
							console.log(redAttrs.count());

							var i=0;
							var j=i+1;
							var numReds = redAttrs.count();
							var myVar=setInterval(function() {
									/*console.log("myVar function")
									console.log(i);
									console.log(j);*/
									var perc= (i/numReds)*100;
									
							document.getElementById("graphProg").innerHTML = "Graph computation: "+perc.toFixed(2)+"%";
								
								var set1 = redAttrs.get(i);
								
								for(j=i+1;j<numReds;j++){
								var set2 = redAttrs.get(j);
								
								var intersection=0;
								var set1val = set1.values();
								
								for(var z=0;z<set1val.length;z++)
									if(set2.contains(set1val[z]))
										intersection=intersection+1;
										
								var edge = intersection/(set1.size()+set2.size()-intersection);
								
								if(!graphAttr.has(i)){
									var t=new Array(numReds);
									t[i]=1.0;
									graphAttr.set(i,t);
								}
								
								if(!graphAttr.has(j)){
									var t=new Array(numReds);
									t[j]=1.0;
									graphAttr.set(j,t);
								}
								
								var t=graphAttr.get(i);
								t[j]=edge;
								graphAttr.set(i,t);
								
								t=graphAttr.get(j);
								t[i]=edge;
								graphAttr.set(j,t);
								}
								
			
								if(i==(numReds-1) && j==(numReds)){
										clearInterval(myVar);
										document.getElementById("graphProg").innerHTML = "Graph computation: "+"100%";
										console.log(graphAttr);
										
										var retData=new Array(graphAttr.count());
										
										for(var z=0;z<graphAttr.count();z++)
											retData[z]=graphAttr.get(z);
											
											console.log("retData");
											console.log(retData);
										
										options = {url: saveGraphAttr,
												method: 'POST', 
												params: {
													},
											    data: { graphAttr:  JSON.stringify(retData)		
											}
												};
												
										var promise5=$scope.setGraphData(options); //modificirati za attribute
										
										
										/*promise5.success(function (data) {
											console.log('Data stored succesfully!');
												$scope.error = '';
										})
										.error(function (data, status) {
										if (status === 404) {
											$scope.error = 'REST server is offline!';
										} else {
												$scope.error = 'Error: ' + status;
											}
											}).then(function(){
											
														var inputForAlgoAttr={};
														
														for(var i=0;i<retData.length;i++){
																var eds1={};
															for(var j=0;j<retData[i].length;j++){
																if(i==j)
																	continue;
																if(typeof retData[i][j] == 'undefined')
																	 continue;//retData[i][j]=0.0;//continue;
																	
																	eds1[j]=1.0-retData[i][j];
															}
																inputForAlgoAttr[i]=eds1;
														}
											
														$scope.checkedOrderSOM.cos=[];
														$scope.graphInputAttrs = inputForAlgoAttr;
											
														console.log("Create parameters and define scope variable here");//put watch on it in the scope.
														//retData[i][j] //use to implement filtering
																		//add three cases for attributes
															
											})*/
										
										var ret= new Array();
										ret.push(promise5);
										ret.push(retData);
										console.log('ret');
										console.log(ret);
										
										return ret; //do the resolve inside element graph construction
											}
											i=i+1;
							}, 5);	
							//}
						//	})
						//})							
									//compute the graph, save the graph and compute the input for the algorithm, run the algorithm and draw the result.
						//	})
	}
	
	
	var getInPartsAttr = function(startIndex, endIndex, numReds, $scope){
				if(typeof($scope.graphInputAttrs)=='undefined')
						$scope.graphInputAttrs = [];
					return Q.spread([startIndex, endIndex, $scope], function(startIndex, endIndex,$scope){
							var options = {url: saveGraphAttr,
												method: 'GET', 
												params: {
													start: JSON.stringify(startIndex),
													end: JSON.stringify(endIndex),
													nr: JSON.stringify(numReds)
													}
												};
												
									var tmpPromise = $scope.getGraphData(options);	
									
									return tmpPromise;
									
									var tmpRes;
									
									tmpPromise.success(function (data) {
											tmpRes=data;
											console.log('data');
											console.log(tmpRes);
												$scope.error = '';
										})
										.error(function (data, status) {
										if (status === 404) {
											$scope.error = 'REST server is offline!';
										} else {
												$scope.error = 'Error: ' + status;
											}
											}).then(function(){
											
											console.log('got a part of data');
											console.log(tmpRes);
											var tmp=new Array();
											
											
											
											return tmp;
											//convert to HashMap arrayList
											
											});
												
					})
				};
	
	function getAttrGraph($scope){
		
		var numredsLink="http://localhost:8081/numReds";
				
				var optionsNR = {url: numredsLink,
								 method: 'GET',
								 params: {}
								 };
								 
				var promiseNR = $scope.generalGETRequest(optionsNR);
				
				
				promiseNR.success(function (data) {
											$scope.numReds = data;
												$scope.error = '';
										})
										.error(function (data, status) {
										if (status === 404) {
											$scope.error = 'REST server is offline!';
										} else {
												$scope.error = 'Error: ' + status;
											}
											}).then(function(){
											
											console.log('num reds:');
											console.log($scope.numReds); 
											console.log($scope.numReds.numReds[0].numReds);
											
											var numReds = $scope.numReds.numReds[0].numReds;
											//convert to HashMap arrayList
											
											var totalNumber = numReds*numReds;
											var numRedsinBucket = Math.floor(2571800/numReds);
											console.log('numRedsInBucket: '+numRedsinBucket);
											var numIters = Math.ceil(totalNumber/(numRedsinBucket*parseInt(numReds)));
											console.log('numIters: '+numIters);

									var promises=new Array();
									
									for(var parts=0;parts<numIters;parts++){
									var startIndex = parts*numRedsinBucket;
									var endIndex = (parts+1)*numRedsinBucket;
									if(endIndex>numReds)
										endIndex=numReds;
										promises.push(getInPartsAttr(startIndex,endIndex,numReds,$scope));
									}
									
									var joinedPromise = Q.all(promises);
									return joinedPromise;
	});
}
	
  function filterRedsNewE(){

  var checkTable="http://localhost:8081/checkTable";
  var checkTableAttrs="http://localhost:8081/checkTableAttrs";
  var numredsLink="http://localhost:8081/numReds";
  var AllRedsSupps="http://localhost:8081/redundancySupp";
  var loadGraph="http://localhost:8081/graphData";
  var saveGraph="http://localhost:8081/graphData";
  var saveGraphG="http://localhost:8081/graphDataG";
  //var numredsLink="http://localhost:8081/numReds";
  
   var pload=document.getElementById("loader");
  //pload.style.visibility="visible";
  var appElement = document.querySelector('[ng-app=redApp]');
   var $scope = angular.element(appElement).scope();
   
    var elOv=$("#eoverIn").val(); var atOv=$("#atoverIn").val();
	
		console.log('FRN called!');
		console.log($scope.riscG.RedsInSomClust);
	
	//add computing/loading part for element/attribute overlap
	
	
	/*var optionsNR = {url: numredsLink,
					method: 'GET',
					params: {}
							};
								 
		var promiseNR = $scope.generalGETRequest(optionsNR);
				
				
						promiseNR.success(function (data) {
					   $scope.numReds = data;
					   $scope.error = '';
									})
								.error(function (data, status) {
									if (status === 404) {
											$scope.error = 'REST server is offline!';
											} else {
												$scope.error = 'Error: ' + status;
													}
												}).then(function(){*/
	
			//if($scope.numReds.numReds[0].numReds<3500){
	
			if(typeof $scope.graphInput=='undefined'){
		
		var options = {url: checkTable,
               method: 'GET', 
               params: {
                        }
                          };
						  
				 var promise=$scope.getCheckTable(options);//$scope.getRedundancyInfo(options);
						  promise.success(function (data) {
				$scope.TableExist=data;
                $scope.error = '';
           })
          .error(function (data, status) {
              if (status === 404) {
                $scope.error = 'REST server is offline!';
              } else {
                $scope.error = 'Error: ' + status;
              }
          }).then(function(){
		  
		  console.log($scope.TableExist);
		  
				if($scope.TableExist.count[0].number==0){
					
					options = {url: AllRedsSupps,
							method: 'GET', 
							params: {
								}
                          };
						  
						   var promise1=$scope.getRedsSupps(options);
						    promise1.success(function (data) {
							$scope.RedsSupps=data;
							$scope.error = '';
						})
							.error(function (data, status) {
							if (status === 404) {
							$scope.error = 'REST server is offline!';
						} else {
								$scope.error = 'Error: ' + status;
							}
							}).then(function(){
													
							var redSupps=new HashMap();
							console.log($scope.RedsSupps);
							console.log('Q');
							console.log(Q);
								
						var promise3 = Q.all( [
						loadToStructE(redSupps,$scope)
							])
						
						Q.allSettled(promise3).then(function(results){
						results.forEach(function(result){
						
						if (result.state === "fulfilled") {
								var redSupps = result.value;
								
							var graph= new HashMap();
							console.log("then part!");
							console.log(redSupps);
							console.log(redSupps.count());

							var i=0;
							var j=i+1;
							var numReds = redSupps.count();
							var myVar=setInterval(function() {
									/*console.log("myVar function")
									console.log(i);
									console.log(j);*/
									var perc= (i/numReds)*100;
									
							document.getElementById("graphProg").innerHTML = "Graph computation: "+perc.toFixed(2)+"%";
								
								var set1 = redSupps.get(i);
								
								for(j=i+1;j<numReds;j++){
								var set2 = redSupps.get(j);
								
								var intersection=0;
								var set1val = set1.values();
								
								for(var z=0;z<set1val.length;z++)
									if(set2.contains(set1val[z]))
										intersection=intersection+1;
										
								var edge = intersection/(set1.size()+set2.size()-intersection);
								
								if(!graph.has(i)){
									var t=new Array(numReds);
									t[i]=1.0;
									graph.set(i,t);
								}
								
								if(!graph.has(j)){
									var t=new Array(numReds);
									t[j]=1.0;
									graph.set(j,t);
								}
								
								var t=graph.get(i);
								t[j]=edge;
								graph.set(i,t);
								
								t=graph.get(j);
								t[i]=edge;
								graph.set(j,t);
								}
								
			
								if(i==(numReds-1) && j==(numReds)){
										clearInterval(myVar);
										document.getElementById("graphProg").innerHTML = "Graph computation: "+"100%";
										console.log(graph);
										
										var totalNumberP = parseInt(graph.count())*parseInt(graph.count());
										var numRedsinBucketP = Math.floor(2571800/parseInt(graph.count()));//2571800
										var numItersP = Math.ceil(totalNumberP/(numRedsinBucketP*parseInt(graph.count())));
										console.log('Num iters: '+numItersP);
								var promisesP=new Array();
								var retDataAll=new Array(graph.count());
								for(var parts=0;parts<numItersP;parts++){
									var startIndex = parts*numRedsinBucketP;
									var endIndex = startIndex + numRedsinBucketP;
									var size = numRedsinBucketP;
									
									if(endIndex>=graph.count()){
										var diff = endIndex - graph.count();
										size = size-diff;
									}
									
									console.log(endIndex);
									console.log(size);
									
									var retData=new Array(size/*graph.count()*/);
									
									var dat;
										
										for(var z=startIndex;z<startIndex+size/*numRedsinBucketP*//*graph.count()*/;z++)//2000
											retData[z-startIndex]=graph.get(z);
											retDataAll[z]=graph.get(z);;
											console.log("retData");
												console.log(retData);
											
											options = {url: saveGraphG,
												method: 'POST', 
												params: {
													},
											    data: { graph:  JSON.stringify(retData), start: startIndex		
											}
												};

												
												
										promisesP.push($scope.setGraphData(options));
									}
									
											
										
										
												
										//var promise5=$scope.setGraphData(options);
										
										
										/*promise5.success(function (data) {
											console.log('Data stored succesfully!');
												$scope.error = '';
										})
										.error(function (data, status) {
										if (status === 404) {
											$scope.error = 'REST server is offline!';
										} else {
												$scope.error = 'Error: ' + status;
											}
											})*/
											var promise5 = Q.all(promisesP).then(function(){
														retData = retDataAll;
														var inputForAlgo={};
														
														for(var i=0;i<retData.length;i++){
																var eds1={};
															for(var j=0;j<retData[i].length;j++){
																if(i==j)
																	continue;
																if(typeof retData[i][j] == 'undefined')
																	 continue;//retData[i][j]=0.0;//continue;
																	
																	eds1[j]=1.0-retData[i][j];
															}
																inputForAlgo[i]=eds1;
														}
											
														$scope.checkedOrderSOM.cos=[];
														$scope.graphInput = inputForAlgo;
											
														console.log("Create parameters and define scope variable here");//put watch on it in the scope.
														//retData[i][j] //use to implement filtering
																		//add three cases for attributes
																		
														if(typeof $scope.graphInputAttrs=='undefined'){
		
																var options = {url: checkTableAttrs,
																				method: 'GET', 
																				params: {
																					}
																				};
						  
																var promiseCT=$scope.getCheckTable(options);//$scope.getRedundancyInfo(options);
																	promiseCT.success(function (data) {
																	$scope.TableExistAttrs=data;
																	$scope.error = '';
																				})
																	.error(function (data, status) {
																		if (status === 404) {
																			$scope.error = 'REST server is offline!';
																			} else {
																			$scope.error = 'Error: ' + status;
																			}
																	}).then(function(){
																		
																		console.log('table exists attrs');
																		console.log($scope.TableExistAttrs);
		  
																			if($scope.TableExistAttrs.count[0].number==0){
																					
																					var optionsAttr = {url: AllRedsAttrs,
																											method: 'GET', 
																											params: {
																												}
																											};
						  
																					var promise1=$scope.getRedsAttrs(optionsAttr);
																					console.log('promise1');
																					console.log(promise1);
						   
																					promise1.success(function (data) {
																							console.log('success get attrs!');
																							console.log(data);
																							$scope.RedsAttrs=data;
																							$scope.error = '';
																								})
																							.error(function (data, status) {
																								console.log('error get attrs!');
																							if (status === 404) {
																								$scope.error = 'REST server is offline!';
																							} else {
																								$scope.error = 'Error: ' + status;
																								}
																							}).then(function(){
																									console.log('attributes recieved');
																									console.log($scope.RedsAttrs);
																									var redAttrs=new HashMap();
																									console.log($scope.RedsAttrs);
																									console.log('Q');
																									console.log(Q);
						
																										var promise3 = Q.all( [
																												loadToStructAttrsE(redAttrs,$scope) //mozda ne treba
																													])
						
																										Q.allSettled(promise3).then(function(results){
																												results.forEach(function(result){
						
																												if (result.state === "fulfilled") {
																														var redAttrs = result.value;
																														console.log('result Attr');
																														console.log(result.value);
								
																							var graphAttr= new HashMap();
																									console.log("then part!");
																									console.log(redAttrs);
																									console.log(redAttrs.count());

																										var i=0;
																										var j=i+1;
																								var numReds = redAttrs.count();
																								
																						var myVar=setInterval(function() {

																							var perc= (i/numReds)*100;
										
																								document.getElementById("graphProg").innerHTML = "Graph computation: "+perc.toFixed(2)+"%";
								
																							var set1 = redAttrs.get(i);
								
																						for(j=i+1;j<numReds;j++){
																								var set2 = redAttrs.get(j);
								
																								var intersection=0;
																								var set1val = set1.values();
								
																							for(var z=0;z<set1val.length;z++)
																									if(set2.contains(set1val[z]))
																											intersection=intersection+1;
										
																										var edge = intersection/(set1.size()+set2.size()-intersection);
								
																									if(!graphAttr.has(i)){
																											var t=new Array(numReds);
																											t[i]=1.0;
																											graphAttr.set(i,t);
																										}
									
																									if(!graphAttr.has(j)){
																											var t=new Array(numReds);
																												t[j]=1.0;
																												graphAttr.set(j,t);
																											}
								
																									var t=graphAttr.get(i);
																										t[j]=edge;
																										graphAttr.set(i,t);
								
																										t=graphAttr.get(j);
																										t[i]=edge;
																										graphAttr.set(j,t);
																									}
								
			
																			if(i==(numReds-1) && j==(numReds)){
																					clearInterval(myVar);
																					document.getElementById("graphProg").innerHTML = "Graph computation: "+"100%";
																					console.log(graphAttr);
										
																					/*var retData=new Array(graphAttr.count());
										
																					for(var z=0;z<graphAttr.count();z++)
																						retData[z]=graphAttr.get(z);
											
																						console.log("retData");
																						console.log(retData);
										
																						options = {url: saveGraphAttr,
																								method: 'POST', 
																								params: {
																								},
																							data: { graphAttr:  JSON.stringify(retData)		
																						}
																					};*/
																					
																					
										var totalNumberP = parseInt(graphAttr.count())*parseInt(graphAttr.count());
										var numRedsinBucketP = Math.floor(2571800/parseInt(graphAttr.count()));//2571800
										var numItersP = Math.ceil(totalNumberP/(numRedsinBucketP*parseInt(graphAttr.count())));
										console.log('Num iters: '+numItersP);
								
								var promisesP=new Array();
								var retDataAll=new Array(graphAttr.count());
								for(var parts=0;parts<numItersP;parts++){
									var startIndex = parts*numRedsinBucketP;
									var endIndex = startIndex + numRedsinBucketP;
									var size = numRedsinBucketP;
									
									if(endIndex>=graphAttr.count()){
										var diff = endIndex - graphAttr.count();
										size = size-diff;
									}
									
									console.log(endIndex);
									console.log(size);
									
									var retData=new Array(size/*graphAttr.count()*/);
									
									var dat;
										
										for(var z=startIndex;z<startIndex+size/*numRedsinBucketP*//*graphAttr.count()*/;z++)//2000
											retData[z-startIndex]=graphAttr.get(z);
											retDataAll[z]=graphAttr.get(z);;
											console.log("retData");
												console.log(retData);
											
											options = {url: saveGraphAttrG,
												method: 'POST', 
												params: {
													},
											    data: { graphAttr:  JSON.stringify(retData), start: startIndex		
											}
												};

												
												
										promisesP.push($scope.setGraphData(options));
									}
									
											
										
										
												
										//var promise5=$scope.setGraphData(options);
										
										
										/*promise5.success(function (data) {
											console.log('Data stored succesfully!');
												$scope.error = '';
										})
										.error(function (data, status) {
										if (status === 404) {
											$scope.error = 'REST server is offline!';
										} else {
												$scope.error = 'Error: ' + status;
											}
											})*/
											//var gcpromise=$scope.setGraphData(options); 
											var gcpromise = Q.all(promisesP).then(function(){
																					retData = retDataAll;
																					/*gcpromise.success(function (data) {
																						console.log('Data stored succesfully!');
																						$scope.error = '';
																						})
																						.error(function (data, status) {
																						if (status === 404) {
																								$scope.error = 'REST server is offline!';
																						} else {
																								$scope.error = 'Error: ' + status;
																								}
																						}).then(function(){*/
											
																								var inputForAlgoAttrs={};
														
																								for(var i=0;i<retData.length;i++){
																										var eds1={};
																										for(var j=0;j<retData[i].length;j++){
																											if(i==j)
																												continue;
																											if(typeof retData[i][j] == 'undefined')
																												continue;//retData[i][j]=0.0;//continue;
																	
																											eds1[j]=1.0-retData[i][j];
																										}
																									inputForAlgoAttrs[i]=eds1;
																									}
											
																											$scope.checkedOrderSOM.cos=[];
																											$scope.graphInputAttrs = inputForAlgoAttrs;
																											
																											//use graphInput and graphInputAttrs
																											filteringE(pload,$scope,elOv,atOv);
																											$scope.$apply();
																											});
																									}
																									
																									i=i+1;
																								  },5)
																								}
																							})
																					})
																				})																					
																			}
																			else{
																				
																					var optionsNR = {url: numredsLink,
																										method: 'GET',
																										params: {}
																									};
								 
																					var promiseNR = $scope.generalGETRequest(optionsNR);
				
				
																						promiseNR.success(function (data) {
																										$scope.numReds = data;
																										$scope.error = '';
																							})
																									.error(function (data, status) {
																									if (status === 404) {
																											$scope.error = 'REST server is offline!';
																									} else {
																										$scope.error = 'Error: ' + status;
																										}
																									}).then(function(){
											
																										console.log('num reds:');
																										console.log($scope.numReds); 
																										console.log($scope.numReds.numReds[0].numReds);
											
																										var numReds = $scope.numReds.numReds[0].numReds;																				
																					
																										//var promiseGR=getAttrGraph($scope);

																														var totalNumber = numReds*numReds;
																														var numRedsinBucket = Math.floor(2571800/numReds);
																														console.log('numRedsInBucket: '+numRedsinBucket);
																														var numIters = Math.ceil(totalNumber/(numRedsinBucket*parseInt(numReds)));
																														console.log('numIters: '+numIters);

																														var promises=new Array();
									
																															for(var parts=0;parts<numIters;parts++){
																																	var startIndex = parts*numRedsinBucket;
																																	var endIndex = (parts+1)*numRedsinBucket;
																																		if(endIndex>numReds)
																																				endIndex=numReds;
																																				promises.push(getInPartsAttr(startIndex,endIndex,numReds,$scope));
																																			}
									
																															var joinedPromise = Q.all(promises);
																										
																										joinedPromise.then(function(values){
									
																													console.log('All data received!');
																													console.log('values');
																													console.log(values);
									
																													var inputAttrs = [];
									
																													console.log('computing input: ');
																													console.log('values length: '+values.length);
																													console.log('graph length: '+values[0].data.GraphDataAttr.length);
									
																														for(var iv=0;iv<values.length;iv++){
																																		for(var iv1=0;iv1<values[iv].data.GraphDataAttr.length;iv1++)
																																				inputAttrs.push(values[iv].data.GraphDataAttr[iv1]);
																																						console.log(inputAttrs.length);
																														}
									
																															console.log('joined input: ');
																															console.log(inputAttrs);
										
																															values=[];
	
																															console.log("Create parameters and define scope variable here");//put watch on it in the scope.
														
																															var inputForAlgoAttrs={};
														
																																for(var i=0;i<inputAttrs.length;i++){
																																				var eds1={};
																																		for(var j=0;j<inputAttrs[i].length;j++){
																																				if(i==j)
																																					continue;
																																				if(typeof inputAttrs[i][j] == 'undefined')
																																					continue;//retData[i][j]=0.0;//continue;
																	
																																				eds1[j]=1.0-inputAttrs[i][j];
																																				}
																																			inputForAlgoAttrs[i]=eds1;
																																			}

																																			$scope.checkedOrderSOM.cos=[];
																																			$scope.graphInputAttrs = inputForAlgoAttrs;
																																			filteringE(pload,$scope,elOv,atOv);
																																			$scope.$apply();
																																		//add three cases for attributes
																																		//use GraphInput and GraphInputAttrs
																																});
																														});
																								}
																							})
																					}
															else{
															filteringE(pload,$scope,elOv,atOv);
															$scope.$apply();
																//use graphInput and graphInputAttrs
															}
															
											})
										
										
										return;
											}
											
											i=i+1;
							}, 5);	
							}
							})
						})							
									//compute the graph, save the graph and compute the input for the algorithm, run the algorithm and draw the result.
							})
							
							}
				else{
				
				var getInParts = function(startIndex, endIndex, numReds, $scope){
				if(typeof($scope.rawGraph)=='undefined')
						$scope.rawGraph = [];
					return Q.spread([startIndex, endIndex, $scope], function(startIndex, endIndex,$scope){
							var options = {url: saveGraph,
												method: 'GET', 
												params: {
													start: JSON.stringify(startIndex),
													end: JSON.stringify(endIndex),
													nr: JSON.stringify(numReds)
													}
												};
												
									var tmpPromise = $scope.getGraphData(options);	
									
									return tmpPromise;
									
									var tmpRes;
									
									tmpPromise.success(function (data) {
											tmpRes=data;
											console.log('data');
											console.log(tmpRes);
												$scope.error = '';
										})
										.error(function (data, status) {
										if (status === 404) {
											$scope.error = 'REST server is offline!';
										} else {
												$scope.error = 'Error: ' + status;
											}
											}).then(function(){
											
											console.log('got a part of data');
											console.log(tmpRes);
											var tmp=new Array();
											
											
											
											return tmp;
											//convert to HashMap arrayList
											
											});
												
					})
				};
				
				var optionsNR = {url: numredsLink,
								 method: 'GET',
								 params: {}
								 };
								 
				var promiseNR = $scope.generalGETRequest(optionsNR);
				
				
				promiseNR.success(function (data) {
											$scope.numReds = data;
												$scope.error = '';
										})
										.error(function (data, status) {
										if (status === 404) {
											$scope.error = 'REST server is offline!';
										} else {
												$scope.error = 'Error: ' + status;
											}
											}).then(function(){
											
											console.log('num reds:');
											console.log($scope.numReds); 
											console.log($scope.numReds.numReds[0].numReds);
											
											var numReds = $scope.numReds.numReds[0].numReds;
											//convert to HashMap arrayList
											
											var totalNumber = numReds*numReds;
											var numRedsinBucket = Math.floor(2571800/numReds);
											console.log('numRedsInBucket: '+numRedsinBucket);
											var numIters = Math.ceil(totalNumber/(numRedsinBucket*parseInt(numReds)));
											console.log('numIters: '+numIters);

									var promises=new Array();
									
									for(var parts=0;parts<numIters;parts++){ // change back
									var startIndex = parts*numRedsinBucket;
									var endIndex = (parts+1)*numRedsinBucket;
									if(endIndex>numReds)
										endIndex=numReds;
										promises.push(getInParts(startIndex,endIndex,numReds,$scope));
									}
									
									var joinedPromise = Q.all(promises).then(function(values){
									
									console.log('All data received!');
									console.log('values');
									console.log(values);
									
									var input = [];
									
									console.log('computing input: ');
									console.log('values length: '+values.length);
									console.log('graph length: '+values[0].data.GraphData.length);
									
									for(var iv=0;iv<values.length;iv++){
											for(var iv1=0;iv1<values[iv].data.GraphData.length;iv1++)
												input.push(values[iv].data.GraphData[iv1]);
												console.log(input.length);
									}
									
										console.log('joined input: ');
										console.log(input);
										
										values=[];
	
										console.log("Create parameters and define scope variable here");//put watch on it in the scope.
														
														var inputForAlgo={};
														
														for(var i=0;i<input.length;i++){
																var eds1={};
															for(var j=0;j<input[i].length;j++){
																if(i==j)
																	continue;
																if(typeof input[i][j] == 'undefined')
																	 continue;//retData[i][j]=0.0;//continue;
																	
																	eds1[j]=1.0-input[i][j];
															}
																inputForAlgo[i]=eds1;
														}

														$scope.checkedOrderSOM.cos=[];
														$scope.graphInput = inputForAlgo;
														//add three cases for attributes
														
													if(typeof $scope.graphInputAttrs=='undefined'){
		
																var options = {url: checkTableAttrs,
																				method: 'GET', 
																				params: {
																					}
																				};
						  
																var promiseCT=$scope.getCheckTable(options);//$scope.getRedundancyInfo(options);
																	promiseCT.success(function (data) {
																	$scope.TableExistAttrs=data;
																	$scope.error = '';
																				})
																	.error(function (data, status) {
																		if (status === 404) {
																			$scope.error = 'REST server is offline!';
																			} else {
																			$scope.error = 'Error: ' + status;
																			}
																	}).then(function(){
																		
																		console.log('table exists attrs');
																		console.log($scope.TableExistAttrs);
																		//$scope.TableExistAttrs.count[0].number=0; //for testing purpose only
																			if($scope.TableExistAttrs.count[0].number==0){//change attribute get
																					
																					var optionsAttr = {url: AllRedsAttrs,
																											method: 'GET', 
																											params: {
																												}
																											};
						  
																					var promise1=$scope.getRedsAttrs(optionsAttr);
																					console.log('promise1');
																					console.log(promise1);
						   
																					promise1.success(function (data){
																							console.log('success get attrs!');
																							console.log(data);
																							$scope.RedsAttrs=data;
																							$scope.error = '';
																								})
																							.error(function (data, status) {
																								console.log('error get attrs!');
																							if (status === 404) {
																								$scope.error = 'REST server is offline!';
																							} else {
																								$scope.error = 'Error: ' + status;
																								}
																							}).then(function(){
																									console.log('attributes recieved');
																									console.log($scope.RedsAttrs);
																									var redAttrs=new HashMap();
																									console.log($scope.RedsAttrs);
																									console.log('Q');
																									console.log(Q);
						
																										var promise3 = Q.all( [
																												loadToStructAttrsE(redAttrs,$scope) //mozda ne treba
																													])
						
																										Q.allSettled(promise3).then(function(results){
																												results.forEach(function(result){
						
																												if (result.state === "fulfilled") {
																														var redAttrs = result.value;
																														console.log('result Attr');
																														console.log(result.value);

																							var graphAttr= new HashMap();
																									console.log("then part!");
																									console.log(redAttrs);
																									console.log(redAttrs.count());

																										var i=0;
																										var j=i+1;
																								var numReds = redAttrs.count();
																								
																						var myVar=setInterval(function() {

																							var perc= (i/numReds)*100;
										
																								document.getElementById("graphProg").innerHTML = "Graph computation: "+perc.toFixed(2)+"%";
								
																							var set1 = redAttrs.get(i);
								
																						for(j=i+1;j<numReds;j++){
																								var set2 = redAttrs.get(j);
								
																								var intersection=0;
																								var set1val = set1.values();
								
																							for(var z=0;z<set1val.length;z++)
																									if(set2.contains(set1val[z]))
																											intersection=intersection+1;
										
																										var edge = intersection/(set1.size()+set2.size()-intersection);
								
																									if(!graphAttr.has(i)){
																											var t=new Array(numReds);
																											t[i]=1.0;
																											graphAttr.set(i,t);
																										}
									
																									if(!graphAttr.has(j)){
																											var t=new Array(numReds);
																												t[j]=1.0;
																												graphAttr.set(j,t);
																											}
								
																									var t=graphAttr.get(i);
																										t[j]=edge;
																										graphAttr.set(i,t);
								
																										t=graphAttr.get(j);
																										t[i]=edge;
																										graphAttr.set(j,t);
																									}
								
			
																			if(i==(numReds-1) && j==(numReds)){//change
																					clearInterval(myVar);
																					document.getElementById("graphProg").innerHTML = "Graph computation: "+"100%";
																					console.log(graphAttr);
										
																					//var retData=new Array(graphAttr.count());
										
																					var totalNumberP = parseInt(graphAttr.count())*parseInt(graphAttr.count());
																					var numRedsinBucketP = Math.floor(2571800/parseInt(graphAttr.count()));//2571800
																					var numItersP = Math.ceil(totalNumberP/(numRedsinBucketP*parseInt(graphAttr.count())));
																					console.log('Num iters: '+numItersP);
																				
																					var promisesP=new Array();
																					var retDataAll=new Array(graphAttr.count());
																					for(var parts=0;parts<numItersP;parts++){
																						var startIndex = parts*numRedsinBucketP;
																						var endIndex = startIndex + numRedsinBucketP;
																						var size = numRedsinBucketP;
									
																						if(endIndex>=graphAttr.count()){
																							var diff = endIndex - graphAttr.count();
																							size = size-diff;
																						}
																						
																						console.log(endIndex);
																						console.log(size);
																						
																						var retData=new Array(size/*graphAttr.count()*/);
																						
																						var dat;
										
																							for(var z=startIndex;z<startIndex+size/*numRedsinBucketP*//*graphAttr.count()*/;z++)//2000
																								retData[z-startIndex]=graphAttr.get(z);
																								retDataAll[z]=graphAttr.get(z);;
																								console.log("retData");
																									console.log(retData);
																								
																								options = {url: saveGraphAttrG,
																									method: 'POST', 
																									params: {
																										},
																									data: { graphAttr:  JSON.stringify(retData), start: startIndex		
																								}
																									};

																									
																									
																							promisesP.push($scope.setGraphData(options));
																						}
																						
											var gcpromise = Q.all(promisesP).then(function(){
										
																			retData = retDataAll;
											
																								var inputForAlgoAttrs={};
														
																								for(var i=0;i<retData.length;i++){
																										var eds1={};
																										for(var j=0;j<retData[i].length;j++){
																											if(i==j)
																												continue;
																											if(typeof retData[i][j] == 'undefined')
																												continue;//retData[i][j]=0.0;//continue;
																	
																											eds1[j]=1.0-retData[i][j];
																										}
																									inputForAlgoAttrs[i]=eds1;
																									}
											
																											$scope.checkedOrderSOM.cos=[];
																											$scope.graphInputAttrs = inputForAlgoAttrs;
																											
																											//use graphInput and graphInputAttrs
																											filteringE(pload,$scope,elOv,atOv);
																											$scope.$apply();
																											});
																									}
																									
																									i=i+1;
																								  },5)
																								}
																							})
																					})
																				})																					
																			}
																			else{
																				
																					var optionsNR = {url: numredsLink,
																										method: 'GET',
																										params: {}
																									};
								 
																					var promiseNR = $scope.generalGETRequest(optionsNR);
				
				
																						promiseNR.success(function (data) {
																										$scope.numReds = data;
																										$scope.error = '';
																							})
																									.error(function (data, status) {
																									if (status === 404) {
																											$scope.error = 'REST server is offline!';
																									} else {
																										$scope.error = 'Error: ' + status;
																										}
																									}).then(function(){
											
																										console.log('num reds:');
																										console.log($scope.numReds); 
																										console.log($scope.numReds.numReds[0].numReds);
											
																										var numReds = $scope.numReds.numReds[0].numReds;																				
																					
																										//var promiseGR=getAttrGraph($scope);

																														var totalNumber = numReds*numReds;
																														var numRedsinBucket = Math.floor(2571800/numReds);
																														console.log('numRedsInBucket: '+numRedsinBucket);
																														var numIters = Math.ceil(totalNumber/(numRedsinBucket*parseInt(numReds)));
																														console.log('numIters: '+numIters);

																														var promises=new Array();
									
																															for(var parts=0;parts<numIters;parts++){
																																	var startIndex = parts*numRedsinBucket;
																																	var endIndex = (parts+1)*numRedsinBucket;
																																		if(endIndex>numReds)
																																				endIndex=numReds;
																																				promises.push(getInPartsAttr(startIndex,endIndex,numReds,$scope));
																																			}
									
																															var joinedPromise = Q.all(promises);
																										
																										joinedPromise.then(function(values){
									
																													console.log('All data received!');
																													console.log('values');
																													console.log(values);
									
																													var inputAttrs = [];
									
																													console.log('computing input: ');
																													console.log('values length: '+values.length);
																													console.log('graph length: '+values[0].data.GraphDataAttr.length);
									
																														for(var iv=0;iv<values.length;iv++){
																																		for(var iv1=0;iv1<values[iv].data.GraphDataAttr.length;iv1++)
																																				inputAttrs.push(values[iv].data.GraphDataAttr[iv1]);
																																						console.log(inputAttrs.length);
																														}
									
																															console.log('joined input: ');
																															console.log(inputAttrs);
										
																															values=[];
	
																															console.log("Create parameters and define scope variable here");//put watch on it in the scope.
														
																															var inputForAlgoAttrs={};
														
																																for(var i=0;i<inputAttrs.length;i++){
																																				var eds1={};
																																		for(var j=0;j<inputAttrs[i].length;j++){
																																				if(i==j)
																																					continue;
																																				if(typeof inputAttrs[i][j] == 'undefined')
																																					continue;//retData[i][j]=0.0;//continue;
																	
																																				eds1[j]=1.0-inputAttrs[i][j];
																																				}
																																			inputForAlgoAttrs[i]=eds1;
																																			}

																																			$scope.checkedOrderSOM.cos=[];
																																			$scope.graphInputAttrs = inputForAlgoAttrs;
																																			filteringE(pload,$scope,elOv,atOv);
																																			$scope.$apply();
																																		//add three cases for attributes
																																		//use GraphInput and GraphInputAttrs
																																});
																														});
																								}
																							})
																					}
															else{
															filteringE(pload,$scope,elOv,atOv);
															$scope.$apply();
																//use graphInput and graphInputAttrs
															}			
									
									});
											
									});
				
						//load the graph and compute the input for the algorithm, run the algorithm and draw the result.
					
				}
		  
				});
			}
			else{
			//use graphInput for filtering
													console.log("Algorithm input: ");
														console.log($scope.graphInput);
													 var inputForAlgo = $scope.graphInput;
														
														
														$scope.checkedOrderSOM.cos=[];
														$scope.graphInput = inputForAlgo;
														//add three cases for attributes
														
											if(typeof $scope.graphInputAttrs=='undefined'){
		
																var options = {url: checkTableAttrs,
																				method: 'GET', 
																				params: {
																					}
																				};
						  
																var promiseCT=$scope.getCheckTable(options);//$scope.getRedundancyInfo(options);
																	promiseCT.success(function (data) {
																	$scope.TableExistAttrs=data;
																	$scope.error = '';
																				})
																	.error(function (data, status) {
																		if (status === 404) {
																			$scope.error = 'REST server is offline!';
																			} else {
																			$scope.error = 'Error: ' + status;
																			}
																	}).then(function(){
																		
																		console.log('table exists attrs');
																		console.log($scope.TableExistAttrs);
		  
																			if($scope.TableExistAttrs.count[0].number==0){
																					
																					var optionsAttr = {url: AllRedsAttrs,
																											method: 'GET', 
																											params: {
																												}
																											};
						  
																					var promise1=$scope.getRedsAttrs(optionsAttr);
																					console.log('promise1');
																					console.log(promise1);
						   
																					promise1.success(function (data) {
																							console.log('success get attrs!');
																							console.log(data);
																							$scope.RedsAttrs=data;
																							$scope.error = '';
																								})
																							.error(function (data, status) {
																								console.log('error get attrs!');
																							if (status === 404) {
																								$scope.error = 'REST server is offline!';
																							} else {
																								$scope.error = 'Error: ' + status;
																								}
																							}).then(function(){
																									console.log('attributes recieved');
																									console.log($scope.RedsAttrs);
																									var redAttrs=new HashMap();
																									console.log($scope.RedsAttrs);
																									console.log('Q');
																									console.log(Q);
						
																										var promise3 = Q.all( [
																												loadToStructAttrsE(redAttrs,$scope) //mozda ne treba
																													])
						
																										Q.allSettled(promise3).then(function(results){
																												results.forEach(function(result){
						
																												if (result.state === "fulfilled") {
																														var redAttrs = result.value;
																														console.log('result Attr');
																														console.log(result.value);
																					
																				/*	var res = createAttrGraph($scope,result.value); //change the code here!
																					
																					console.log('res[0]');
																					console.log(res[0]);
																					console.log(res[0].success);
																					var gcpromise = res[0];*/
																					
																						//var redAttrs = result.value;
								
																							var graphAttr= new HashMap();
																									console.log("then part!");
																									console.log(redAttrs);
																									console.log(redAttrs.count());

																										var i=0;
																										var j=i+1;
																								var numReds = redAttrs.count();
																								
																						var myVar=setInterval(function() {

																							var perc= (i/numReds)*100;
										
																								document.getElementById("graphProg").innerHTML = "Graph computation: "+perc.toFixed(2)+"%";
								
																							var set1 = redAttrs.get(i);
								
																						for(j=i+1;j<numReds;j++){
																								var set2 = redAttrs.get(j);
								
																								var intersection=0;
																								var set1val = set1.values();
								
																							for(var z=0;z<set1val.length;z++)
																									if(set2.contains(set1val[z]))
																											intersection=intersection+1;
										
																										var edge = intersection/(set1.size()+set2.size()-intersection);
								
																									if(!graphAttr.has(i)){
																											var t=new Array(numReds);
																											t[i]=1.0;
																											graphAttr.set(i,t);
																										}
									
																									if(!graphAttr.has(j)){
																											var t=new Array(numReds);
																												t[j]=1.0;
																												graphAttr.set(j,t);
																											}
								
																									var t=graphAttr.get(i);
																										t[j]=edge;
																										graphAttr.set(i,t);
								
																										t=graphAttr.get(j);
																										t[i]=edge;
																										graphAttr.set(j,t);
																									}
								
			
																			if(i==(numReds-1) && j==(numReds)){
																					clearInterval(myVar);
																					document.getElementById("graphProg").innerHTML = "Graph computation: "+"100%";
																					console.log(graphAttr);
										
																					var totalNumberP = parseInt(graphAttr.count())*parseInt(graphAttr.count());
																					var numRedsinBucketP = Math.floor(2571800/parseInt(graphAttr.count()));//2571800
																					var numItersP = Math.ceil(totalNumberP/(numRedsinBucketP*parseInt(graphAttr.count())));
																					console.log('Num iters: '+numItersP);
																				
																					var promisesP=new Array();
																					var retDataAll=new Array(graphAttr.count());
																					for(var parts=0;parts<numItersP;parts++){
																						var startIndex = parts*numRedsinBucketP;
																						var endIndex = startIndex + numRedsinBucketP;
																						var size = numRedsinBucketP;
									
																						if(endIndex>=graphAttr.count()){
																							var diff = endIndex - graphAttr.count();
																							size = size-diff;
																						}
																						
																						console.log(endIndex);
																						console.log(size);
																						
																						var retData=new Array(size/*graphAttr.count()*/);
																						
																						var dat;
										
																							for(var z=startIndex;z<startIndex+size/*numRedsinBucketP*//*graphAttr.count()*/;z++)//2000
																								retData[z-startIndex]=graphAttr.get(z);
																								retDataAll[z]=graphAttr.get(z);;
																								console.log("retData");
																									console.log(retData);
																								
																								options = {url: saveGraphAttrG,
																									method: 'POST', 
																									params: {
																										},
																									data: { graphAttr:  JSON.stringify(retData), start: startIndex		
																								}
																									};

																									
																									
																							promisesP.push($scope.setGraphData(options));
																						}
																						
											var gcpromise = Q.all(promisesP).then(function(){
											
																								retData = retDataAll;
																								var inputForAlgoAttrs={};
														
																								for(var i=0;i<retData.length;i++){
																										var eds1={};
																										for(var j=0;j<retData[i].length;j++){
																											if(i==j)
																												continue;
																											if(typeof retData[i][j] == 'undefined')
																												continue;//retData[i][j]=0.0;//continue;
																	
																											eds1[j]=1.0-retData[i][j];
																										}
																									inputForAlgoAttrs[i]=eds1;
																									}
											
																											$scope.checkedOrderSOM.cos=[];
																											$scope.graphInputAttrs = inputForAlgoAttrs;
																											
																											//use graphInput and graphInputAttrs
																											filteringE(pload,$scope,elOv,atOv);
																											$scope.$apply();
																											});
																									}
																									
																									i=i+1;
																								  },5)
																								}
																							})
																					})
																				})																					
																			}
																			else{
																				
																					var optionsNR = {url: numredsLink,
																										method: 'GET',
																										params: {}
																									};
								 
																					var promiseNR = $scope.generalGETRequest(optionsNR);
				
				
																						promiseNR.success(function (data) {
																										$scope.numReds = data;
																										$scope.error = '';
																							})
																									.error(function (data, status) {
																									if (status === 404) {
																											$scope.error = 'REST server is offline!';
																									} else {
																										$scope.error = 'Error: ' + status;
																										}
																									}).then(function(){
											
																										console.log('num reds:');
																										console.log($scope.numReds); 
																										console.log($scope.numReds.numReds[0].numReds);
											
																										var numReds = $scope.numReds.numReds[0].numReds;																				
																					
																										//var promiseGR=getAttrGraph($scope);

																														var totalNumber = numReds*numReds;
																														var numRedsinBucket = Math.floor(2571800/numReds);
																														console.log('numRedsInBucket: '+numRedsinBucket);
																														var numIters = Math.ceil(totalNumber/(numRedsinBucket*parseInt(numReds)));
																														console.log('numIters: '+numIters);

																														var promises=new Array();
									
																															for(var parts=0;parts<numIters;parts++){
																																	var startIndex = parts*numRedsinBucket;
																																	var endIndex = (parts+1)*numRedsinBucket;
																																		if(endIndex>numReds)
																																				endIndex=numReds;
																																				promises.push(getInPartsAttr(startIndex,endIndex,numReds,$scope));
																																			}
									
																															var joinedPromise = Q.all(promises);
																										
																										joinedPromise.then(function(values){
									
																													console.log('All data received!');
																													console.log('values');
																													console.log(values);
									
																													var inputAttrs = [];
									
																													console.log('computing input: ');
																													console.log('values length: '+values.length);
																													console.log('graph length: '+values[0].data.GraphDataAttr.length);
									
																														for(var iv=0;iv<values.length;iv++){
																																		for(var iv1=0;iv1<values[iv].data.GraphDataAttr.length;iv1++)
																																				inputAttrs.push(values[iv].data.GraphDataAttr[iv1]);
																																						console.log(inputAttrs.length);
																														}
									
																															console.log('joined input: ');
																															console.log(inputAttrs);
										
																															values=[];
	
																															console.log("Create parameters and define scope variable here");//put watch on it in the scope.
														
																															var inputForAlgoAttrs={};
														
																																for(var i=0;i<inputAttrs.length;i++){
																																				var eds1={};
																																		for(var j=0;j<inputAttrs[i].length;j++){
																																				if(i==j)
																																					continue;
																																				if(typeof inputAttrs[i][j] == 'undefined')
																																					continue;//retData[i][j]=0.0;//continue;
																	
																																				eds1[j]=1.0-inputAttrs[i][j];
																																				}
																																			inputForAlgoAttrs[i]=eds1;
																																			}

																																			$scope.checkedOrderSOM.cos=[];
																																			$scope.graphInputAttrs = inputForAlgoAttrs;
																																			filteringE(pload,$scope,elOv,atOv);
																																			$scope.$apply();
																																		//add three cases for attributes
																																		//use GraphInput and GraphInputAttrs
																																});
																														});
																								}
																							})
																					}
															else{
															filteringE(pload,$scope,elOv,atOv);
															$scope.$apply();
																//use graphInput and graphInputAttrs
															}
			}
					/*}
					else{
					filterReds();
					}*/
			//})
		} 
	
  function filterReds(){
  
  //$("#bar").show();
 /* var pbar=document.getElementById("barContainer");
  pbar.style.visibility="visible";
  var bar=document.getElementById("bar");
  //bar.style.width="45%";
  bar.style.visibility="visible";
  var barT=document.getElementById("barText");
  barT.style.visibility="visible";
  */
  var pload=document.getElementById("loader");
  pload.style.visibility="visible";
  var appElement = document.querySelector('[ng-app=redApp]');
   var $scope = angular.element(appElement).scope();
   
    //var $http = angular.element(appElement).http();
	//console.log(angular.element(appElement));
  /* var batchLength=200;
   var n=Math.floor($scope.RedsContainingAttrs.redescriptions.length/batchLength);
  
	if($scope.RedsContainingAttrs.redescriptions.length<batchLength)
		n=$scope.RedsContainingAttrs.redescriptions.length;
	else if($scope.RedsContainingAttrs.redescriptions.length%batchLength!=0)
		n=n+1;
	
	console.log("n: "+n);
	console.log("redset size: "+$scope.RedsContainingAttrs.redescriptions.length);
	*/
	 var groupMaps= new HashMap();
	 
	 
	 var elOv=$("#eoverIn").val(); var atOv=$("#atoverIn").val();
	 
	 //console.log("obtained values!");
	 //console.log(elOv+" "+atOv);
	// console.log("Initial set size: "+$scope.RedsContainingAttrs.redescriptions.length);
	
  /* for(var i=0;i<n;i++)	{
   var s=[];
	for(var j=0;j<batchLength;j++){
	//console.log("i: "+i); console.log("j: "+j);
			if((i*batchLength+j)<$scope.RedsContainingAttrs.redescriptions.length){
			//console.log($scope.RedsContainingAttrs.redescriptions[i*200+j].id);
					s.push($scope.RedsContainingAttrs.redescriptions[i*batchLength+j].id);
					//console.log(s);
					}
	}
	groupMaps.set(i,s);
	//console.log(s);
  }*/
  
  
 // console.log($scope.RedsContainingAttrs.redescriptions);
 // console.log(groupMaps);
       console.log($scope);
 // var str=JSON.stringify(obj); console.log(str);
  var redescriptionElements=new HashMap();
  var redescriptionAttributes = new HashMap();
    var redescriptionElements1=new HashMap();
  var redescriptionAttributes1 = new HashMap(); //console.log(Q);
  //for(i=0;i<1;i++){
  var obj= 1;//$scope.riscG.RedsInSOMClust.redescriptions.map(function(c){return{'value': c.id}});  //groupMaps.get(i).map(function(c){return {'value': c}});
	   //console.log(obj);
  var options = {url: databaseConfig,
               method: 'GET', 
               params: {
               ids: JSON.stringify(obj)
                        }
                          };
						 // console.log(Q);
						  var promise=$scope.getRedundancyAll(options);//$scope.getRedundancyInfo(options);
						  promise.success(function (data) {
			  // console.log('function gRI called');
			   //console.log(data);
                //$scope.RedundancyInfo = data;
				$scope.RedundancyAll=data;
                $scope.error = '';
           })
          .error(function (data, status) {
              if (status === 404) {
                $scope.error = 'REST server is offline!';
              } else {
                $scope.error = 'Error: ' + status;
              }
          }).then(function(){
		  
						//console.log("resolved!"); console.log($scope);// console.log($scope.RedundancyInfo); console.log($scope.RedundancyInfo.redElems); 
						
							
	for(k=0;k<$scope.RedundancyAll.redElems.length;k++){
			if(!redescriptionElements.has($scope.RedundancyAll.redElems[k].id)){
					var stmp=new HashSet();
					stmp.add($scope.RedundancyAll.redElems[k].elementID);
					redescriptionElements.set($scope.RedundancyAll.redElems[k].id,stmp);
			}
			else{
			var stmp=redescriptionElements.get($scope.RedundancyAll.redElems[k].id);
			stmp.add($scope.RedundancyAll.redElems[k].elementID);
			redescriptionElements.set($scope.RedundancyAll.redElems[k].id,stmp);
			}
						
	}
		
	for(k=0;k<$scope.RedundancyAll.redAttr.length;k++){
			if(!redescriptionAttributes.has($scope.RedundancyAll.redAttr[k].id)){
					var stmp=new HashSet();
					stmp.add($scope.RedundancyAll.redAttr[k].attributeID);
					redescriptionAttributes.set($scope.RedundancyAll.redAttr[k].id,stmp);
			}
			else{
				var stmp=redescriptionAttributes.get($scope.RedundancyAll.redAttr[k].id);
				stmp.add($scope.RedundancyAll.redAttr[k].attributeID);
				redescriptionAttributes.set($scope.RedundancyAll.redAttr[k].id,stmp);
			}		
	}
	
	//console.log("loaded all data...");
	//console.log(redescriptionElements); console.log(redescriptionAttributes);
	/*if($scope.riscG.RedsInSOMClust.redescriptions[1].id==81){
						$scope.riscG.RedsInSOMClust.redescriptions.splice(0,1);
					}*/
					
					var toDelete = new HashSet();
					
					$scope.riscG.RedsInSOMClust.redescriptions.sort(function(a, b){
					
					if(a.col3==b.col3){
						
						if(a.col5==b.col5){
							
							if(a.col4==b.col4){
									
									if(a.col5==b.col5){
										return a.col6-b.col6;
									}
									else{
										return a.col5-b.col5;
									}
									
							}
							else{
								return b.col4-a.col4;
							}
						
						}
						else{
							return a.col5-b.col5;
						}
						
					}
					else{
						return b.col3-a.col3;
					}
					
					});
					
					for(i=0;i<$scope.riscG.RedsInSOMClust.redescriptions.length-1;i++)
							for(j=i+1;j<$scope.riscG.RedsInSOMClust.redescriptions.length;j++){
								
								if(toDelete.contains($scope.riscG.RedsInSOMClust.redescriptions[j].id))
											continue;
								
								var perc=(i*$scope.riscG.RedsInSOMClust.redescriptions.length+j)/($scope.riscG.RedsInSOMClust.redescriptions.length*$scope.riscG.RedsInSOMClust.redescriptions.length)*100;
							//console.log(perc);
								//if(Math.round(perc)%2==0){
									//console.log("in the function");
								//	console.log(Math.round(perc));
								//		bar.style.width= (Math.round(perc))+"%";
									//	barT.innerHTML = Math.round(perc)+"% complete...";
										//console.log(barT);
										
								//}
								
								/*if((j+1)==$scope.riscG.RedsInSOMClust.redescriptions.length)
										console.log(i);*/
								
							
								var s1Vals= redescriptionElements.get($scope.riscG.RedsInSOMClust.redescriptions[i].id).values();
											var sref=redescriptionElements.get($scope.riscG.RedsInSOMClust.redescriptions[j].id);
											var intersection=0; var union=0;
											//var s2Vals = redescriptionElements.get($scope.riscG.RedsInSOMClust[j].id).values;
											
											for(z=0;z<s1Vals.length;z++){
													if(sref.contains(s1Vals[z])){
														intersection=intersection+1;
														}
											}
											
											//console.log("set size: "+s1Vals.length);
											//console.log("intersection: "+intersection);
											union=s1Vals.length+sref.size()-intersection;
											if(union==0)
												console.log("union: "+union);
												
												var jsEl= intersection/union;
												//console.log("jsEl: "+jsEl);
												if(jsEl*100>=elOv){
												if($scope.riscG.RedsInSOMClust.redescriptions[i].data[2]>$scope.riscG.RedsInSOMClust.redescriptions[j].data[2]){
													toDelete.add($scope.riscG.RedsInSOMClust.redescriptions[j].id);
													     }
												else
													toDelete.add($scope.riscG.RedsInSOMClust.redescriptions[i].id);
													//break;
													}	

									var s1Vals= redescriptionAttributes.get($scope.riscG.RedsInSOMClust.redescriptions[i].id).values();
											var sref=redescriptionAttributes.get($scope.riscG.RedsInSOMClust.redescriptions[j].id);
											var intersection=0; var union=0;
											//var s2Vals = redescriptionElements.get($scope.riscG.RedsInSOMClust[j].id).values;
											
											for(z=0;z<s1Vals.length;z++){
													if(sref.contains(s1Vals[z])){
														intersection=intersection+1;
														}
											}
											
											union=s1Vals.length+sref.size()-intersection;
												
												var jsAt= intersection/union;
												//console.log("jsAt: "+jsAt);
												if(jsAt*100>=atOv){
												if($scope.riscG.RedsInSOMClust.redescriptions[i].data[2]>$scope.riscG.RedsInSOMClust.redescriptions[j].data[2]){
													toDelete.add($scope.riscG.RedsInSOMClust.redescriptions[j].id);
													     }
												else
													toDelete.add($scope.riscG.RedsInSOMClust.redescriptions[i].id);
													//break;
													}
													
							}
							
						//while(toDelete.size()>0){
							for(i=0;i<$scope.riscG.RedsInSOMClust.redescriptions.length;i++){
								if(toDelete.contains($scope.riscG.RedsInSOMClust.redescriptions[i].id)){
									toDelete.remove($scope.riscG.RedsInSOMClust.redescriptions[i].id);
									$scope.riscG.RedsInSOMClust.redescriptions.splice(i,1);
									i--;
								}
									
						//	}		
						}
						
						//console.log("size after: "+$scope.riscG.RedsInSOMClust.redescriptions.length);
						pload.style.visibility="hidden";
					/* pbar.style.visibility="hidden";
					 bar.style.visibility="hidden";
					 barT.style.visibility="hidden";*/
					//console.log("Number of remaining redescriptions: ");
					//console.log($scope.riscG.RedsInSOMClust.redescriptions.length);
					
						//console.log(redescriptionAttributes); console.log(redescriptionElements);
						//console.log("counter: "+i);
						
						//console.log("call 2 started!");
						
			//for(j=i+1;j<2;j++){
					/*var obj1=groupMaps.get(j).map(function(c){return {'value': c}});
						console.log(obj1);
						options = {url: databaseConfig1,
               method: 'GET', 
               params: {
               ids: JSON.stringify(obj1)
                        }
                          };
						  
						  var promise1=$scope.getRedundancyAll1(options);
						  promise.success(function (data) {
			  // console.log('function gRI called');
			   //console.log(data);
                $scope.RedundancyInfo = data;
                $scope.error = '';
           })
          .error(function (data, status) {
              if (status === 404) {
                $scope.error = 'REST server is offline!';
              } else {
                $scope.error = 'Error: ' + status;
              }
          }).then(function(){
		
			console.log("resolved!"); console.log($scope); console.log($scope.RedundancyInfo1); console.log($scope.RedundancyInfo1.redElems); 
						
							
	for(k=0;k<$scope.RedundancyInfo1.redElems.length;k++){
			if(!redescriptionElements1.has($scope.RedundancyInfo1.redElems[k].id)){
					var stmp=new HashSet();
					stmp.add($scope.RedundancyInfo1.redElems[k].elementID);
					redescriptionElements1.set($scope.RedundancyInfo1.redElems[k].id,stmp);
			}
			else{
			var stmp=redescriptionElements1.get($scope.RedundancyInfo1.redElems[k].id);
			stmp.add($scope.RedundancyInfo1.redElems[k].elementID);
			redescriptionElements1.set($scope.RedundancyInfo1.redElems[k].id,stmp);
			}
						
	}
	
		
	for(k=0;k<$scope.RedundancyInfo1.redAttr.length;k++){
			if(!redescriptionAttributes1.has($scope.RedundancyInfo1.redAttr[k].id)){
					var stmp=new HashSet();
					stmp.add($scope.RedundancyInfo1.redAttr[k].attributeID);
					redescriptionAttributes1.set($scope.RedundancyInfo1.redAttr[k].id,stmp);
			}
			else{
				var stmp=redescriptionAttributes1.get($scope.RedundancyInfo1.redAttr[k].id);
				stmp.add($scope.RedundancyInfo1.redAttr[k].attributeID);
				redescriptionAttributes1.set($scope.RedundancyInfo1.redAttr[k].id,stmp);
			}
						
	}
						console.log(redescriptionAttributes1); console.log(redescriptionElements1);
						console.log("counter1: "+j);
						
					})	
						//}*/						
						});
		//Q.all().then(function(result){console.log("Resolved inside javascript!")});
		//$scope.getRedundancyInfo(options);
		//then(function(result){console.log("promise resolved!")});
		//console.log("Counter outside: "+i)
//}
		/*var tmp=new HashSet();
		tmp.add(1); tmp.add(2); tmp.add(3);
		console.log(tmp);
		console.log(tmp.size());*/
		 // }
		//}
   
   
					/*$scope.$apply(function(){
						console.log("Scope"); console.log($scope);
						console.log("Function filter redescriptions called!");
					if($scope.riscG.RedsInSOMClust.redescriptions[1].id==81){
						$scope.riscG.RedsInSOMClust.redescriptions.splice(0,1);
					}
				});
					console.log($scope.$apply)*/
   
  //var scope = angular.element($("#outer")).scope();
		}  

function choosePlotTypeEl(myRadio) {
	var appElement = document.querySelector('[ng-app=redApp]');
   var $scope = angular.element(appElement).scope();
   console.log($scope);
   console.log("value of radio button");
   console.log(myRadio.value);
   
   if(myRadio.value === 'nbox'){
		if($scope.plotType==1){
			$scope.plotType=2;
		}
		else if($scope.plotType==2)
			$scope.plotType=1;
		else
			$scope.plotType = 1;
		}
   if(myRadio.value === 'viol')
		$scope.plotType = 0;
		
		$scope.$apply();
		
}

function addTrandLinesEl(myCheck) {
	var appElement = document.querySelector('[ng-app=redApp]');
   var $scope = angular.element(appElement).scope();
   console.log($scope.Trends);
   console.log($scope);
   console.log(myCheck.checked);
   
   if(myCheck.checked == true)
		$scope.Trends = 1;
   if(myCheck.checked == false)
		$scope.Trends = 0;
		
		console.log($scope.Trends);
		$scope.$apply();
}
		
   </script>

<div class="container">

<div class="header">
<h1 class="header-title">Element based redescription set exploration</h1>
</div>

<div id="indtroduction" style="margin-top:10px;margin-bottom:10px">
<p>This is the first functionality of the <b> INTERSET tool that </b> allows <b> iterative exploration of redescription sets </b> based on elements described in different redescriptions. </p>
<div id="functionality" style="margin-bottom:20px">
<h3> Functionality</h3>
<p> The element based exploration uses the <b> Self Organising map </b> to order elements into different clusters based on element occurence in redescription support sets. The exploration process can be done in several steps: </p>
<ol>
  <li> <b> Click </b> on any SOM cluster to examine redescriptions describing at least one element from the cluster</li>
  <li> <b> Scroll </b> through redescription table and <b> select </b> some interesting redescription</li>
  <li> <b> Examine </b> additional information about the selected redescription</li>
</ol>
<p> Clicking on some of the components displays new elements on the page. The elements are placed <b> below currently displayed components</b>, so depending on the screen size, you might need to scroll to use them. </p>
</div>

</div>


    <div id="Elapp" ng-app="redApp" ng-controller="redCtrl">
       <!-- <som-map clusterinfo-url="http://localhost:8081/clusterinfo", url="http://localhost:8081/redescriptions"></som-map> -->
	   	   
	   <div id="inputControls" style="height:120px; width: 1000px">
	    <label>Number of rows: <input type="text" ng-model="params.nRows" ng-init = "params.nRows=4" style="width:50px" /></label>
        <label>Number of columns: <input type="text" ng-model="params.nCols" ng-init = "params.nCols=4" style="width:50px" /></label>
	    <label> Learning rate:  <input type="text" ng-model="params.lRate" ng-init = "params.lRate=0.1" style="width:50px" /></label>
        <label>Number of iterations: <input type="text" ng-model="params.nIter" ng-init = "params.nIter=100" style="width:50px" /></label>
		<label>Progress: <input type="text" ng-model="progress" readonly="readonly" style="width:200px" /></label></br>
			<button ng-model="button" ng-disabled="checked" ng-click="trainSom(params)">Train SOM on all data</button>
			<button ng-model="button" ng-disabled="checked" ng-click="trainOnSelection(params)">Train SOM on selection</button>
			 <span id="butonWithRadio" style="margin-left:20px, width: 700px">
			 <label>
					<input type="radio" ng-model="action.type" value="save" style="margin-left: 40px">
						Save selection
					</label>
			<label>
					<input type="radio" ng-model="action.type" value="load">
						Load and create SOM
			</label>
			 <label>
					<input type="radio" ng-model="action.type" value="saveLayout">
						Save SOM layout
					</label>
			<label>
					<input type="radio" ng-model="action.type" value="loadLayout">
						Load SOM layout
			</label>
			</br> <div id="selectionControls" style="margin-left: 380px;"> <label>minimal Fraction: <input type="text" ng-model="params.minFR" style="width:50px"/></label style="margin-left: 450px;"> 
			<button ng-model="button" ng-disabled="checked" ng-click="trainOnSelectionShared(params)" style="margin-left: 80px;">Perform</button></div>
			</span>
			</div>
	   <load-data redelem-url="http://localhost:8081/redescriptionElement" som-url="http://localhost:8081/somData"  somback-url="http://localhost:8081/somDataBack" clusterinfo-url="http://localhost:8081/clusterinfo" clusterinfosel-url="http://localhost:8081/clusterinfosel" clusterinfoselback-url="http://localhost:8081/clusterinfoBack" redescriptionssel-url="http://localhost:8081/redescriptionsSel" redescriptionsback-url="http://localhost:8081/redescriptionsBack" shared-url="http://localhost:8081/sharedData"></load-data>
	   <som-map clusterinfo-url="http://localhost:8081/clusterinfo", url="http://localhost:8081/redescriptions"></som-map>
		<som-elements style="max-height:200px;overflow-y:scroll;overflow-x: hidden;width:300px;float:right"></som-elements>
		<som-redescriptions style="max-height:260px;width:1000px;float:left" redinfo-url="http://localhost:8081/redescriptionInfo"></som-redescriptions>
		
		<!-- <div class="span12" id="canvas container">
          <canvas id="canvas" class="canvas hide" style="clear:left; margin-top:20px; margin-right:20px; margin-bottom:20px; margin-left:0px; width:500px; height:300px"></canvas>
		  <div id="html-canvas" class="canvas"></div>
		  </div>   -->
		  <word-net  style="float:left; margin-top: 50px"> </word-net>
		  <!--<div id="attrdist"></div>-->
		  <selected-redescription style="float:left; margin-top: 50px"> </selected-redescription>
		  <draw-graphe style="float:left; margin-top: 50px" redinfo-url="http://localhost:8081/redescriptionInfo"> </draw-graphe>
    </div>
</body> 

</html>