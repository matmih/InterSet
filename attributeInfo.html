<html>

<head>


<meta name="viewport" content="width=device-width, initial-scale=1">

<style>

@import url(http://fonts.googleapis.com/css?family=Lato:400:700);
body {
  /*font-family: "Helvetica Neue";*/
  font-family: "Lato";
  margin: 40px auto;
  width: 960px;
  min-height: 2000px;
}
#body {
  position: relative;
}
footer {
  padding: 2em 0 1em 0;
  font-size: 12px;
}
h1 {
  font-size: 30px;
  margin-top: .3em;
  margin-bottom: 0;
}
h1 + h2 {
  margin-top: 0;
}
h2 {
  font-weight: 400;
  font-size: 28px;
}
h1, h2 {
  font-family: "Lato";
  text-rendering: optimizeLegibility;
}
#body > p {
  line-height: 1.5em;
  width: 640px;
  text-rendering: optimizeLegibility;
}
#redCharts {
  padding: 2px 0;
  width: 860px;
}

#totals {
 padding: 2px 0;
}

.red {
	cursor:pointer;
}

div.red:hover {
    background: LightGray;
}

.chart {
  display: inline-block;
  height: 151px;
  margin-bottom: 20px;
}
.reset {
  padding-left: 1em;
  font-size: smaller;
  color: #ccc;
}
.background.bar {
  fill: #ccc;
}
.foreground.bar {
  fill: seagreen;
}
.axis path, .axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}
.axis text {
  font: 10px sans-serif;
}
.brush rect.extent {
  fill: seagreen;
  fill-opacity: .125;
}
.brush .resize path {
  fill: #eee;
  stroke: #666;
}
/*#js-chart {
  width: 600px;
}
#supports-chart {
  width: 600px;
}
#pval-chart {
  width: 600px;
}
#aej-chart {
  width: 600px;
}
#aaj-chart {
  width: 600px;
}
#date-chart {
  width: 920px;
}*/
#git-list {
  max-height:200px;
  overflow-y:scroll;
  overflow-x: hidden;
}
#git-list .date,
#git-list .day {
  
}
#git-list.date .githeader{
width:940px;
}
#git-list .repo {
  line-height: 1.5em;
  /*background: #eee;*/
  /*background: #336666;*/
  width: 940px;
  margin-bottom: 1px;
}
#git-list .repo .leftrule {
 display: inline-block;
  width: 300px;
}
#git-list .repo div {
  display: inline-block;
  width: 100px;
  vertical-align: middle; 
    margin-bottom:10px;
}
#git-list .repo .number{
  display: inline-block;
  width: 50px;
  text-align: center;
}
#git-list .repo .rightrule{
  display: inline-block;
  width: 300px;
  margin-left: 40px;
  text-align: left;
}
#gl{
height: 30px;
font-size: 14px;
/*width: 940px;*/
height: 50px;
display: inline-block;
margin-top : 10px;
margin-bottom: 10px;
padding : 10px;
//overflow-x: scroll;
}
#results > div{
  display: inline-block;
  vertical-align: top;
  margin-top : 10px;
}
#git-list div.distance,
#git-list div.delay {
  width: 160px;
  padding-right: 10px;
  text-align: right;
}
#git-list .early {
  color: green;
}
aside {
  position: absolute;
  left: 600px;
  font-size: smaller;
  width: 300px;
}
.bar {
  fill: seagreen;
}

.title{
	text-align: center;
	font-weight: bold;
}

/*.bar:hover {
  fill: brown;
}*/
.axis {
  font: 10px sans-serif;
}
.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}
.y.axis path {
  display: none;
}
.oneline {
 width: 100px;
 height: 30px;
 display: inline-block;
 text-align: right;
}
.hclr {
 width: 250px;
 height: 40px;
 display: inline-block;
 text-align: center;
  margin-top: 10px;
  margin-bottom: 10px;
}

.hclr p {
font-weight: bold;
}

.hcrr {
 width: 385px;
 height: 40px;
 display: inline-block;
 text-align: center;
  margin-top: 10px;
  margin-bottom: 10px;
}

.hcrr p {
font-weight: bold;
}

.hcjs {
 width: 40px;
 height: 40px;
 display: inline-block;
 text-align: center;
 margin-top: 10px;
  margin-bottom: 10px;
}

.hcjs p {
font-weight: bold;
}

.hcsupp {
 width: 60px;
 height: 40px;
 display: inline-block;
 text-align: center;
  margin-top: 10px;
  margin-bottom: 10px;
}

.hcsupp p {
font-weight: bold;
}

.hcpval {
 width: 45px;
 height: 40px;
 display: inline-block;
 text-align: center;
  margin-top: 10px;
  margin-bottom: 10px;
}

.hcpval p {
font-weight: bold;
}

.hcejs {
 width: 50px;
 height: 40px;
 display: inline-block;
 text-align: center;
  margin-top: 10px;
  margin-bottom: 10px;
}

.hcejs p {
font-weight: bold;
}

.hcajs {
 width: 50px;
 height: 40px;
 display: inline-block;
 text-align: center;
 font: bold;
 margin-bottom : 2px;
  margin-top: 10px;
  margin-bottom: 10px;
}

.hcajs p {
font-weight: bold;
}

.hrn {
 width: 250px;
 height: 30px;
 display: inline-block;
}
.hrn:hover{
color:seagreen;
}
.hdate:hover{
color:seagreen;
}
.hpl:hover{
color:seagreen;
}
.hw:hover{
color:seagreen;
}
.hsize:hover{
color:seagreen;
}
.hiss:hover{
color:seagreen;
}
.oneline:hover{
color:seagreen;
}
a {
  text-decoration: none;
}
a:link {
    color: seagreen;
}
a:visited {
    color: seagreen;
}
a:hover {
    color: seagreen;
}
a:active {
    color: seagreen;
}
a.listLink {
  color: seagreen;
}
a.listLink:hover {
  color: seagreen;
}
.searchResultDiv {
  height: 24px;
}

.background {
  fill: #eee;
}

line {
  stroke: #fff;
}

text.active {
  fill: red;
}


#tooltipA {
        position: absolute;
        width: 200px;
        height: auto;
        padding: 10px;
        background-color: white;
        -webkit-border-radius: 10px;
        -moz-border-radius: 10px;
        border-radius: 10px;
        -webkit-box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
        -moz-box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
        box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
        pointer-events: none;
      }

      #tooltipA.hidden {
        display: none;
      }

      #tooltipA p {
        margin: 0;
        font-family: sans-serif;
        font-size: 12px;
        line-height: 20px;
      }
	  
	  .node {
  stroke: #fff;
  stroke-width: 1.5px;
}

.link {
  stroke: #999;
  stroke-opacity: .6;
  }
  
  .node {
	cursor:pointer;
}

.link {
	cursor:pointer;
}

</style>

<div id="tooltipA" class="hidden">
        <p><span id="value"> </p>
		<br>
		<p><span id="value1"> </p>
</div>

</head>

<body> 

<script> 

 /*var options = {url: databaseConfig,
               method: 'GET', 
               params: {
               ids: JSON.stringify(obj)
                        }
                          };
						  var promise=$scope.getRedundancyAll(options);//$scope.getRedundancyInfo(options);
						  promise.success(function (data) {
				$scope.RedundancyAll=data;
                $scope.error = '';
           })
          .error(function (data, status) {
              if (status === 404) {
                $scope.error = 'REST server is offline!';
              } else {
                $scope.error = 'Error: ' + status;
              }
          }).then(function(){		  
*/

function eventualAdd(a, b) {
    return Q.spread([a, b], function (a, b) {
        return a + b;
    })
}

function loadToStruct(structure, $scope){
return Q.spread([structure,$scope], function(structure,$scope){
	for(var i=0;i<$scope.RedsSupps.redElems.length;i++){
								if(!structure.has($scope.RedsSupps.redElems[i].id)){
									var tSet=new HashSet();
									tSet.add($scope.RedsSupps.redElems[i].elementID);
									structure.set($scope.RedsSupps.redElems[i].id,tSet);
								}
								else{
								var tSet=structure.get($scope.RedsSupps.redElems[i].id);
								tSet.add($scope.RedsSupps.redElems[i].elementID);
								structure.set($scope.RedsSupps.redElems[i].id,tSet);
								}
						}
						
							console.log('Loaded to structure...');
							console.log(structure);
							console.log(structure.count());
							return structure;
							})
}

function relateRedsA(){
console.log("Relation button pressed!");

var selectedReds = new HashSet();
var checkTable="http://localhost:8081/checkTable";
var AllRedsSupps="http://localhost:8081/redundancySupp";
var loadGraph="http://localhost:8081/graphData";
var saveGraph="http://localhost:8081/graphData";
var saveGraphG="http://localhost:8081/graphDataG";
var numredsLink="http://localhost:8081/numReds";

$('#redTableDiv').each(function (i, row) {

        // reference all the stuff you need first
        var $row = $(row),
            $checkedBoxes = $row.find('input:checked');

        $checkedBoxes.each(function (i, checkbox) {
            // assuming you layout the elements this way, 
            // we'll take advantage of .next()
            var $checkbox = $(checkbox);
               console.log('checkbox');
			   console.log($checkbox);
			   console.log($checkbox[0].id);
			   selectedReds.add(parseInt($checkbox[0].id));
        });
    });
	
   var appElement = document.querySelector('[ng-app=redApp]');
   var $scope = angular.element(appElement).scope();
	
	console.log('checkedOrder');
	console.log($scope.checkedOrder.co);
	
	if($scope.checkedOrder.co.length<2){
		$scope.checkedOrder.co.splice(0,$scope.checkedOrder.co.length);
		
		$('#redTableDiv').each(function (i, row) {

        // reference all the stuff you need first
        var $row = $(row),
            $checkedBoxes = $row.find('input:checked');

        $checkedBoxes.each(function (i, checkbox) {
            // assuming you layout the elements this way, 
            // we'll take advantage of .next()
            var $checkbox = $(checkbox);
               $checkbox.attr('checked', false); 
        });
    });
		
		alert('Select at least two redescriptions!');
		return;
		}
		else{
	
		var globalThreshold = $("#jacConst").val();
		var globalNumPaths = $("#nPaths").val();
		
		if(isNaN(globalThreshold) || isNaN(globalNumPaths)){
			alert('Input must be a valid number!');
			return;
		}
		
		globalThreshold = parseFloat(globalThreshold);
		globalNumPaths = parseInt(globalNumPaths);
		console.log('Weight threshold: '+globalThreshold);
		console.log('Num paths: '+globalNumPaths);
		console.log('Checked reds: ');
		console.log($scope.checkedOrder.co);
		
		if(typeof $scope.graphInput=='undefined'){
		
		var options = {url: checkTable,
               method: 'GET', 
               params: {
                        }
                          };
						  
				 var promise=$scope.getCheckTable(options);//$scope.getRedundancyInfo(options);
						  promise.success(function (data) {
				$scope.TableExist=data;
                $scope.error = '';
           })
          .error(function (data, status) {
              if (status === 404) {
                $scope.error = 'REST server is offline!';
              } else {
                $scope.error = 'Error: ' + status;
              }
          }).then(function(){
		  
		  console.log($scope.TableExist);
		  
				if($scope.TableExist.count[0].number==0){
					
					options = {url: AllRedsSupps,
							method: 'GET', 
							params: {
								}
                          };
						  
						   var promise1=$scope.getRedsSupps(options);
						    promise1.success(function (data) {
							$scope.RedsSupps=data;
							$scope.error = '';
						})
							.error(function (data, status) {
							if (status === 404) {
							$scope.error = 'REST server is offline!';
						} else {
								$scope.error = 'Error: ' + status;
							}
							}).then(function(){
							
						
							var redSupps=new HashMap();
							console.log($scope.RedsSupps);
							console.log('Q');
							console.log(Q);
						
						/*var promise4=Q.all([
							eventualAdd(2, 2),
							eventualAdd(10, 20)
						]);
						
						
						Q.allSettled(promise4)
							.then(function (results) {
							results.forEach(function (result) {
							if (result.state === "fulfilled") {
								var value = result.value;
								console.log("q value: "+value);
						} else {
							var reason = result.reason;
						}
						});
					});*/
						
						var promise3 = Q.all( [
						loadToStruct(redSupps,$scope)
							])
						
						Q.allSettled(promise3).then(function(results){
						results.forEach(function(result){
						
						if (result.state === "fulfilled") {
								var redSupps = result.value;
								
							var graph= new HashMap();
							console.log("then part!");
							console.log(redSupps);
							console.log(redSupps.count());

							var i=0;
							var j=i+1;
							var numReds = redSupps.count();
							var myVar=setInterval(function() {
									/*console.log("myVar function")
									console.log(i);
									console.log(j);*/
									var perc= (i/numReds)*100;
									
							document.getElementById("graphProg").innerHTML = "Graph computation: "+perc.toFixed(2)+"%";
								
								var set1 = redSupps.get(i);
								
								for(j=i+1;j<numReds;j++){
								var set2 = redSupps.get(j);
								
								var intersection=0;
								var set1val = set1.values();
								
								for(var z=0;z<set1val.length;z++)
									if(set2.contains(set1val[z]))
										intersection=intersection+1;
										
								var edge = intersection/(set1.size()+set2.size()-intersection);
								
								if(!graph.has(i)){
									var t=new Array(numReds);
									t[i]=1.0;
									graph.set(i,t);
								}
								
								if(!graph.has(j)){
									var t=new Array(numReds);
									t[j]=1.0;
									graph.set(j,t);
								}
								
								var t=graph.get(i);
								t[j]=edge;
								graph.set(i,t);
								
								t=graph.get(j);
								t[i]=edge;
								graph.set(j,t);
								}
								
			
								if(i==(numReds-1) && j==(numReds)){
										clearInterval(myVar);
										document.getElementById("graphProg").innerHTML = "Graph computation: "+"100%";
										console.log(graph);
										
										var totalNumberP = parseInt(graph.count())*parseInt(graph.count());
										var numRedsinBucketP = Math.floor(2571800/parseInt(graph.count()));//2571800
										var numItersP = Math.ceil(totalNumberP/(numRedsinBucketP*parseInt(graph.count())));
										console.log('Num iters: '+numItersP);
								var promisesP=new Array();
								var retDataAll=new Array(graph.count());
								for(var parts=0;parts<numItersP;parts++){
									var startIndex = parts*numRedsinBucketP;
									var endIndex = startIndex + numRedsinBucketP;
									var size = numRedsinBucketP;
									
									if(endIndex>=graph.count()){
										var diff = endIndex - graph.count();
										size = size-diff;
									}
									
									console.log(endIndex);
									console.log(size);
									
									var retData=new Array(size/*graph.count()*/);
									
									var dat;
										
										for(var z=startIndex;z<startIndex+size/*numRedsinBucketP*//*graph.count()*/;z++)//2000
											retData[z-startIndex]=graph.get(z);
											retDataAll[z]=graph.get(z);;
											console.log("retData");
												console.log(retData);
											
											options = {url: saveGraphG,
												method: 'POST', 
												params: {
													},
											    data: { graph:  JSON.stringify(retData), start: startIndex		
											}
												};

												
												
										promisesP.push($scope.setGraphData(options));
									}
									
											
										
										
												
										//var promise5=$scope.setGraphData(options);
										
										
										/*promise5.success(function (data) {
											console.log('Data stored succesfully!');
												$scope.error = '';
										})
										.error(function (data, status) {
										if (status === 404) {
											$scope.error = 'REST server is offline!';
										} else {
												$scope.error = 'Error: ' + status;
											}
											})*/
											var promise5 = Q.all(promisesP).then(function(){
														console.log("Create parameters and define scope variable here");//put watch on it in the scope.
														retData=retDataAll;
														var inputForAlgo={};
														
														for(var i=0;i<retData.length;i++){
																var eds1={};
															for(var j=0;j<retData[i].length;j++){
																if(i==j)
																	continue;
																if(typeof retData[i][j] == 'undefined')
																	 continue;//retData[i][j]=0.0;//continue;
																	
																	eds1[j]=1.0-retData[i][j];
															}
																inputForAlgo[i]=eds1;
														}
														
														console.log("Algorithm input: ");
														console.log(inputForAlgo);
														
														var threshold1=1-globalThreshold;//1-0.2;
														var forbiden1 = new HashSet();
														
														var present = new HashSet();
														
														for(var pr=0;pr<$scope.ricaG.RedsContainingAttrs.redescriptions.length;pr++)
																present.add($scope.ricaG.RedsContainingAttrs.redescriptions[pr].id);
																
														for(var pr=0;pr<retData.length;pr++)
																if(!present.contains(pr))
																	forbiden1.add(pr+"");
														
														var pathsFinal = new PriorityQueue();
														var pathsCandidates = new PriorityQueue();
 														 var graph = new Graph(inputForAlgo,threshold1,forbiden1);
														 var inputArr = new Array();
														 
														 for(var t=0;t<$scope.checkedOrder.co.length;t++)
																inputArr[t]=$scope.checkedOrder.co[t]+"";
														 
														 var sp=graph.findShortestPath(inputArr);
														console.log('SP: ');
														console.log(sp);
														console.log('checked order: ');
														console.log($scope.checkedOrder.co);
														console.log('Forbiden nodes.');
														console.log(forbiden1.values());
														
														 /*var forbiden1=new HashSet();
																var map = {a:{b:3,c:1,d:1},b:{a:2,c:1},c:{a:4,b:1}, d:{b:3,c:1}}, threshold1=50;
																var graph = new Graph(map,threshold1,forbiden1);
																var sp=graph.findShortestPath('a','b','c');*/
													
													if(sp!=null){			
																var cost=0;
														for(var i=0;i<sp.length-1;i++){
																	cost = cost + graph.findEdge(sp[i],sp[i+1]);
															}
														
														sp.forbidenEdges=new Array();														
												
														sp.cost=cost;
														pathsFinal.push(cost,sp);
														pathsCandidates.push(cost,sp);
													}
														
														while(pathsFinal.length()<globalNumPaths){//10
																if(pathsCandidates.length()==0)
																		break;
															var tmpPath = pathsCandidates.pop();
															var startNodes = new Array();
															var endNodes = new Array();
															
															for(var i=0;i<tmpPath.forbidenEdges.length;i++){
																startNodes.push(tmpPath.forbidenEdges[i].s);
																endNodes.push(tmpPath.forbidenEdges[i].e);
															}
															
															for(var i=0;i<tmpPath.length-1;i++){
																	startNodes.push(tmpPath[i]);
																	endNodes.push(tmpPath[i+1]);
																	graph.setEdges(startNodes,endNodes);
																	
																	inputArr = new Array();
														 
														 for(var t=0;t<$scope.checkedOrder.co.length;t++)
																inputArr[t]=$scope.checkedOrder.co[t]+"";
																
																	var sp1=graph.findShortestPath(inputArr,forbiden1);
								
																	if(sp1!=null){
																	
																	sp1.forbidenEdges=new Array();
																	for(var j=0;j<startNodes.length;j++){
																		var ed={}; ed.s=startNodes[j]; ed.e=endNodes[j];
																		sp1.forbidenEdges.push(ed);
																	}
																		
																		cost=0;
																		for(var i=0;i<sp1.length-1;i++){
																			cost = cost + graph.findEdge(sp1[i],sp1[i+1]);
																	}
																	
																	sp1.cost=cost;
																	if(!pathsCandidates.contains(sp1))
																		pathsCandidates.push(cost,sp1);
																	}
																	
																	graph.restoreEdges(startNodes,endNodes);
																	startNodes.splice(startNodes.length-1,1);
																	endNodes.splice(endNodes.length-1,1);
															}
															
															if(pathsCandidates.length()==0)
																break;
															
															var spT=pathsCandidates.pop();
															if(!pathsFinal.contains(spT)){
																	pathsFinal.push(spT.cost,spT);//check if this path exists.
																	pathsCandidates.push(spT.cost,spT);
															}
															else{
																	while(pathsFinal.contains(spT)){
																		spT=pathsCandidates.pop();
																	}
																	if(spT!=null){
																	pathsFinal.push(spT.cost,spT);
																	pathsCandidates.push(spT.cost,spT);
																	}
															}
															
															//console.log('tmp path1: ');
															//console.log(spT);
														}
														
														var drawGraph={};
														drawGraph.nodes = new Array();
														drawGraph.links = new Array();
														var usedNodes = new HashSet();
														console.log('Paths: ');
														var rank=1;
														
														drawGraph.startNode = $scope.checkedOrder.co[0]+"";
														usedNodes.add($scope.checkedOrder.co[0]+"");
														drawGraph.endNode = $scope.checkedOrder.co[$scope.checkedOrder.co.length-1]+"";
														usedNodes.add($scope.checkedOrder.co[$scope.checkedOrder.co.length-1]+"");
														drawGraph.intermediary = new HashSet();
														for(var k=1;k<$scope.checkedOrder.co.length-1;k++){
															drawGraph.intermediary.add($scope.checkedOrder.co[k]+"");
															usedNodes.add($scope.checkedOrder.co[k]+"");
															}
														
														while(pathsFinal.length()>0){
															var sp = pathsFinal.pop();
															console.log(rank+'. '+sp);
															console.log(sp);
															console.log(sp.length);
															for(var i=0;i<sp.length-1;i++){
															//if(i==0)
															//drawGraph.startNode=sp[i];
																 var contained=0;
																 usedNodes.add(sp[i]);
																 for(var j=0;j<drawGraph.links.length;j++){
																	if(drawGraph.links[j].source==sp[i] && drawGraph.links[j].target==sp[i+1]){
																		contained=1;
																		break;
																	}
																}
																	
																	if(contained==0){
																		var ed={};
																		ed.source=sp[i]; ed.target=sp[i+1]; ed.group=rank; ed.value=graph.findEdge(sp[i],sp[i+1]);
																		drawGraph.nGr=rank;
																		//console.log('ed');
																		//console.log(ed);
																		drawGraph.links.push(ed);
																	}			
															}
															usedNodes.add(sp[sp.length-1]);
															//drawGraph.endNode=sp[sp.length-1];
															rank=rank+1;
														}
														
														//create edges between all present nodes not on a path as default edges, code -1, grey color
														
														var unAr=usedNodes.values();
														
														for(var un1=0;un1<unAr.length-1;un1++){
															for(var un2=un1+1;un2<unAr.length;un2++){
															 var contained=0;
																 for(var j=0;j<drawGraph.links.length;j++){
																	if((drawGraph.links[j].source==unAr[un1] && drawGraph.links[j].target==unAr[un2]) || (drawGraph.links[j].source==unAr[un2] && drawGraph.links[j].target==unAr[un1])){
																		contained=1;
																		break;
																	}
																}
																if(contained==0 && graph.findEdge(unAr[un1],unAr[un2])<=threshold1){
																var ed={};
																		ed.source=unAr[un1]; ed.target=unAr[un2]; ed.group=-1; ed.value=graph.findEdge(unAr[un1],unAr[un2]);
																		drawGraph.links.push(ed);
																}
															}
														}
														
														var selReds=new Array();//redescriptions that need to be displayed
														
														for(var i=0;i<$scope.ricaG.RedsContainingAttrs.redescriptions.length;i++){
																if(usedNodes.contains($scope.ricaG.RedsContainingAttrs.redescriptions[i].id+""))
																		selReds.push($scope.ricaG.RedsContainingAttrs.redescriptions[i]);
														}
														
														var una = usedNodes.values();
														
														var mapping = new HashMap();
														
														var ind=0;
														for(var i=0;i<una.length;i++){
															mapping.set(una[i],ind);
															ind=ind+1;
															}
															
														for(var i=0;i<drawGraph.links.length;i++){
																drawGraph.links[i].source=mapping.get(drawGraph.links[i].source);
																drawGraph.links[i].target=mapping.get(drawGraph.links[i].target);
															}
														
														for(var i=0;i<una.length;i++){
															var n={};
															n.id=una[i];
															
															for(var j=0;j<selReds.length;j++)
																if(selReds[j].id+""==una[i]){
																	n.lq=selReds[j].data[0];
																	n.rq=selReds[j].data[1];
																	n.js=selReds[j].data[2];
																	n.supp=selReds[j].data[3];
																	n.pVal=selReds[j].data[4];
																} //uncomment when dealing with original data

															drawGraph.nodes.push(n);
														}
														
														console.log('scope');
														console.log($scope);
														//redIds.values();
													
														$scope.RedRelationGraphA=drawGraph;	//save graphINput to scope.graphInput variable	
														$scope.checkedOrder.co=[];
														$scope.graphInput = inputForAlgo;
														
														$('#redTableDiv').each(function (i, row) {

															var $row = $(row),
														$checkedBoxes = $row.find('input:checked');

														$checkedBoxes.each(function (i, checkbox) {

														var $checkbox = $(checkbox);
														$checkbox.attr('checked', false); 
														});
													});
	
											})
										
										
										return;
											}
											
											i=i+1;
			
								/*if(j==(numReds-1)){
									i=i+1;
									j=i+1;
										}
			
									j=j+1;*/
							}, 5);	
							}
							})
						})							
									//compute the graph, save the graph and compute the input for the algorithm, run the algorithm and draw the result.
							})
							
							}
				else{
				
				var getInParts = function(startIndex, endIndex, numReds, $scope){
				if(typeof($scope.rawGraph)=='undefined')
						$scope.rawGraph = [];
					return Q.spread([startIndex, endIndex, $scope], function(startIndex, endIndex,$scope){
							var options = {url: saveGraph,
												method: 'GET', 
												params: {
													start: JSON.stringify(startIndex),
													end: JSON.stringify(endIndex),
													nr: JSON.stringify(numReds)
													}
												};
												
									var tmpPromise = $scope.getGraphData(options);	
									
									return tmpPromise;
									
									var tmpRes;
									
									tmpPromise.success(function (data) {
											tmpRes=data;
											console.log('data');
											console.log(tmpRes);
												$scope.error = '';
										})
										.error(function (data, status) {
										if (status === 404) {
											$scope.error = 'REST server is offline!';
										} else {
												$scope.error = 'Error: ' + status;
											}
											}).then(function(){
											
											console.log('got a part of data');
											console.log(tmpRes);
											var tmp=new Array();
											
											
											
											return tmp;
											//convert to HashMap arrayList
											
											});
												
					})
				};
				
				/*var promise3 = Q.all( [
						loadToStruct(redSupps,$scope)
							])
						
						Q.allSettled(promise3).then(function(results){
						results.forEach(function(result){
						
						if (result.state === "fulfilled") {
								var redSupps = result.value;*/

				
				var optionsNR = {url: numredsLink,
								 method: 'GET',
								 params: {}
								 };
								 
				var promiseNR = $scope.generalGETRequest(optionsNR);
				
				
				promiseNR.success(function (data) {
											$scope.numReds = data;
												$scope.error = '';
										})
										.error(function (data, status) {
										if (status === 404) {
											$scope.error = 'REST server is offline!';
										} else {
												$scope.error = 'Error: ' + status;
											}
											}).then(function(){
											
											console.log('num reds:');
											console.log($scope.numReds); 
											console.log($scope.numReds.numReds[0].numReds);
											
											var numReds = $scope.numReds.numReds[0].numReds;
											//convert to HashMap arrayList
											
											var totalNumber = numReds*numReds;
											var numRedsinBucket = Math.floor(2571800/numReds);
											console.log('numRedsInBucket: '+numRedsinBucket);
											var numIters = Math.ceil(totalNumber/(numRedsinBucket*parseInt(numReds)));
											console.log('numIters: '+numIters);

									var promises=new Array();
									
									for(var parts=0;parts<numIters;parts++){
									var startIndex = parts*numRedsinBucket;
									var endIndex = (parts+1)*numRedsinBucket;
									if(endIndex>numReds)
										endIndex=numReds;
										promises.push(getInParts(startIndex,endIndex,numReds,$scope));
									}
									
									var joinedPromise = Q.all(promises).then(function(values){
									
									console.log('All data received!');
									console.log('values');
									console.log(values);
									
									
									var input = [];
									
									console.log('computing input: ');
									console.log('values length: '+values.length);
									console.log('graph length: '+values[0].data.GraphData.length);
									
									for(var iv=0;iv<values.length;iv++){
											for(var iv1=0;iv1<values[iv].data.GraphData.length;iv1++)
												input.push(values[iv].data.GraphData[iv1]);
												console.log(input.length);
									}
									
										console.log('joined input: ');
										console.log(input);
										
										values=[];
	
										console.log("Create parameters and define scope variable here");//put watch on it in the scope.
														
														var inputForAlgo={};
														
														for(var i=0;i<input.length;i++){
																var eds1={};
															for(var j=0;j<input[i].length;j++){
																if(i==j)
																	continue;
																if(typeof input[i][j] == 'undefined')
																	 continue;//retData[i][j]=0.0;//continue;
																	
																	eds1[j]=1.0-input[i][j];
															}
																inputForAlgo[i]=eds1;
														}
														
														console.log("Algorithm input: ");
														console.log(inputForAlgo);
														
														var threshold1=1-globalThreshold;//1-0.2;
														var forbiden1 = new HashSet();
														
														var present = new HashSet();
														
														console.log($scope.ricaG);
														
														for(var pr=0;pr<$scope.ricaG.RedsContainingAttrs.redescriptions.length;pr++)
																present.add($scope.ricaG.RedsContainingAttrs.redescriptions[pr].id);
																
														for(var pr=0;pr<input.length;pr++)
																if(!present.contains(pr))
																	forbiden1.add(pr+"");
														
														var pathsFinal = new PriorityQueue();
														var pathsCandidates = new PriorityQueue();
 														 var graph = new Graph(inputForAlgo,threshold1,forbiden1);
														 var inputArr = new Array();
														 
														 for(var t=0;t<$scope.checkedOrder.co.length;t++)
																inputArr[t]=$scope.checkedOrder.co[t]+"";
														 
														 var sp=graph.findShortestPath(inputArr);
														console.log('SP: ');
														console.log(sp);
														console.log('checked order: ');
														console.log($scope.checkedOrder.co);
														console.log('Forbiden nodes.');
														console.log(forbiden1.values());
														
														 /*var forbiden1=new HashSet();
																var map = {a:{b:3,c:1,d:1},b:{a:2,c:1},c:{a:4,b:1}, d:{b:3,c:1}}, threshold1=50;
																var graph = new Graph(map,threshold1,forbiden1);
																var sp=graph.findShortestPath('a','b','c');*/
													
													if(sp!=null){			
																var cost=0;
														for(var i=0;i<sp.length-1;i++){
																	cost = cost + graph.findEdge(sp[i],sp[i+1]);
															}
														
														sp.forbidenEdges=new Array();														
												
														sp.cost=cost;
														pathsFinal.push(cost,sp);
														pathsCandidates.push(cost,sp);
													}
														
														while(pathsFinal.length()<globalNumPaths){//10
																if(pathsCandidates.length()==0)
																		break;
															var tmpPath = pathsCandidates.pop();
															var startNodes = new Array();
															var endNodes = new Array();
															
															for(var i=0;i<tmpPath.forbidenEdges.length;i++){
																startNodes.push(tmpPath.forbidenEdges[i].s);
																endNodes.push(tmpPath.forbidenEdges[i].e);
															}
															
															for(var i=0;i<tmpPath.length-1;i++){
																	startNodes.push(tmpPath[i]);
																	endNodes.push(tmpPath[i+1]);
																	graph.setEdges(startNodes,endNodes);
																	
																	inputArr = new Array();
														 
														 for(var t=0;t<$scope.checkedOrder.co.length;t++)
																inputArr[t]=$scope.checkedOrder.co[t]+"";
																
																	var sp1=graph.findShortestPath(inputArr,forbiden1);
								
																	if(sp1!=null){
																	
																	sp1.forbidenEdges=new Array();
																	for(var j=0;j<startNodes.length;j++){
																		var ed={}; ed.s=startNodes[j]; ed.e=endNodes[j];
																		sp1.forbidenEdges.push(ed);
																	}
																		
																		cost=0;
																		for(var i=0;i<sp1.length-1;i++){
																			cost = cost + graph.findEdge(sp1[i],sp1[i+1]);
																	}
																	
																	sp1.cost=cost;
																	if(!pathsCandidates.contains(sp1))
																		pathsCandidates.push(cost,sp1);
																	}
																	
																	graph.restoreEdges(startNodes,endNodes);
																	startNodes.splice(startNodes.length-1,1);
																	endNodes.splice(endNodes.length-1,1);
															}
															
															if(pathsCandidates.length()==0)
																break;
															
															var spT=pathsCandidates.pop();
															if(!pathsFinal.contains(spT)){
																	pathsFinal.push(spT.cost,spT);//check if this path exists.
																	pathsCandidates.push(spT.cost,spT);
															}
															else{
																	while(pathsFinal.contains(spT)){
																		spT=pathsCandidates.pop();
																	}
																	if(spT!=null){
																	pathsFinal.push(spT.cost,spT);
																	pathsCandidates.push(spT.cost,spT);
																	}
															}
															
															//console.log('tmp path1: ');
															//console.log(spT);
														}
														
														var drawGraph={};
														drawGraph.nodes = new Array();
														drawGraph.links = new Array();
														var usedNodes = new HashSet();
														console.log('Paths: ');
														var rank=1;
														
														drawGraph.startNode = $scope.checkedOrder.co[0]+"";
														usedNodes.add($scope.checkedOrder.co[0]+"");
														drawGraph.endNode = $scope.checkedOrder.co[$scope.checkedOrder.co.length-1]+"";
														usedNodes.add($scope.checkedOrder.co[$scope.checkedOrder.co.length-1]+"");
														drawGraph.intermediary = new HashSet();
														for(var k=1;k<$scope.checkedOrder.co.length-1;k++){
															drawGraph.intermediary.add($scope.checkedOrder.co[k]+"");
															usedNodes.add($scope.checkedOrder.co[k]+"");
															}
														
														while(pathsFinal.length()>0){
															var sp = pathsFinal.pop();
															console.log(rank+'. '+sp);
															console.log(sp);
															console.log(sp.length);
															for(var i=0;i<sp.length-1;i++){
															//if(i==0)
															//drawGraph.startNode=sp[i];
																 var contained=0;
																 usedNodes.add(sp[i]);
																 for(var j=0;j<drawGraph.links.length;j++){
																	if(drawGraph.links[j].source==sp[i] && drawGraph.links[j].target==sp[i+1]){
																		contained=1;
																		break;
																	}
																}
																	
																	if(contained==0){
																		var ed={};
																		ed.source=sp[i]; ed.target=sp[i+1]; ed.group=rank; ed.value=graph.findEdge(sp[i],sp[i+1]);
																		drawGraph.nGr=rank;
																		//console.log('ed');
																		//console.log(ed);
																		drawGraph.links.push(ed);
																	}			
															}
															usedNodes.add(sp[sp.length-1]);
															//drawGraph.endNode=sp[sp.length-1];
															rank=rank+1;
														}
														
														//create edges between all present nodes not on a path as default edges, code -1, grey color
														
														var unAr=usedNodes.values();
														
														for(var un1=0;un1<unAr.length-1;un1++){
															for(var un2=un1+1;un2<unAr.length;un2++){
															 var contained=0;
																 for(var j=0;j<drawGraph.links.length;j++){
																	if((drawGraph.links[j].source==unAr[un1] && drawGraph.links[j].target==unAr[un2]) || (drawGraph.links[j].source==unAr[un2] && drawGraph.links[j].target==unAr[un1])){
																		contained=1;
																		break;
																	}
																}
																if(contained==0 && graph.findEdge(unAr[un1],unAr[un2])<=threshold1){
																var ed={};
																		ed.source=unAr[un1]; ed.target=unAr[un2]; ed.group=-1; ed.value=graph.findEdge(unAr[un1],unAr[un2]);
																		drawGraph.links.push(ed);
																}
															}
														}
														
														var selReds=new Array();//redescriptions that need to be displayed
														
														for(var i=0;i<$scope.ricaG.RedsContainingAttrs.redescriptions.length;i++){
																if(usedNodes.contains($scope.ricaG.RedsContainingAttrs.redescriptions[i].id+""))
																		selReds.push($scope.ricaG.RedsContainingAttrs.redescriptions[i]);
														}
														
														var una = usedNodes.values();
														
														var mapping = new HashMap();
														
														var ind=0;
														for(var i=0;i<una.length;i++){
															mapping.set(una[i],ind);
															ind=ind+1;
															}
															
														for(var i=0;i<drawGraph.links.length;i++){
																drawGraph.links[i].source=mapping.get(drawGraph.links[i].source);
																drawGraph.links[i].target=mapping.get(drawGraph.links[i].target);
															}
														
														for(var i=0;i<una.length;i++){
															var n={};
															n.id=una[i];
															
															for(var j=0;j<selReds.length;j++)
																if(selReds[j].id+""==una[i]){
																	n.lq=selReds[j].data[0];
																	n.rq=selReds[j].data[1];
																	n.js=selReds[j].data[2];
																	n.supp=selReds[j].data[3];
																	n.pVal=selReds[j].data[4];
																} //uncomment when dealing with original data

															drawGraph.nodes.push(n);
														}
														
														console.log('scope');
														console.log($scope);
														//redIds.values();
													
														$scope.RedRelationGraphA=drawGraph;	//save graphINput to scope.graphInput variable	
														$scope.checkedOrder.co=[];
														$scope.graphInput = inputForAlgo;
														
														$('#redTableDiv').each(function (i, row) {

															var $row = $(row),
														$checkedBoxes = $row.find('input:checked');

														$checkedBoxes.each(function (i, checkbox) {

														var $checkbox = $(checkbox);
														$checkbox.attr('checked', false); 
														});
													});
	
									
									
									});
										
										
									/*Q.allSettled(joinedPromise).then(function(results){
										var globalAr = new Array();
										results.forEach(function(result){
						
											if (result.state === "fulfilled") {
													console.log('part succesfully received!');
													console.log(result);
													console.log(result.value);
													var promise = result.value;
													
													tmpPromise.success(function (data) {
											globalAr=data;
											console.log('data');
											console.log(globalAr);
												$scope.error = '';
										})
										.error(function (data, status) {
										if (status === 404) {
											$scope.error = 'REST server is offline!';
										} else {
												$scope.error = 'Error: ' + status;
											}
											}).then(function(){
											
											console.log('got a part of data');
											var tmp=new Array();
											
											return;
											//convert to HashMap arrayList
											
											});
													
													
													}
												})
												
												console.log('outside results');
												console.log(globalAr);
												
											})/*
							
								
										/*var options = {url: saveGraph,
												method: 'GET', 
												params: {
													}
												};
												
										var promise5=$scope.getGraphData(options);
										
										
										promise5.success(function (data) {
											$scope.rawGraph = data;
												$scope.error = '';
										})
										.error(function (data, status) {
										if (status === 404) {
											$scope.error = 'REST server is offline!';
										} else {
												$scope.error = 'Error: ' + status;
											}
											}).then(function(){
											
											console.log('scope raw graph');
											console.log($scope.rawGraph); 
											//convert to HashMap arrayList
											
											});*/
											
									});
				
						//load the graph and compute the input for the algorithm, run the algorithm and draw the result.
					
				}
		  
				});
			}
			else{
			
													console.log("Algorithm input: ");
														console.log($scope.graphInput);
													 var inputForAlgo = $scope.graphInput;
														
														var threshold1=1-globalThreshold;//1-0.2;
														var forbiden1 = new HashSet();
														
														var present = new HashSet();
														
														for(var pr=0;pr<$scope.ricaG.RedsContainingAttrs.redescriptions.length;pr++)
																present.add($scope.ricaG.RedsContainingAttrs.redescriptions[pr].id);
																
														for(var pr=0;pr<$scope.numReds.numReds[0].numReds;pr++)
																if(!present.contains(pr))
																	forbiden1.add(pr+"");
														
														var pathsFinal = new PriorityQueue();
														var pathsCandidates = new PriorityQueue();
 														 var graph = new Graph(inputForAlgo,threshold1,forbiden1);
														 var inputArr = new Array();
														 
														 for(var t=0;t<$scope.checkedOrder.co.length;t++)
																inputArr[t]=$scope.checkedOrder.co[t]+"";
														 
														 var sp=graph.findShortestPath(inputArr);
														console.log('SP: ');
														console.log(sp);
														console.log('checked order: ');
														console.log($scope.checkedOrder.co);
														console.log('Forbiden nodes.');
														console.log(forbiden1.values());
														
														 /*var forbiden1=new HashSet();
																var map = {a:{b:3,c:1,d:1},b:{a:2,c:1},c:{a:4,b:1}, d:{b:3,c:1}}, threshold1=50;
																var graph = new Graph(map,threshold1,forbiden1);
																var sp=graph.findShortestPath('a','b','c');*/
													
													if(sp!=null){			
																var cost=0;
														for(var i=0;i<sp.length-1;i++){
																	cost = cost + graph.findEdge(sp[i],sp[i+1]);
															}
														
														sp.forbidenEdges=new Array();														
												
														sp.cost=cost;
														pathsFinal.push(cost,sp);
														pathsCandidates.push(cost,sp);
													}
														
														while(pathsFinal.length()<globalNumPaths){//10
																if(pathsCandidates.length()==0)
																		break;
															var tmpPath = pathsCandidates.pop();
															var startNodes = new Array();
															var endNodes = new Array();
															
															for(var i=0;i<tmpPath.forbidenEdges.length;i++){
																startNodes.push(tmpPath.forbidenEdges[i].s);
																endNodes.push(tmpPath.forbidenEdges[i].e);
															}
															
															for(var i=0;i<tmpPath.length-1;i++){
																	startNodes.push(tmpPath[i]);
																	endNodes.push(tmpPath[i+1]);
																	graph.setEdges(startNodes,endNodes);
																	
																	inputArr = new Array();
														 
														 for(var t=0;t<$scope.checkedOrder.co.length;t++)
																inputArr[t]=$scope.checkedOrder.co[t]+"";
																
																	var sp1=graph.findShortestPath(inputArr,forbiden1);
								
																	if(sp1!=null){
																	
																	sp1.forbidenEdges=new Array();
																	for(var j=0;j<startNodes.length;j++){
																		var ed={}; ed.s=startNodes[j]; ed.e=endNodes[j];
																		sp1.forbidenEdges.push(ed);
																	}
																		
																		cost=0;
																		for(var i=0;i<sp1.length-1;i++){
																			cost = cost + graph.findEdge(sp1[i],sp1[i+1]);
																	}
																	
																	sp1.cost=cost;
																	if(!pathsCandidates.contains(sp1))
																		pathsCandidates.push(cost,sp1);
																	}
																	
																	graph.restoreEdges(startNodes,endNodes);
																	startNodes.splice(startNodes.length-1,1);
																	endNodes.splice(endNodes.length-1,1);
															}
															
															if(pathsCandidates.length()==0)
																break;
															
															var spT=pathsCandidates.pop();
															if(!pathsFinal.contains(spT)){
																	pathsFinal.push(spT.cost,spT);//check if this path exists.
																	pathsCandidates.push(spT.cost,spT);
															}
															else{
																	while(pathsFinal.contains(spT)){
																		spT=pathsCandidates.pop();
																	}
																	if(spT!=null){
																	pathsFinal.push(spT.cost,spT);
																	pathsCandidates.push(spT.cost,spT);
																	}
															}
															
															//console.log('tmp path1: ');
															//console.log(spT);
														}
														
														var drawGraph={};
														drawGraph.nodes = new Array();
														drawGraph.links = new Array();
														var usedNodes = new HashSet();
														console.log('Paths: ');
														var rank=1;
														
														drawGraph.startNode = $scope.checkedOrder.co[0]+"";
														usedNodes.add($scope.checkedOrder.co[0]+"");
														drawGraph.endNode = $scope.checkedOrder.co[$scope.checkedOrder.co.length-1]+"";
														usedNodes.add($scope.checkedOrder.co[$scope.checkedOrder.co.length-1]+"");
														drawGraph.intermediary = new HashSet();
														for(var k=1;k<$scope.checkedOrder.co.length-1;k++){
															drawGraph.intermediary.add($scope.checkedOrder.co[k]+"");
															usedNodes.add($scope.checkedOrder.co[k]+"");
															}
														
														while(pathsFinal.length()>0){
															var sp = pathsFinal.pop();
															console.log(rank+'. '+sp);
															console.log(sp);
															console.log(sp.length);
															for(var i=0;i<sp.length-1;i++){
															//if(i==0)
															//drawGraph.startNode=sp[i];
																 var contained=0;
																 usedNodes.add(sp[i]);
																 for(var j=0;j<drawGraph.links.length;j++){
																	if(drawGraph.links[j].source==sp[i] && drawGraph.links[j].target==sp[i+1]){
																		contained=1;
																		break;
																	}
																}
																	
																	if(contained==0){
																		var ed={};
																		ed.source=sp[i]; ed.target=sp[i+1]; ed.group=rank; ed.value=graph.findEdge(sp[i],sp[i+1]);
																		drawGraph.nGr=rank;
																		//console.log('ed');
																		//console.log(ed);
																		drawGraph.links.push(ed);
																	}			
															}
															usedNodes.add(sp[sp.length-1]);
															//drawGraph.endNode=sp[sp.length-1];
															rank=rank+1;
														}
														
														//create edges between all present nodes not on a path as default edges, code -1, grey color
														
														var unAr=usedNodes.values();
														
														for(var un1=0;un1<unAr.length-1;un1++){
															for(var un2=un1+1;un2<unAr.length;un2++){
															 var contained=0;
																 for(var j=0;j<drawGraph.links.length;j++){
																	if((drawGraph.links[j].source==unAr[un1] && drawGraph.links[j].target==unAr[un2]) || (drawGraph.links[j].source==unAr[un2] && drawGraph.links[j].target==unAr[un1])){
																		contained=1;
																		break;
																	}
																}
																if(contained==0 && graph.findEdge(unAr[un1],unAr[un2])<=threshold1){
																var ed={};
																		ed.source=unAr[un1]; ed.target=unAr[un2]; ed.group=-1; ed.value=graph.findEdge(unAr[un1],unAr[un2]);
																		drawGraph.links.push(ed);
																}
															}
														}
														
														var selReds=new Array();//redescriptions that need to be displayed
														
														for(var i=0;i<$scope.ricaG.RedsContainingAttrs.redescriptions.length;i++){
																if(usedNodes.contains($scope.ricaG.RedsContainingAttrs.redescriptions[i].id+""))
																		selReds.push($scope.ricaG.RedsContainingAttrs.redescriptions[i]);
														}
														
														var una = usedNodes.values();
														
														var mapping = new HashMap();
														
														var ind=0;
														for(var i=0;i<una.length;i++){
															mapping.set(una[i],ind);
															ind=ind+1;
															}
															
														for(var i=0;i<drawGraph.links.length;i++){
																drawGraph.links[i].source=mapping.get(drawGraph.links[i].source);
																drawGraph.links[i].target=mapping.get(drawGraph.links[i].target);
															}
														
														for(var i=0;i<una.length;i++){
															var n={};
															n.id=una[i];
															
															for(var j=0;j<selReds.length;j++)
																if(selReds[j].id+""==una[i]){
																	n.lq=selReds[j].data[0];
																	n.rq=selReds[j].data[1];
																	n.js=selReds[j].data[2];
																	n.supp=selReds[j].data[3];
																	n.pVal=selReds[j].data[4];
																} //uncomment when dealing with original data

															drawGraph.nodes.push(n);
														}
														
														console.log('scope');
														console.log($scope);
														//redIds.values();
													
														$scope.RedRelationGraphA=drawGraph;	//save graphINput to scope.graphInput variable	
														$scope.checkedOrder.co=[];
														$scope.graphInput = inputForAlgo;
														
														$('#redTableDiv').each(function (i, row) {

															var $row = $(row),
														$checkedBoxes = $row.find('input:checked');

														$checkedBoxes.each(function (i, checkbox) {

														var $checkbox = $(checkbox);
														$checkbox.attr('checked', false); 
														});
													});
			
			$scope.$apply();
			
				//run the algorithm and draw the result.
			}
		}
	
	/*var numTimes=0;

	var i=0;
	var j=0;
	var myVar=setInterval(function() {
            console.log(i);
			console.log(j);
			
			document.getElementById("demo").innerHTML = "("+i+","+j+")";
			
			
			if(i==3 && j==100){
				clearInterval(myVar);
				document.getElementById("demo").innerHTML = "";
				return;
				}
			
			if(j==100){
				j=0;
				i=i+1;
			}
			
				j=j+1;
        }, 500);*/

}

function JSON2CSV(objArray) {
    var array = typeof objArray != 'object' ? JSON.parse(objArray) : objArray;

    var str = '';
    var line = '';

    if ($("#labels").is(':checked')) {
        var head = array[0];
        if ($("#quote").is(':checked')) {
            for (var index in array[0]) {
                var value = index + "";
                line += '"' + value.replace(/"/g, '""') + '",';
            }
        } else {
            for (var index in array[0]) {
                line += index + ',';
            }
        }

        line = line.slice(0, -1);
        str += line + '\r\n';
    }

    for (var i = 0; i < array.length; i++) {
        var line = '';

        if ($("#quote").is(':checked')) {
            for (var index in array[i]) {
                var value = array[i][index] + "";
                line += '"' + value.replace(/"/g, '""') + '",';
            }
        } else {
            for (var index in array[i]) {
                line += array[i][index] + ',';
            }
        }

        line = line.slice(0, -1);
        str += line + '\r\n';
    }
    return str;
    
}

var globalVarA;

function exportFunctionA(){
	   var redJson=JSON.stringify(globalVarA.redescriptions);

		var csv = JSON2CSV(redJson);
	   
	   var blob = new Blob([csv], {type: "text/plain;charset=utf-8"});
		saveAs(blob, "redescriptions.csv");
	   
   };
   
var globalVarA1;

 function exportFunctionSuppA(){
 console.log("globalVarA1");
 console.log(globalVarA1);
	   var redJson=JSON.stringify(globalVarA1);

		var csv = JSON2CSV(redJson);
	   
	   var blob = new Blob([csv], {type: "text/plain;charset=utf-8"});
		saveAs(blob, "redescriptionSupport.csv");
	   
   };

var GlScope;
var databaseConfig="http://localhost:8081/redundancyAll";
var databaseConfigOld="http://localhost:8081/redundancyinfo";
var databaseConfig1="http://localhost:8081/redundancyinfo1";
//var Q = require('q');

var AllRedsAttrs="http://localhost:8081/redundancyAttrs";
var loadGraph="http://localhost:8081/graphDataAttr";
var saveGraphAttr="http://localhost:8081/graphDataAttr";
var saveGraphAttrG="http://localhost:8081/graphDataAttrG";
	
	function filteringA(pload,$scope, elOv, atOv){

	var toDelete = new HashSet();
					
					//sort reds
					$scope.ricaG.RedsContainingAttrs.redescriptions.sort(function(a, b){
					
					if(a.col3==b.col3){
						
						if(a.col5==b.col5){
							
							if(a.col4==b.col4){
									
									if(a.col5==b.col5){
										return a.col6-b.col6;
									}
									else{
										return a.col5-b.col5;
									}
									
							}
							else{
								return b.col4-a.col4;
							}
						
						}
						else{
							return a.col5-b.col5;
						}
						
					}
					else{
						return b.col3-a.col3;
					}
					
					});
	
	for(i=0;i<$scope.ricaG.RedsContainingAttrs.redescriptions.length-1;i++)
							for(j=i+1;j<$scope.ricaG.RedsContainingAttrs.redescriptions.length;j++){
								
								if(toDelete.contains($scope.ricaG.RedsContainingAttrs.redescriptions[j].id))
											continue;
								
								var perc=(i*$scope.ricaG.RedsContainingAttrs.redescriptions.length+j)/($scope.ricaG.RedsContainingAttrs.redescriptions.length*$scope.ricaG.RedsContainingAttrs.redescriptions.length)*100;
							
								
												var jsEl= 1.0-$scope.graphInput[$scope.ricaG.RedsContainingAttrs.redescriptions[i].id+""][$scope.ricaG.RedsContainingAttrs.redescriptions[j].id+""];
												//console.log("jsEl: "+jsEl);
												if(jsEl*100>=elOv){
												if($scope.ricaG.RedsContainingAttrs.redescriptions[i].data[2]>$scope.ricaG.RedsContainingAttrs.redescriptions[j].data[2]){
													toDelete.add($scope.ricaG.RedsContainingAttrs.redescriptions[j].id);
													     }
												else
													toDelete.add($scope.ricaG.RedsContainingAttrs.redescriptions[i].id);
													//break;
													}	

									
												
												var jsAt= 1.0-$scope.graphInputAttrs[$scope.ricaG.RedsContainingAttrs.redescriptions[i].id+""][$scope.ricaG.RedsContainingAttrs.redescriptions[j].id+""];
												//console.log("jsAt: "+jsAt);
												if(jsAt*100>=atOv){
												if($scope.ricaG.RedsContainingAttrs.redescriptions[i].data[2]>$scope.ricaG.RedsContainingAttrs.redescriptions[j].data[2]){
													toDelete.add($scope.ricaG.RedsContainingAttrs.redescriptions[j].id);
													     }
												else
													toDelete.add($scope.ricaG.RedsContainingAttrs.redescriptions[i].id);
													//break;
													}
													
							}
							
						//while(toDelete.size()>0){
							for(i=0;i<$scope.ricaG.RedsContainingAttrs.redescriptions.length;i++){
								if(toDelete.contains($scope.ricaG.RedsContainingAttrs.redescriptions[i].id)){
									toDelete.remove($scope.ricaG.RedsContainingAttrs.redescriptions[i].id);
									$scope.ricaG.RedsContainingAttrs.redescriptions.splice(i,1);
									i--;
								}
									
						//	}		
						}
	
			//pload.style.visibility="hidden";
	}

	var getInPartsAttr = function(startIndex, endIndex, numReds, $scope){
				if(typeof($scope.graphInputAttrs)=='undefined')
						$scope.graphInputAttrs = [];
					return Q.spread([startIndex, endIndex, $scope], function(startIndex, endIndex,$scope){
							var options = {url: saveGraphAttr,
												method: 'GET', 
												params: {
													start: JSON.stringify(startIndex),
													end: JSON.stringify(endIndex),
													nr: JSON.stringify(numReds)
													}
												};
												
									var tmpPromise = $scope.getGraphData(options);	
									
									return tmpPromise;
									
									var tmpRes;
									
									tmpPromise.success(function (data) {
											tmpRes=data;
											console.log('data');
											console.log(tmpRes);
												$scope.error = '';
										})
										.error(function (data, status) {
										if (status === 404) {
											$scope.error = 'REST server is offline!';
										} else {
												$scope.error = 'Error: ' + status;
											}
											}).then(function(){
											
											console.log('got a part of data');
											console.log(tmpRes);
											var tmp=new Array();
											
											
											
											return tmp;
											//convert to HashMap arrayList
											
											});
												
					})
				};
	
  function filterRedsNewA(){

  var checkTable="http://localhost:8081/checkTable";
  var checkTableAttrs="http://localhost:8081/checkTableAttrs";
  var numredsLink="http://localhost:8081/numReds";
  var AllRedsSupps="http://localhost:8081/redundancySupp";
  var loadGraph="http://localhost:8081/graphData";
  var saveGraph="http://localhost:8081/graphData";
  var saveGraphG="http://localhost:8081/graphDataG";
  //var numredsLink="http://localhost:8081/numReds";
  
   var pload=document.getElementById("loader");
  //pload.style.visibility="visible";
  var appElement = document.querySelector('[ng-app=redApp]');
   var $scope = angular.element(appElement).scope();
   
    var elOv=$("#eoverIn").val(); var atOv=$("#atoverIn").val();
	
		console.log('FRN called!');
		console.log($scope.RedsInSomClust);
	
	//add computing/loading part for element/attribute overlap
	
	/*var optionsNR = {url: numredsLink,
					method: 'GET',
					params: {}
							};
								 
		var promiseNR = $scope.generalGETRequest(optionsNR);
				
				
						promiseNR.success(function (data) {
					   $scope.numReds = data;
					   $scope.error = '';
									})
								.error(function (data, status) {
									if (status === 404) {
											$scope.error = 'REST server is offline!';
											} else {
												$scope.error = 'Error: ' + status;
													}
												}).then(function(){
	
			if($scope.numReds.numReds[0].numReds<3500){*/
	
			if(typeof $scope.graphInput=='undefined'){
		
		var options = {url: checkTable,
               method: 'GET', 
               params: {
                        }
                          };
						  
				 var promise=$scope.getCheckTable(options);//$scope.getRedundancyInfo(options);
						  promise.success(function (data) {
				$scope.TableExist=data;
                $scope.error = '';
           })
          .error(function (data, status) {
              if (status === 404) {
                $scope.error = 'REST server is offline!';
              } else {
                $scope.error = 'Error: ' + status;
              }
          }).then(function(){
		  
		  console.log($scope.TableExist);
		  
				if($scope.TableExist.count[0].number==0){
					
					options = {url: AllRedsSupps,
							method: 'GET', 
							params: {
								}
                          };
						  
						   var promise1=$scope.getRedsSupps(options);
						    promise1.success(function (data) {
							$scope.RedsSupps=data;
							$scope.error = '';
						})
							.error(function (data, status) {
							if (status === 404) {
							$scope.error = 'REST server is offline!';
						} else {
								$scope.error = 'Error: ' + status;
							}
							}).then(function(){
							
						
							var redSupps=new HashMap();
							console.log($scope.RedsSupps);
							console.log('Q');
							console.log(Q);
						
						
						var promise3 = Q.all( [
						loadToStruct(redSupps,$scope)
							])
						
						Q.allSettled(promise3).then(function(results){
						results.forEach(function(result){
						
						if (result.state === "fulfilled") {
								var redSupps = result.value;
								
							var graph= new HashMap();
							console.log("then part!");
							console.log(redSupps);
							console.log(redSupps.count());

							var i=0;
							var j=i+1;
							var numReds = redSupps.count();
							var myVar=setInterval(function() {
									/*console.log("myVar function")
									console.log(i);
									console.log(j);*/
									var perc= (i/numReds)*100;
									
							document.getElementById("graphProg").innerHTML = "Graph computation: "+perc.toFixed(2)+"%";
								
								var set1 = redSupps.get(i);
								
								for(j=i+1;j<numReds;j++){
								var set2 = redSupps.get(j);
								
								var intersection=0;
								var set1val = set1.values();
								
								for(var z=0;z<set1val.length;z++)
									if(set2.contains(set1val[z]))
										intersection=intersection+1;
										
								var edge = intersection/(set1.size()+set2.size()-intersection);
								
								if(!graph.has(i)){
									var t=new Array(numReds);
									t[i]=1.0;
									graph.set(i,t);
								}
								
								if(!graph.has(j)){
									var t=new Array(numReds);
									t[j]=1.0;
									graph.set(j,t);
								}
								
								var t=graph.get(i);
								t[j]=edge;
								graph.set(i,t);
								
								t=graph.get(j);
								t[i]=edge;
								graph.set(j,t);
								}
								
			
								if(i==(numReds-1) && j==(numReds)){
										clearInterval(myVar);
										document.getElementById("graphProg").innerHTML = "Graph computation: "+"100%";
										console.log(graph);
										
										
											var totalNumberP = parseInt(graph.count())*parseInt(graph.count());
										var numRedsinBucketP = Math.floor(2571800/parseInt(graph.count()));//2571800
										var numItersP = Math.ceil(totalNumberP/(numRedsinBucketP*parseInt(graph.count())));
										console.log('Num iters: '+numItersP);
								var promisesP=new Array();
								var retDataAll=new Array(graph.count());
								for(var parts=0;parts<numItersP;parts++){
									var startIndex = parts*numRedsinBucketP;
									var endIndex = startIndex + numRedsinBucketP;
									var size = numRedsinBucketP;
									
									if(endIndex>=graph.count()){
										var diff = endIndex - graph.count();
										size = size-diff;
									}
									
									console.log(endIndex);
									console.log(size);
									
									var retData=new Array(size/*graph.count()*/);
									
									var dat;
										
										for(var z=startIndex;z<startIndex+size/*numRedsinBucketP*//*graph.count()*/;z++)//2000
											retData[z-startIndex]=graph.get(z);
											retDataAll[z]=graph.get(z);;
											console.log("retData");
												console.log(retData);
											
											options = {url: saveGraphG,
												method: 'POST', 
												params: {
													},
											    data: { graph:  JSON.stringify(retData), start: startIndex		
											}
												};

												
												
										promisesP.push($scope.setGraphData(options));
									}
									
											
										
										
												
										//var promise5=$scope.setGraphData(options);
										
										
										/*promise5.success(function (data) {
											console.log('Data stored succesfully!');
												$scope.error = '';
										})
										.error(function (data, status) {
										if (status === 404) {
											$scope.error = 'REST server is offline!';
										} else {
												$scope.error = 'Error: ' + status;
											}
											})*/
											var promise5 = Q.all(promisesP).then(function(){
											retData = retDataAll;
														var inputForAlgo={};
														
														for(var i=0;i<retData.length;i++){
																var eds1={};
															for(var j=0;j<retData[i].length;j++){
																if(i==j)
																	continue;
																if(typeof retData[i][j] == 'undefined')
																	 continue;//retData[i][j]=0.0;//continue;
																	
																	eds1[j]=1.0-retData[i][j];
															}
																inputForAlgo[i]=eds1;
														}
											
														$scope.checkedOrder.co=[];
														$scope.graphInput = inputForAlgo;
											
														console.log("Create parameters and define scope variable here");//put watch on it in the scope.
														//retData[i][j] //use to implement filtering
																		//add three cases for attributes
																		
														if(typeof $scope.graphInputAttrs=='undefined'){
		
																var options = {url: checkTableAttrs,
																				method: 'GET', 
																				params: {
																					}
																				};
						  
																var promiseCT=$scope.getCheckTable(options);//$scope.getRedundancyInfo(options);
																	promiseCT.success(function (data) {
																	$scope.TableExistAttrs=data;
																	$scope.error = '';
																				})
																	.error(function (data, status) {
																		if (status === 404) {
																			$scope.error = 'REST server is offline!';
																			} else {
																			$scope.error = 'Error: ' + status;
																			}
																	}).then(function(){
																		
																		console.log('table exists attrs');
																		console.log($scope.TableExistAttrs);
		  
																			if($scope.TableExistAttrs.count[0].number==0){
																					
																					var optionsAttr = {url: AllRedsAttrs,
																											method: 'GET', 
																											params: {
																												}
																											};
						  
																					var promise1=$scope.getRedsAttrs(optionsAttr);
																					console.log('promise1');
																					console.log(promise1);
						   
																					promise1.success(function (data) {
																							console.log('success get attrs!');
																							console.log(data);
																							$scope.RedsAttrs=data;
																							$scope.error = '';
																								})
																							.error(function (data, status) {
																								console.log('error get attrs!');
																							if (status === 404) {
																								$scope.error = 'REST server is offline!';
																							} else {
																								$scope.error = 'Error: ' + status;
																								}
																							}).then(function(){
																									console.log('attributes recieved');
																									console.log($scope.RedsAttrs);
																									var redAttrs=new HashMap();
																									console.log($scope.RedsAttrs);
																									console.log('Q');
																									console.log(Q);
						
																										var promise3 = Q.all( [
																												loadToStructAttrs(redAttrs,$scope) //mozda ne treba
																													])
						
																										Q.allSettled(promise3).then(function(results){
																												results.forEach(function(result){
						
																												if (result.state === "fulfilled") {
																														var redAttrs = result.value;
																														console.log('result Attr');
																														console.log(result.value);
								
																							var graphAttr= new HashMap();
																									console.log("then part!");
																									console.log(redAttrs);
																									console.log(redAttrs.count());

																										var i=0;
																										var j=i+1;
																								var numReds = redAttrs.count();
																								
																						var myVar=setInterval(function() {

																							var perc= (i/numReds)*100;
										
																								document.getElementById("graphProg").innerHTML = "Graph computation: "+perc.toFixed(2)+"%";
								
																							var set1 = redAttrs.get(i);
								
																						for(j=i+1;j<numReds;j++){
																								var set2 = redAttrs.get(j);
								
																								var intersection=0;
																								var set1val = set1.values();
								
																							for(var z=0;z<set1val.length;z++)
																									if(set2.contains(set1val[z]))
																											intersection=intersection+1;
										
																										var edge = intersection/(set1.size()+set2.size()-intersection);
								
																									if(!graphAttr.has(i)){
																											var t=new Array(numReds);
																											t[i]=1.0;
																											graphAttr.set(i,t);
																										}
									
																									if(!graphAttr.has(j)){
																											var t=new Array(numReds);
																												t[j]=1.0;
																												graphAttr.set(j,t);
																											}
								
																									var t=graphAttr.get(i);
																										t[j]=edge;
																										graphAttr.set(i,t);
								
																										t=graphAttr.get(j);
																										t[i]=edge;
																										graphAttr.set(j,t);
																									}
								
			
																			if(i==(numReds-1) && j==(numReds)){
																					clearInterval(myVar);
																					document.getElementById("graphProg").innerHTML = "Graph computation: "+"100%";
																					console.log(graphAttr);
										
																					var totalNumberP = parseInt(graphAttr.count())*parseInt(graphAttr.count());
										var numRedsinBucketP = Math.floor(2571800/parseInt(graphAttr.count()));//2571800
										var numItersP = Math.ceil(totalNumberP/(numRedsinBucketP*parseInt(graphAttr.count())));
										console.log('Num iters: '+numItersP);
								
								var promisesP=new Array();
								var retDataAll=new Array(graphAttr.count());
								for(var parts=0;parts<numItersP;parts++){
									var startIndex = parts*numRedsinBucketP;
									var endIndex = startIndex + numRedsinBucketP;
									var size = numRedsinBucketP;
									
									if(endIndex>=graphAttr.count()){
										var diff = endIndex - graphAttr.count();
										size = size-diff;
									}
									
									console.log(endIndex);
									console.log(size);
									
									var retData=new Array(size/*graphAttr.count()*/);
									
									var dat;
										
										for(var z=startIndex;z<startIndex+size/*numRedsinBucketP*//*graphAttr.count()*/;z++)//2000
											retData[z-startIndex]=graphAttr.get(z);
											retDataAll[z]=graphAttr.get(z);;
											console.log("retData");
												console.log(retData);
											
											options = {url: saveGraphAttrG,
												method: 'POST', 
												params: {
													},
											    data: { graphAttr:  JSON.stringify(retData), start: startIndex		
											}
												};

												
												
										promisesP.push($scope.setGraphData(options));
									}
									
											
										
										
												
										//var promise5=$scope.setGraphData(options);
										
										
										/*promise5.success(function (data) {
											console.log('Data stored succesfully!');
												$scope.error = '';
										})
										.error(function (data, status) {
										if (status === 404) {
											$scope.error = 'REST server is offline!';
										} else {
												$scope.error = 'Error: ' + status;
											}
											})*/
											//var gcpromise=$scope.setGraphData(options); 
											var gcpromise = Q.all(promisesP).then(function(){
																								retData = retDataAll;
																								var inputForAlgoAttrs={};
														
																								for(var i=0;i<retData.length;i++){
																										var eds1={};
																										for(var j=0;j<retData[i].length;j++){
																											if(i==j)
																												continue;
																											if(typeof retData[i][j] == 'undefined')
																												continue;//retData[i][j]=0.0;//continue;
																	
																											eds1[j]=1.0-retData[i][j];
																										}
																									inputForAlgoAttrs[i]=eds1;
																									}
											
																											$scope.checkedOrder.co=[];
																											$scope.graphInputAttrs = inputForAlgoAttrs;
																											
																											//use graphInput and graphInputAttrs
																											filteringA(pload,$scope,elOv,atOv);
																											$scope.$apply();
																											});
																									}
																									
																									i=i+1;
																								  },5)
																								}
																							})
																					})
																				})																					
																			}
																			else{
																				
																					var optionsNR = {url: numredsLink,
																										method: 'GET',
																										params: {}
																									};
								 
																					var promiseNR = $scope.generalGETRequest(optionsNR);
				
				
																						promiseNR.success(function (data) {
																										$scope.numReds = data;
																										$scope.error = '';
																							})
																									.error(function (data, status) {
																									if (status === 404) {
																											$scope.error = 'REST server is offline!';
																									} else {
																										$scope.error = 'Error: ' + status;
																										}
																									}).then(function(){
											
																										console.log('num reds:');
																										console.log($scope.numReds); 
																										console.log($scope.numReds.numReds[0].numReds);
											
																										var numReds = $scope.numReds.numReds[0].numReds;																				
																					
																										//var promiseGR=getAttrGraph($scope);

																														var totalNumber = numReds*numReds;
																														var numRedsinBucket = Math.floor(2571800/numReds);
																														console.log('numRedsInBucket: '+numRedsinBucket);
																														var numIters = Math.ceil(totalNumber/(numRedsinBucket*parseInt(numReds)));
																														console.log('numIters: '+numIters);

																														var promises=new Array();
									
																															for(var parts=0;parts<numIters;parts++){
																																	var startIndex = parts*numRedsinBucket;
																																	var endIndex = (parts+1)*numRedsinBucket;
																																		if(endIndex>numReds)
																																				endIndex=numReds;
																																				promises.push(getInPartsAttr(startIndex,endIndex,numReds,$scope));
																																			}
									
																															var joinedPromise = Q.all(promises);
																										
																										joinedPromise.then(function(values){
									
																													console.log('All data received!');
																													console.log('values');
																													console.log(values);
									
																													var inputAttrs = [];
									
																													console.log('computing input: ');
																													console.log('values length: '+values.length);
																													console.log('graph length: '+values[0].data.GraphDataAttr.length);
									
																														for(var iv=0;iv<values.length;iv++){
																																		for(var iv1=0;iv1<values[iv].data.GraphDataAttr.length;iv1++)
																																				inputAttrs.push(values[iv].data.GraphDataAttr[iv1]);
																																						console.log(inputAttrs.length);
																														}
									
																															console.log('joined input: ');
																															console.log(inputAttrs);
										
																															values=[];
	
																															console.log("Create parameters and define scope variable here");//put watch on it in the scope.
														
																															var inputForAlgoAttrs={};
														
																																for(var i=0;i<inputAttrs.length;i++){
																																				var eds1={};
																																		for(var j=0;j<inputAttrs[i].length;j++){
																																				if(i==j)
																																					continue;
																																				if(typeof inputAttrs[i][j] == 'undefined')
																																					continue;//retData[i][j]=0.0;//continue;
																	
																																				eds1[j]=1.0-inputAttrs[i][j];
																																				}
																																			inputForAlgoAttrs[i]=eds1;
																																			}

																																			$scope.checkedOrder.co=[];
																																			$scope.graphInputAttrs = inputForAlgoAttrs;
																																			filteringA(pload,$scope,elOv,atOv);
																																			$scope.$apply();
																																		//add three cases for attributes
																																		//use GraphInput and GraphInputAttrs
																																});
																														});
																								}
																							})
																					}
															else{
															filteringA(pload,$scope,elOv,atOv);
															$scope.$apply();
																//use graphInput and graphInputAttrs
															}
															
											})
										
										
										return;
											}
											
											i=i+1;
							}, 5);	
							}
							})
						})							
									//compute the graph, save the graph and compute the input for the algorithm, run the algorithm and draw the result.
							})
							
							}
				else{
				
				var getInParts = function(startIndex, endIndex, numReds, $scope){
				if(typeof($scope.rawGraph)=='undefined')
						$scope.rawGraph = [];
					return Q.spread([startIndex, endIndex, $scope], function(startIndex, endIndex,$scope){
							var options = {url: saveGraph,
												method: 'GET', 
												params: {
													start: JSON.stringify(startIndex),
													end: JSON.stringify(endIndex),
													nr: JSON.stringify(numReds)
													}
												};
												
									var tmpPromise = $scope.getGraphData(options);	
									
									return tmpPromise;
									
									var tmpRes;
									
									tmpPromise.success(function (data) {
											tmpRes=data;
											console.log('data');
											console.log(tmpRes);
												$scope.error = '';
										})
										.error(function (data, status) {
										if (status === 404) {
											$scope.error = 'REST server is offline!';
										} else {
												$scope.error = 'Error: ' + status;
											}
											}).then(function(){
											
											console.log('got a part of data');
											console.log(tmpRes);
											var tmp=new Array();
											
											
											
											return tmp;
											//convert to HashMap arrayList
											
											});
												
					})
				};
				
				var optionsNR = {url: numredsLink,
								 method: 'GET',
								 params: {}
								 };
								 
				var promiseNR = $scope.generalGETRequest(optionsNR);
				
				
				promiseNR.success(function (data) {
											$scope.numReds = data;
												$scope.error = '';
										})
										.error(function (data, status) {
										if (status === 404) {
											$scope.error = 'REST server is offline!';
										} else {
												$scope.error = 'Error: ' + status;
											}
											}).then(function(){
											
											console.log('num reds:');
											console.log($scope.numReds); 
											console.log($scope.numReds.numReds[0].numReds);
											
											var numReds = $scope.numReds.numReds[0].numReds;
											//convert to HashMap arrayList
											
											var totalNumber = numReds*numReds;
											var numRedsinBucket = Math.floor(2571800/numReds);
											console.log('numRedsInBucket: '+numRedsinBucket);
											var numIters = Math.ceil(totalNumber/(numRedsinBucket*parseInt(numReds)));
											console.log('numIters: '+numIters);

									var promises=new Array();
									
									for(var parts=0;parts<numIters;parts++){
									var startIndex = parts*numRedsinBucket;
									var endIndex = (parts+1)*numRedsinBucket;
									if(endIndex>numReds)
										endIndex=numReds;
										promises.push(getInParts(startIndex,endIndex,numReds,$scope));
									}
									
									var joinedPromise = Q.all(promises).then(function(values){
									
									console.log('All data received!');
									console.log('values');
									console.log(values);
									
									var input = [];
									
									console.log('computing input: ');
									console.log('values length: '+values.length);
									console.log('graph length: '+values[0].data.GraphData.length);
									
									for(var iv=0;iv<values.length;iv++){
											for(var iv1=0;iv1<values[iv].data.GraphData.length;iv1++)
												input.push(values[iv].data.GraphData[iv1]);
												console.log(input.length);
									}
									
										console.log('joined input: ');
										console.log(input);
										
										values=[];
	
										console.log("Create parameters and define scope variable here");//put watch on it in the scope.
														
														var inputForAlgo={};
														
														for(var i=0;i<input.length;i++){
																var eds1={};
															for(var j=0;j<input[i].length;j++){
																if(i==j)
																	continue;
																if(typeof input[i][j] == 'undefined')
																	 continue;//retData[i][j]=0.0;//continue;
																	
																	eds1[j]=1.0-input[i][j];
															}
																inputForAlgo[i]=eds1;
														}

														$scope.checkedOrder.co=[];
														$scope.graphInput = inputForAlgo;
														//add three cases for attributes
														
													if(typeof $scope.graphInputAttrs=='undefined'){
		
																var options = {url: checkTableAttrs,
																				method: 'GET', 
																				params: {
																					}
																				};
						  
																var promiseCT=$scope.getCheckTable(options);//$scope.getRedundancyInfo(options);
																	promiseCT.success(function (data) {
																	$scope.TableExistAttrs=data;
																	$scope.error = '';
																				})
																	.error(function (data, status) {
																		if (status === 404) {
																			$scope.error = 'REST server is offline!';
																			} else {
																			$scope.error = 'Error: ' + status;
																			}
																	}).then(function(){
																		
																		console.log('table exists attrs');
																		console.log($scope.TableExistAttrs);
		  
																			if($scope.TableExistAttrs.count[0].number==0){
																					
																					var optionsAttr = {url: AllRedsAttrs,
																											method: 'GET', 
																											params: {
																												}
																											};
						  
																					var promise1=$scope.getRedsAttrs(optionsAttr);
																					console.log('promise1');
																					console.log(promise1);
						   
																					promise1.success(function (data) {
																							console.log('success get attrs!');
																							console.log(data);
																							$scope.RedsAttrs=data;
																							$scope.error = '';
																								})
																							.error(function (data, status) {
																								console.log('error get attrs!');
																							if (status === 404) {
																								$scope.error = 'REST server is offline!';
																							} else {
																								$scope.error = 'Error: ' + status;
																								}
																							}).then(function(){
																									console.log('attributes recieved');
																									console.log($scope.RedsAttrs);
																									var redAttrs=new HashMap();
																									console.log($scope.RedsAttrs);
																									console.log('Q');
																									console.log(Q);
						
																										var promise3 = Q.all( [
																												loadToStructAttrs(redAttrs,$scope) //mozda ne treba
																													])
						
																										Q.allSettled(promise3).then(function(results){
																												results.forEach(function(result){
						
																												if (result.state === "fulfilled") {
																														var redAttrs = result.value;
																														console.log('result Attr');
																														console.log(result.value);

																							var graphAttr= new HashMap();
																									console.log("then part!");
																									console.log(redAttrs);
																									console.log(redAttrs.count());

																										var i=0;
																										var j=i+1;
																								var numReds = redAttrs.count();
																								
																						var myVar=setInterval(function() {

																							var perc= (i/numReds)*100;
										
																								document.getElementById("graphProg").innerHTML = "Graph computation: "+perc.toFixed(2)+"%";
								
																							var set1 = redAttrs.get(i);
								
																						for(j=i+1;j<numReds;j++){
																								var set2 = redAttrs.get(j);
								
																								var intersection=0;
																								var set1val = set1.values();
								
																							for(var z=0;z<set1val.length;z++)
																									if(set2.contains(set1val[z]))
																											intersection=intersection+1;
										
																										var edge = intersection/(set1.size()+set2.size()-intersection);
								
																									if(!graphAttr.has(i)){
																											var t=new Array(numReds);
																											t[i]=1.0;
																											graphAttr.set(i,t);
																										}
									
																									if(!graphAttr.has(j)){
																											var t=new Array(numReds);
																												t[j]=1.0;
																												graphAttr.set(j,t);
																											}
								
																									var t=graphAttr.get(i);
																										t[j]=edge;
																										graphAttr.set(i,t);
								
																										t=graphAttr.get(j);
																										t[i]=edge;
																										graphAttr.set(j,t);
																									}
								
			
																			if(i==(numReds-1) && j==(numReds)){
																					clearInterval(myVar);
																					document.getElementById("graphProg").innerHTML = "Graph computation: "+"100%";
																					console.log(graphAttr);
										
																					var totalNumberP = parseInt(graphAttr.count())*parseInt(graphAttr.count());
																					var numRedsinBucketP = Math.floor(2571800/parseInt(graphAttr.count()));//2571800
																					var numItersP = Math.ceil(totalNumberP/(numRedsinBucketP*parseInt(graphAttr.count())));
																					console.log('Num iters: '+numItersP);
																				
																					var promisesP=new Array();
																					var retDataAll=new Array(graphAttr.count());
																					for(var parts=0;parts<numItersP;parts++){
																						var startIndex = parts*numRedsinBucketP;
																						var endIndex = startIndex + numRedsinBucketP;
																						var size = numRedsinBucketP;
									
																						if(endIndex>=graphAttr.count()){
																							var diff = endIndex - graphAttr.count();
																							size = size-diff;
																						}
																						
																						console.log(endIndex);
																						console.log(size);
																						
																						var retData=new Array(size/*graphAttr.count()*/);
																						
																						var dat;
										
																							for(var z=startIndex;z<startIndex+size/*numRedsinBucketP*//*graphAttr.count()*/;z++)//2000
																								retData[z-startIndex]=graphAttr.get(z);
																								retDataAll[z]=graphAttr.get(z);;
																								console.log("retData");
																									console.log(retData);
																								
																								options = {url: saveGraphAttrG,
																									method: 'POST', 
																									params: {
																										},
																									data: { graphAttr:  JSON.stringify(retData), start: startIndex		
																								}
																									};

																									
																									
																							promisesP.push($scope.setGraphData(options));
																						}
																						
											var gcpromise = Q.all(promisesP).then(function(){
											
																								retData = retDataAll;
																								var inputForAlgoAttrs={};
														
																								for(var i=0;i<retData.length;i++){
																										var eds1={};
																										for(var j=0;j<retData[i].length;j++){
																											if(i==j)
																												continue;
																											if(typeof retData[i][j] == 'undefined')
																												continue;//retData[i][j]=0.0;//continue;
																	
																											eds1[j]=1.0-retData[i][j];
																										}
																									inputForAlgoAttrs[i]=eds1;
																									}
											
																											$scope.checkedOrder.co=[];
																											$scope.graphInputAttrs = inputForAlgoAttrs;
																											
																											//use graphInput and graphInputAttrs
																											filteringA(pload,$scope,elOv,atOv);
																											$scope.$apply();
																											});
																									}
																									
																									i=i+1;
																								  },5)
																								}
																							})
																					})
																				})																					
																			}
																			else{
																				
																					var optionsNR = {url: numredsLink,
																										method: 'GET',
																										params: {}
																									};
								 
																					var promiseNR = $scope.generalGETRequest(optionsNR);
				
				
																						promiseNR.success(function (data) {
																										$scope.numReds = data;
																										$scope.error = '';
																							})
																									.error(function (data, status) {
																									if (status === 404) {
																											$scope.error = 'REST server is offline!';
																									} else {
																										$scope.error = 'Error: ' + status;
																										}
																									}).then(function(){
											
																										console.log('num reds:');
																										console.log($scope.numReds); 
																										console.log($scope.numReds.numReds[0].numReds);
											
																										var numReds = $scope.numReds.numReds[0].numReds;																				
																					
																										//var promiseGR=getAttrGraph($scope);

																														var totalNumber = numReds*numReds;
																														var numRedsinBucket = Math.floor(2571800/numReds);
																														console.log('numRedsInBucket: '+numRedsinBucket);
																														var numIters = Math.ceil(totalNumber/(numRedsinBucket*parseInt(numReds)));
																														console.log('numIters: '+numIters);

																														var promises=new Array();
									
																															for(var parts=0;parts<numIters;parts++){
																																	var startIndex = parts*numRedsinBucket;
																																	var endIndex = (parts+1)*numRedsinBucket;
																																		if(endIndex>numReds)
																																				endIndex=numReds;
																																				promises.push(getInPartsAttr(startIndex,endIndex,numReds,$scope));
																																			}
									
																															var joinedPromise = Q.all(promises);
																										
																										joinedPromise.then(function(values){
									
																													console.log('All data received!');
																													console.log('values');
																													console.log(values);
									
																													var inputAttrs = [];
									
																													console.log('computing input: ');
																													console.log('values length: '+values.length);
																													console.log('graph length: '+values[0].data.GraphDataAttr.length);
									
																														for(var iv=0;iv<values.length;iv++){
																																		for(var iv1=0;iv1<values[iv].data.GraphDataAttr.length;iv1++)
																																				inputAttrs.push(values[iv].data.GraphDataAttr[iv1]);
																																						console.log(inputAttrs.length);
																														}
									
																															console.log('joined input: ');
																															console.log(inputAttrs);
										
																															values=[];
	
																															console.log("Create parameters and define scope variable here");//put watch on it in the scope.
														
																															var inputForAlgoAttrs={};
														
																																for(var i=0;i<inputAttrs.length;i++){
																																				var eds1={};
																																		for(var j=0;j<inputAttrs[i].length;j++){
																																				if(i==j)
																																					continue;
																																				if(typeof inputAttrs[i][j] == 'undefined')
																																					continue;//retData[i][j]=0.0;//continue;
																	
																																				eds1[j]=1.0-inputAttrs[i][j];
																																				}
																																			inputForAlgoAttrs[i]=eds1;
																																			}

																																			$scope.checkedOrder.co=[];
																																			$scope.graphInputAttrs = inputForAlgoAttrs;
																																			filteringA(pload,$scope,elOv,atOv);
																																			$scope.$apply();
																																		//add three cases for attributes
																																		//use GraphInput and GraphInputAttrs
																																});
																														});
																								}
																							})
																					}
															else{
															filteringA(pload,$scope,elOv,atOv);
															$scope.$apply();
																//use graphInput and graphInputAttrs
															}			
									
									});
											
									});
				
						//load the graph and compute the input for the algorithm, run the algorithm and draw the result.
					
				}
		  
				});
			}
			else{
			//use graphInput for filtering
													console.log("Algorithm input: ");
														console.log($scope.graphInput);
													 var inputForAlgo = $scope.graphInput;
														
														
														$scope.checkedOrder.co=[];
														$scope.graphInput = inputForAlgo;
														//add three cases for attributes
														
											if(typeof $scope.graphInputAttrs=='undefined'){
		
																var options = {url: checkTableAttrs,
																				method: 'GET', 
																				params: {
																					}
																				};
						  
																var promiseCT=$scope.getCheckTable(options);//$scope.getRedundancyInfo(options);
																	promiseCT.success(function (data) {
																	$scope.TableExistAttrs=data;
																	$scope.error = '';
																				})
																	.error(function (data, status) {
																		if (status === 404) {
																			$scope.error = 'REST server is offline!';
																			} else {
																			$scope.error = 'Error: ' + status;
																			}
																	}).then(function(){
																		
																		console.log('table exists attrs');
																		console.log($scope.TableExistAttrs);
		  
																			if($scope.TableExistAttrs.count[0].number==0){
																					
																					var optionsAttr = {url: AllRedsAttrs,
																											method: 'GET', 
																											params: {
																												}
																											};
						  
																					var promise1=$scope.getRedsAttrs(optionsAttr);
																					console.log('promise1');
																					console.log(promise1);
						   
																					promise1.success(function (data) {
																							console.log('success get attrs!');
																							console.log(data);
																							$scope.RedsAttrs=data;
																							$scope.error = '';
																								})
																							.error(function (data, status) {
																								console.log('error get attrs!');
																							if (status === 404) {
																								$scope.error = 'REST server is offline!';
																							} else {
																								$scope.error = 'Error: ' + status;
																								}
																							}).then(function(){
																									console.log('attributes recieved');
																									console.log($scope.RedsAttrs);
																									var redAttrs=new HashMap();
																									console.log($scope.RedsAttrs);
																									console.log('Q');
																									console.log(Q);
						
																										var promise3 = Q.all( [
																												loadToStructAttrs(redAttrs,$scope) //mozda ne treba
																													])
						
																										Q.allSettled(promise3).then(function(results){
																												results.forEach(function(result){
						
																												if (result.state === "fulfilled") {
																														var redAttrs = result.value;
																														console.log('result Attr');
																														console.log(result.value);
																					
																				/*	var res = createAttrGraph($scope,result.value); //change the code here!
																					
																					console.log('res[0]');
																					console.log(res[0]);
																					console.log(res[0].success);
																					var gcpromise = res[0];*/
																					
																						//var redAttrs = result.value;
								
																							var graphAttr= new HashMap();
																									console.log("then part!");
																									console.log(redAttrs);
																									console.log(redAttrs.count());

																										var i=0;
																										var j=i+1;
																								var numReds = redAttrs.count();
																								
																						var myVar=setInterval(function() {

																							var perc= (i/numReds)*100;
										
																								document.getElementById("graphProg").innerHTML = "Graph computation: "+perc.toFixed(2)+"%";
								
																							var set1 = redAttrs.get(i);
								
																						for(j=i+1;j<numReds;j++){
																								var set2 = redAttrs.get(j);
								
																								var intersection=0;
																								var set1val = set1.values();
								
																							for(var z=0;z<set1val.length;z++)
																									if(set2.contains(set1val[z]))
																											intersection=intersection+1;
										
																										var edge = intersection/(set1.size()+set2.size()-intersection);
								
																									if(!graphAttr.has(i)){
																											var t=new Array(numReds);
																											t[i]=1.0;
																											graphAttr.set(i,t);
																										}
									
																									if(!graphAttr.has(j)){
																											var t=new Array(numReds);
																												t[j]=1.0;
																												graphAttr.set(j,t);
																											}
								
																									var t=graphAttr.get(i);
																										t[j]=edge;
																										graphAttr.set(i,t);
								
																										t=graphAttr.get(j);
																										t[i]=edge;
																										graphAttr.set(j,t);
																									}
								
			
																			if(i==(numReds-1) && j==(numReds)){
																					clearInterval(myVar);
																					document.getElementById("graphProg").innerHTML = "Graph computation: "+"100%";
																					console.log(graphAttr);
										
																					var totalNumberP = parseInt(graphAttr.count())*parseInt(graphAttr.count());
																					var numRedsinBucketP = Math.floor(2571800/parseInt(graphAttr.count()));//2571800
																					var numItersP = Math.ceil(totalNumberP/(numRedsinBucketP*parseInt(graphAttr.count())));
																					console.log('Num iters: '+numItersP);
																				
																					var promisesP=new Array();
																					var retDataAll=new Array(graphAttr.count());
																					for(var parts=0;parts<numItersP;parts++){
																						var startIndex = parts*numRedsinBucketP;
																						var endIndex = startIndex + numRedsinBucketP;
																						var size = numRedsinBucketP;
									
																						if(endIndex>=graphAttr.count()){
																							var diff = endIndex - graphAttr.count();
																							size = size-diff;
																						}
																						
																						console.log(endIndex);
																						console.log(size);
																						
																						var retData=new Array(size/*graphAttr.count()*/);
																						
																						var dat;
										
																							for(var z=startIndex;z<startIndex+size/*numRedsinBucketP*//*graphAttr.count()*/;z++)//2000
																								retData[z-startIndex]=graphAttr.get(z);
																								retDataAll[z]=graphAttr.get(z);;
																								console.log("retData");
																									console.log(retData);
																								
																								options = {url: saveGraphAttrG,
																									method: 'POST', 
																									params: {
																										},
																									data: { graphAttr:  JSON.stringify(retData), start: startIndex		
																								}
																									};

																									
																									
																							promisesP.push($scope.setGraphData(options));
																						}
																						 
											var gcpromise = Q.all(promisesP).then(function(){
																								
																								retData = retDataAll;
																								var inputForAlgoAttrs={};
														
																								for(var i=0;i<retData.length;i++){
																										var eds1={};
																										for(var j=0;j<retData[i].length;j++){
																											if(i==j)
																												continue;
																											if(typeof retData[i][j] == 'undefined')
																												continue;//retData[i][j]=0.0;//continue;
																	
																											eds1[j]=1.0-retData[i][j];
																										}
																									inputForAlgoAttrs[i]=eds1;
																									}
											
																											$scope.checkedOrder.co=[];
																											$scope.graphInputAttrs = inputForAlgoAttrs;
																											
																											//use graphInput and graphInputAttrs
																											filteringA(pload,$scope,elOv,atOv);
																											$scope.$apply();
																											});
																									}
																									
																									i=i+1;
																								  },5)
																								}
																							})
																					})
																				})																					
																			}
																			else{
																				
																					var optionsNR = {url: numredsLink,
																										method: 'GET',
																										params: {}
																									};
								 
																					var promiseNR = $scope.generalGETRequest(optionsNR);
				
				
																						promiseNR.success(function (data) {
																										$scope.numReds = data;
																										$scope.error = '';
																							})
																									.error(function (data, status) {
																									if (status === 404) {
																											$scope.error = 'REST server is offline!';
																									} else {
																										$scope.error = 'Error: ' + status;
																										}
																									}).then(function(){
											
																										console.log('num reds:');
																										console.log($scope.numReds); 
																										console.log($scope.numReds.numReds[0].numReds);
											
																										var numReds = $scope.numReds.numReds[0].numReds;																				
																					
																										//var promiseGR=getAttrGraph($scope);

																														var totalNumber = numReds*numReds;
																														var numRedsinBucket = Math.floor(2571800/numReds);
																														console.log('numRedsInBucket: '+numRedsinBucket);
																														var numIters = Math.ceil(totalNumber/(numRedsinBucket*parseInt(numReds)));
																														console.log('numIters: '+numIters);

																														var promises=new Array();
									
																															for(var parts=0;parts<numIters;parts++){
																																	var startIndex = parts*numRedsinBucket;
																																	var endIndex = (parts+1)*numRedsinBucket;
																																		if(endIndex>numReds)
																																				endIndex=numReds;
																																				promises.push(getInPartsAttr(startIndex,endIndex,numReds,$scope));
																																			}
									
																															var joinedPromise = Q.all(promises);
																										
																										joinedPromise.then(function(values){
									
																													console.log('All data received!');
																													console.log('values');
																													console.log(values);
									
																													var inputAttrs = [];
									
																													console.log('computing input: ');
																													console.log('values length: '+values.length);
																													console.log('graph length: '+values[0].data.GraphDataAttr.length);
									
																														for(var iv=0;iv<values.length;iv++){
																																		for(var iv1=0;iv1<values[iv].data.GraphDataAttr.length;iv1++)
																																				inputAttrs.push(values[iv].data.GraphDataAttr[iv1]);
																																						console.log(inputAttrs.length);
																														}
									
																															console.log('joined input: ');
																															console.log(inputAttrs);
										
																															values=[];
	
																															console.log("Create parameters and define scope variable here");//put watch on it in the scope.
														
																															var inputForAlgoAttrs={};
														
																																for(var i=0;i<inputAttrs.length;i++){
																																				var eds1={};
																																		for(var j=0;j<inputAttrs[i].length;j++){
																																				if(i==j)
																																					continue;
																																				if(typeof inputAttrs[i][j] == 'undefined')
																																					continue;//retData[i][j]=0.0;//continue;
																	
																																				eds1[j]=1.0-inputAttrs[i][j];
																																				}
																																			inputForAlgoAttrs[i]=eds1;
																																			}

																																			$scope.checkedOrder.co=[];
																																			$scope.graphInputAttrs = inputForAlgoAttrs;
																																			filteringA(pload,$scope,elOv,atOv);
																																			$scope.$apply();
																																		//add three cases for attributes
																																		//use GraphInput and GraphInputAttrs
																																});
																														});
																								}
																							})
																					}
															else{
															filteringA(pload,$scope,elOv,atOv);
															$scope.$apply();
																//use graphInput and graphInputAttrs
															}
			}
				/*}
					else{
					filterReds();
					}
			})*/
		} 


	
  function filterReds(){
  
  //$("#bar").show();
  /*var pbar=document.getElementById("barContainer");
  pbar.style.visibility="visible";
  var bar=document.getElementById("bar");
  //bar.style.width="45%";
  bar.style.visibility="visible";
  var barT=document.getElementById("barText");
  barT.style.visibility="visible";*/
  
  var pload=document.getElementById("loader");
  pload.style.visibility="visible";
  
  var appElement = document.querySelector('[ng-app=redApp]');
   var $scope = angular.element(appElement).scope();
    //var $http = angular.element(appElement).http();
	console.log(angular.element(appElement));
  /* var batchLength=200;
   var n=Math.floor($scope.ricaG.RedsContainingAttrs.redescriptions.length/batchLength);
  
	if($scope.ricaG.RedsContainingAttrs.redescriptions.length<batchLength)
		n=$scope.ricaG.RedsContainingAttrs.redescriptions.length;
	else if($scope.ricaG.RedsContainingAttrs.redescriptions.length%batchLength!=0)
		n=n+1;
	
	console.log("n: "+n);
	console.log("redset size: "+$scope.ricaG.RedsContainingAttrs.redescriptions.length);
	*/
	 var groupMaps= new HashMap();
	 
	 
	 var elOv=$("#eoverIn").val(); var atOv=$("#atoverIn").val();
	 
	 console.log("obtained values!");
	 console.log(elOv+" "+atOv);
	 console.log("Initial set size: "+$scope.ricaG.RedsContainingAttrs.redescriptions.length);
	
  /* for(var i=0;i<n;i++)	{
   var s=[];
	for(var j=0;j<batchLength;j++){
	//console.log("i: "+i); console.log("j: "+j);
			if((i*batchLength+j)<$scope.ricaG.RedsContainingAttrs.redescriptions.length){
			//console.log($scope.ricaG.RedsContainingAttrs.redescriptions[i*200+j].id);
					s.push($scope.ricaG.RedsContainingAttrs.redescriptions[i*batchLength+j].id);
					//console.log(s);
					}
	}
	groupMaps.set(i,s);
	//console.log(s);
  }*/
  
 // console.log($scope.ricaG.RedsContainingAttrs.redescriptions);
 // console.log(groupMaps);
       
 // var str=JSON.stringify(obj); console.log(str);
  var redescriptionElements=new HashMap();
  var redescriptionAttributes = new HashMap();
    var redescriptionElements1=new HashMap();
  var redescriptionAttributes1 = new HashMap(); //console.log(Q);
  //for(i=0;i<1;i++){
  var obj= 1;//$scope.ricaG.RedsContainingAttrs.redescriptions.map(function(c){return{'value': c.id}});  //groupMaps.get(i).map(function(c){return {'value': c}});
	   //console.log(obj);
  var options = {url: databaseConfig,
               method: 'GET', 
               params: {
               ids: JSON.stringify(obj)
                        }
                          };
						 // console.log(Q);
						  var promise=$scope.getRedundancyAll(options);//$scope.getRedundancyInfo(options);
						  promise.success(function (data) {
			  // console.log('function gRI called');
			   //console.log(data);
                //$scope.RedundancyInfo = data;
				$scope.RedundancyAll=data;
                $scope.error = '';
           })
          .error(function (data, status) {
              if (status === 404) {
                $scope.error = 'REST server is offline!';
              } else {
                $scope.error = 'Error: ' + status;
              }
          }).then(function(){
		  
						//console.log("resolved!"); console.log($scope);// console.log($scope.RedundancyInfo); console.log($scope.RedundancyInfo.redElems); 						
							
	for(k=0;k<$scope.RedundancyAll.redElems.length;k++){
			if(!redescriptionElements.has($scope.RedundancyAll.redElems[k].id)){
					var stmp=new HashSet();
					stmp.add($scope.RedundancyAll.redElems[k].elementID);
					redescriptionElements.set($scope.RedundancyAll.redElems[k].id,stmp);
			}
			else{
			var stmp=redescriptionElements.get($scope.RedundancyAll.redElems[k].id);
			stmp.add($scope.RedundancyAll.redElems[k].elementID);
			redescriptionElements.set($scope.RedundancyAll.redElems[k].id,stmp);
			}
						
	}
	
		
	for(k=0;k<$scope.RedundancyAll.redAttr.length;k++){
			if(!redescriptionAttributes.has($scope.RedundancyAll.redAttr[k].id)){
					var stmp=new HashSet();
					stmp.add($scope.RedundancyAll.redAttr[k].attributeID);
					redescriptionAttributes.set($scope.RedundancyAll.redAttr[k].id,stmp);
			}
			else{
				var stmp=redescriptionAttributes.get($scope.RedundancyAll.redAttr[k].id);
				stmp.add($scope.RedundancyAll.redAttr[k].attributeID);
				redescriptionAttributes.set($scope.RedundancyAll.redAttr[k].id,stmp);
			}		
	}
	
	//console.log("loaded all data...");
	//console.log(redescriptionElements); console.log(redescriptionAttributes);
	/*if($scope.ricaG.RedsContainingAttrs.redescriptions[1].id==81){
						$scope.ricaG.RedsContainingAttrs.redescriptions.splice(0,1);
					}*/
					
					var toDelete = new HashSet();
					
					$scope.ricaG.RedsContainingAttrs.redescriptions.sort(function(a, b){
					
					if(a.col3==b.col3){
						
						if(a.col5==b.col5){
							
							if(a.col4==b.col4){
									
									if(a.col5==b.col5){
										return a.col6-b.col6;
									}
									else{
										return a.col5-b.col5;
									}
									
							}
							else{
								return b.col4-a.col4;
							}
						
						}
						else{
							return a.col5-b.col5;
						}
						
					}
					else{
						return b.col3-a.col3;
					}
					
					});
					

					for(i=0;i<$scope.ricaG.RedsContainingAttrs.redescriptions.length-1;i++)
							for(j=i+1;j<$scope.ricaG.RedsContainingAttrs.redescriptions.length;j++){
								
								if(toDelete.contains($scope.ricaG.RedsContainingAttrs.redescriptions[j].id))
											continue;
								
								var perc=(i*$scope.ricaG.RedsContainingAttrs.redescriptions.length+j)/($scope.ricaG.RedsContainingAttrs.redescriptions.length*$scope.ricaG.RedsContainingAttrs.redescriptions.length)*100;
							//console.log(perc);
								if(Math.round(perc)%2==0){
									//console.log("in the function");
								//	console.log(Math.round(perc));
										//bar.style.width= (Math.round(perc))+"%";
										//barT.innerHTML = Math.round(perc)+"% complete...";
										//console.log(barT);
										
								}
							
								var s1Vals= redescriptionElements.get($scope.ricaG.RedsContainingAttrs.redescriptions[i].id).values();
											var sref=redescriptionElements.get($scope.ricaG.RedsContainingAttrs.redescriptions[j].id);
											var intersection=0; var union=0;
											//var s2Vals = redescriptionElements.get($scope.ricaG.RedsContainingAttrs[j].id).values;
											
											for(z=0;z<s1Vals.length;z++){
													if(sref.contains(s1Vals[z])){
														intersection=intersection+1;
														}
											}
											
											//console.log("set size: "+s1Vals.length);
											//console.log("intersection: "+intersection);
											union=s1Vals.length+sref.size()-intersection;
											//console.log("union: "+union);
												
												var jsEl= intersection/union;
												//console.log("jsEl: "+jsEl);
												if(jsEl*100>=elOv){
												if($scope.ricaG.RedsContainingAttrs.redescriptions[i].data[2]>$scope.ricaG.RedsContainingAttrs.redescriptions[j].data[2]){
													toDelete.add($scope.ricaG.RedsContainingAttrs.redescriptions[j].id);
													     }
												else
													toDelete.add($scope.ricaG.RedsContainingAttrs.redescriptions[i].id);
													//break;
													}	

									var s1Vals= redescriptionAttributes.get($scope.ricaG.RedsContainingAttrs.redescriptions[i].id).values();
											var sref=redescriptionAttributes.get($scope.ricaG.RedsContainingAttrs.redescriptions[j].id);
											var intersection=0; var union=0;
											//var s2Vals = redescriptionElements.get($scope.ricaG.RedsContainingAttrs[j].id).values;
											
											for(z=0;z<s1Vals.length;z++){
													if(sref.contains(s1Vals[z])){
														intersection=intersection+1;
														}
											}
											
											union=s1Vals.length+sref.size()-intersection;
												
												var jsAt= intersection/union;
												//console.log("jsAt: "+jsAt);
												if(jsAt*100>=atOv){
												if($scope.ricaG.RedsContainingAttrs.redescriptions[i].data[2]>$scope.ricaG.RedsContainingAttrs.redescriptions[j].data[2]){
													toDelete.add($scope.ricaG.RedsContainingAttrs.redescriptions[j].id);
													     }
												else
													toDelete.add($scope.ricaG.RedsContainingAttrs.redescriptions[i].id);
													//break;
													}
													
							}
							
						//while(toDelete.size()>0){
							for(i=0;i<$scope.ricaG.RedsContainingAttrs.redescriptions.length;i++){
								if(toDelete.contains($scope.ricaG.RedsContainingAttrs.redescriptions[i].id)){
									toDelete.remove($scope.ricaG.RedsContainingAttrs.redescriptions[i].id);
									$scope.ricaG.RedsContainingAttrs.redescriptions.splice(i,1);
									i--;
								}
									
						//	}
									
						}
						pload.style.visibility="hidden";
					/* pbar.style.visibility="hidden";
					 bar.style.visibility="hidden";
					 barT.style.visibility="hidden";*/
					//console.log("Number of remaining redescriptions: ");
					//console.log($scope.ricaG.RedsContainingAttrs.redescriptions.length);
					
						//console.log(redescriptionAttributes); console.log(redescriptionElements);
						//console.log("counter: "+i);
						
						//console.log("call 2 started!");
						
			//for(j=i+1;j<2;j++){
					/*var obj1=groupMaps.get(j).map(function(c){return {'value': c}});
						console.log(obj1);
						options = {url: databaseConfig1,
               method: 'GET', 
               params: {
               ids: JSON.stringify(obj1)
                        }
                          };
						  
						  var promise1=$scope.getRedundancyAll1(options);
						  promise.success(function (data) {
			  // console.log('function gRI called');
			   //console.log(data);
                $scope.RedundancyInfo = data;
                $scope.error = '';
           })
          .error(function (data, status) {
              if (status === 404) {
                $scope.error = 'REST server is offline!';
              } else {
                $scope.error = 'Error: ' + status;
              }
          }).then(function(){
		
			console.log("resolved!"); console.log($scope); console.log($scope.RedundancyInfo1); console.log($scope.RedundancyInfo1.redElems); 
						
							
	for(k=0;k<$scope.RedundancyInfo1.redElems.length;k++){
			if(!redescriptionElements1.has($scope.RedundancyInfo1.redElems[k].id)){
					var stmp=new HashSet();
					stmp.add($scope.RedundancyInfo1.redElems[k].elementID);
					redescriptionElements1.set($scope.RedundancyInfo1.redElems[k].id,stmp);
			}
			else{
			var stmp=redescriptionElements1.get($scope.RedundancyInfo1.redElems[k].id);
			stmp.add($scope.RedundancyInfo1.redElems[k].elementID);
			redescriptionElements1.set($scope.RedundancyInfo1.redElems[k].id,stmp);
			}
						
	}
	
		
	for(k=0;k<$scope.RedundancyInfo1.redAttr.length;k++){
			if(!redescriptionAttributes1.has($scope.RedundancyInfo1.redAttr[k].id)){
					var stmp=new HashSet();
					stmp.add($scope.RedundancyInfo1.redAttr[k].attributeID);
					redescriptionAttributes1.set($scope.RedundancyInfo1.redAttr[k].id,stmp);
			}
			else{
				var stmp=redescriptionAttributes1.get($scope.RedundancyInfo1.redAttr[k].id);
				stmp.add($scope.RedundancyInfo1.redAttr[k].attributeID);
				redescriptionAttributes1.set($scope.RedundancyInfo1.redAttr[k].id,stmp);
			}
						
	}
						console.log(redescriptionAttributes1); console.log(redescriptionElements1);
						console.log("counter1: "+j);
						
					})	
						//}*/						
						});
		//Q.all().then(function(result){console.log("Resolved inside javascript!")});
		//$scope.getRedundancyInfo(options);
		//then(function(result){console.log("promise resolved!")});
		//console.log("Counter outside: "+i)
//}
		/*var tmp=new HashSet();
		tmp.add(1); tmp.add(2); tmp.add(3);
		console.log(tmp);
		console.log(tmp.size());*/
		 // }
		//}
   
   
					/*$scope.$apply(function(){
						console.log("Scope"); console.log($scope);
						console.log("Function filter redescriptions called!");
					if($scope.ricaG.RedsContainingAttrs.redescriptions[1].id==81){
						$scope.ricaG.RedsContainingAttrs.redescriptions.splice(0,1);
					}
				});
					console.log($scope.$apply)*/
   
  //var scope = angular.element($("#outer")).scope();
		}
		
   function choosePlotTypeAtt(myRadio) {
	var appElement = document.querySelector('[ng-app=redApp]');
   var $scope = angular.element(appElement).scope();
   console.log($scope);
   console.log("value of radio button");
   console.log(myRadio.value);
   
   if(myRadio.value === 'nbox'){
		if($scope.plotType1==1){
			$scope.plotType1=2;
		}
		else if($scope.plotType1==2)
			$scope.plotType1=1;
		else
			$scope.plotType1 = 1;
		}
   if(myRadio.value === 'viol')
		$scope.plotType1 = 0;
		
		$scope.$apply();
		
}

function addTrandLinesAtt(myCheck) {
	var appElement = document.querySelector('[ng-app=redApp]');
   var $scope = angular.element(appElement).scope();
   console.log($scope.Trends1);
   console.log($scope);
   console.log(myCheck.checked);
   
   if(myCheck.checked == true)
		$scope.Trends1 = 1;
   if(myCheck.checked == false)
		$scope.Trends1 = 0;
		
		console.log($scope.Trends1);
		$scope.$apply();
}
		
   </script>


<div class="container">

<div class="header">
<h1 class="header-title">Attribute based redescription set exploration</h1>
</div>

<div id="indtroduction" style="margin-top:10px;margin-bottom:10px">
<p>This is the second functionality of the <b> INTERSET tool that </b> allows <b> iterative exploration of redescription sets </b> based on attributes occuring in queries of different redescriptions. </p>
<div id="functionality" style="margin-bottom:20px">
<h3> Functionality</h3>
<p> The attribute based exploration uses the <b>cross-view attribute coocurence heatmap </b> to display which attributes occur often together in redescription queries. The exploration process can be done in several steps: </p>
<ol>
  <li> <b> Select </b> the order which will be used to arrange the attributes in a heatmap</li>
  <li> <b> Select </b> the attribute pair of interest (different attributes can be loaded by using <b>pages</b> at the bottom of heatmap)</li>
  <li> <b> Scroll </b> through redescription table and <b> select </b> some interesting redescription </li>
  <li> <b> Examine </b> additional information about the selected redescription</li>
</ol>
<p> Clicking on some of the components displays new elements on the page. The elements are placed <b> below currently displayed components</b>, so depending on the screen size, you might need to scroll to use them. </p>
</div>

</div>

    <div id="Atapp" ng-app="redApp" ng-controller="redCtrl">
		  <!--<red-filter allred-url="http://localhost:8081/allRedescriptions", redinfo-url="http://localhost:8081/redescriptionInfo" > </red-filter>
		  <selected-redescription style="float:left; margin-top: 50px"> </selected-redescription>-->
		<div id="inputControls" style="height:60px">
	    <label>Number of attributes to display: <input type="text" ng-model="params.toDisplay" ng-init = "params.toDisplay=50" style="width:50px" /></label></br>
			<button ng-model="button" ng-disabled="checked" ng-click="compHeatmap(params)">Create heatmap on all data</button>
			<button ng-model="button" ng-disabled="checked" ng-click="compHeatmapSel(params)">Create heatmap on selection</button>
		 <span id="butonWithRadio">
			<label>
					<input type="radio" ng-model="action.type" value="save" style="margin-left: 30px">
						Save selection
					</label>
			<label>
					<input type="radio" ng-model="action.type" value="load">
						Load and create heatmap
			</label>
			<button ng-model="button" ng-disabled="checked" ng-click="compHeatmapSelShared(params)"  style="margin-left: 500px;">Perform</button>
			</span>
			</div>
			
		  <loadheat-data redattr-url="http://localhost:8081/attributeData" attrfreq-url="http://localhost:8081/attrFreq" allred-url="http://localhost:8081/attributeCoocurence" initat-url="http://localhost:8081/initatData" shared-url="http://localhost:8081/sharedData"> </loadheat-data>	
		  <attribute-heatmap allred-url="http://localhost:8081/attributeCoocurence", attrred-url="http://localhost:8081/attributeRedescriptions" attrredsel-url="http://localhost:8081/attributeRedescriptionsSel"></attribute-heatmap>
		  <attribute-redescriptions redinfo-url="http://localhost:8081/redescriptionInfo"></attribute-redescriptions>
		  <selected-redescription style="float:left; margin-top: 50px"> </selected-redescription>
		  <draw-grapha style="float:left; margin-top: 50px" redinfo-url="http://localhost:8081/redescriptionInfo"> </draw-grapha>
    </div>
</body> 

</html>