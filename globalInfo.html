<html>

<head>

<style>
@import url(http://fonts.googleapis.com/css?family=Lato:400:700);
body {
  /*font-family: "Helvetica Neue";*/
  font-family: "Lato";
  margin: 40px auto;
  width: 960px;
  min-height: 2000px;
}
#body {
  position: relative;
}
footer {
  padding: 2em 0 1em 0;
  font-size: 12px;
}
h1 {
  font-size: 46px;
  margin-top: .3em;
  margin-bottom: 0;
}
h1 + h2 {
  margin-top: 0;
}
h2 {
  font-weight: 400;
  font-size: 28px;
}
h1, h2 {
  font-family: "Lato";
  text-rendering: optimizeLegibility;
}
#body > p {
  line-height: 1.5em;
  width: 640px;
  text-rendering: optimizeLegibility;
}
#redCharts {
  padding: 2px 0;
  width: 860px;
}

#totals {
 padding: 2px 0;
}

.red {
	cursor:pointer;
}

div.red:hover {
    background: LightGray;
}

.chart {
  display: inline-block;
  height: 151px;
  margin-bottom: 20px;
}
.reset {
  padding-left: 1em;
  font-size: smaller;
  color: #ccc;
}
.background.bar {
  fill: #ccc;
}
.foreground.bar {
  fill: seagreen;
}
.axis path, .axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}
.axis text {
  font: 10px sans-serif;
}
.brush rect.extent {
  fill: seagreen;
  fill-opacity: .125;
}
.brush .resize path {
  fill: #eee;
  stroke: #666;
}
/*#js-chart {
  width: 600px;
}
#supports-chart {
  width: 600px;
}
#pval-chart {
  width: 600px;
}
#aej-chart {
  width: 600px;
}
#aaj-chart {
  width: 600px;
}
#date-chart {
  width: 920px;
}*/
#git-list {
  max-height:200px;
  overflow-y:scroll;
  overflow-x: hidden;
}
#git-list .date,
#git-list .day {
  
}
#git-list.date .githeader{
width:940px;
}
#git-list .repo {
  line-height: 1.5em;
  /*background: #eee;*/
  /*background: #336666;*/
  width: 940px;
  margin-bottom: 1px;
}
#git-list .repo .leftrule {
 display: inline-block;
  width: 300px;
}
#git-list .repo div {
  display: inline-block;
  width: 100px;
  vertical-align: middle; 
    margin-bottom:10px;
}
#git-list .repo .number{
  display: inline-block;
  width: 50px;
  text-align: center;
}
#git-list .repo .selctR{
  display: inline-block;
  width: 40px;
  text-align: center;
}
#git-list .repo .rightrule{
  display: inline-block;
  width: 300px;
  margin-left: 40px;
  text-align: left;
}
#gl{
height: 30px;
font-size: 14px;
/*width: 940px;*/
height: 50px;
display: inline-block;
margin-top : 10px;
margin-bottom: 10px;
padding : 10px;
//overflow-x: scroll;
}
#results > div{
  display: inline-block;
  vertical-align: top;
  margin-top : 10px;
}
#git-list div.distance,
#git-list div.delay {
  width: 160px;
  padding-right: 10px;
  text-align: right;
}
#git-list .early {
  color: green;
}
aside {
  position: absolute;
  left: 600px;
  font-size: smaller;
  width: 300px;
}
.bar {
  fill: seagreen;
}

.title{
	text-align: center;
	font-weight: bold;
}

/*.bar:hover {
  fill: brown;
}*/
.axis {
  font: 10px sans-serif;
}
.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}
.y.axis path {
  display: none;
}
.oneline {
 width: 100px;
 height: 30px;
 display: inline-block;
 text-align: right;
}
.hclr {
 width: 250px;
 height: 40px;
 display: inline-block;
 text-align: center;
  margin-top: 10px;
  margin-bottom: 10px;
}

.hclr p {
font-weight: bold;
}

.hcrr {
 width: 385px;
 height: 40px;
 display: inline-block;
 text-align: center;
  margin-top: 10px;
  margin-bottom: 10px;
}

.hcrr p {
font-weight: bold;
}

.hcjs {
 width: 40px;
 height: 40px;
 display: inline-block;
 text-align: center;
 margin-top: 10px;
  margin-bottom: 10px;
}

.hcjs p {
font-weight: bold;
}

.hcsupp {
 width: 60px;
 height: 40px;
 display: inline-block;
 text-align: center;
  margin-top: 10px;
  margin-bottom: 10px;
}

.hcsupp p {
font-weight: bold;
}

.hcpval {
 width: 45px;
 height: 40px;
 display: inline-block;
 text-align: center;
  margin-top: 10px;
  margin-bottom: 10px;
}

.hcpval p {
font-weight: bold;
}

.hcejs {
 width: 50px;
 height: 40px;
 display: inline-block;
 text-align: center;
  margin-top: 10px;
  margin-bottom: 10px;
}

.hcejs p {
font-weight: bold;
}

.hcajs {
 width: 50px;
 height: 40px;
 display: inline-block;
 text-align: center;
 font: bold;
 margin-bottom : 2px;
  margin-top: 10px;
  margin-bottom: 10px;
}

.hcajs p {
font-weight: bold;
}

.hrn {
 width: 250px;
 height: 30px;
 display: inline-block;
}
.hrn:hover{
color:seagreen;
}
.hdate:hover{
color:seagreen;
}
.hpl:hover{
color:seagreen;
}
.hw:hover{
color:seagreen;
}
.hsize:hover{
color:seagreen;
}
.hiss:hover{
color:seagreen;
}
.oneline:hover{
color:seagreen;
}
a {
  text-decoration: none;
}
a:link {
    color: seagreen;
}
a:visited {
    color: seagreen;
}
a:hover {
    color: seagreen;
}
a:active {
    color: seagreen;
}
a.listLink {
  color: seagreen;
}
a.listLink:hover {
  color: seagreen;
}
.searchResultDiv {
  height: 24px;
}

	  	  .node {
  stroke: #fff;
  stroke-width: 1.5px;
}

.link {
  stroke: #999;
  stroke-opacity: .6;
  }
  
  .node {
	cursor:pointer;
}

.link {
	cursor:pointer;
}

</style>



</head>

<body> 

<script> 

function relateRedsG(){
console.log("Relation button pressed!");

var selectedReds = new HashSet();
var checkTable="http://localhost:8081/checkTable";
var AllRedsSupps="http://localhost:8081/redundancySupp";
var loadGraph="http://localhost:8081/graphData";
var saveGraph="http://localhost:8081/graphData";
var saveGraphG="http://localhost:8081/graphDataG";
var numredsLink="http://localhost:8081/numReds";

$('#git-list').each(function (i, row) {

        // reference all the stuff you need first
        var $row = $(row),
            $checkedBoxes = $row.find('input:checked');

        $checkedBoxes.each(function (i, checkbox) {
            // assuming you layout the elements this way, 
            // we'll take advantage of .next()
            var $checkbox = $(checkbox);
               console.log('checkbox');
			   console.log($checkbox);
			   console.log($checkbox[0].id);
			   selectedReds.add(parseInt($checkbox[0].id));
        });
    });
	
   var appElement = document.querySelector('[ng-app=redApp]');
   var $scope = angular.element(appElement).scope();
	
	if($scope.checkedOrderGL.cog.length<2){
		$scope.checkedOrderGL.cog.splice(0,$scope.checkedOrderGL.cog.length);
		
		$('#git-list').each(function (i, row) { //make it work

        // reference all the stuff you need first
        var $row = $(row),
            $checkedBoxes = $row.find('input:checked');
			
			//console.log('row');
			//console.log($row);

        $checkedBoxes.each(function (i, checkbox) {
            // assuming you layout the elements this way, 
            // we'll take advantage of .next()
            var $checkbox = $(checkbox);
               $checkbox.attr('checked', false); 
        });
    });
		
		alert('Select at least two redescriptions!');
		return;
		}
		else{
	
		var globalThreshold = $("#jacConstG").val();
		var globalNumPaths = $("#nPathsG").val();
		
		if(isNaN(globalThreshold) || isNaN(globalNumPaths)){
			alert('Input must be a valid number!');
			return;
		}
		
		globalThreshold = parseFloat(globalThreshold);
		globalNumPaths = parseInt(globalNumPaths);
		console.log('Weight threshold: '+globalThreshold);
		console.log('Num paths: '+globalNumPaths);
		console.log('Checked reds: ');
		console.log($scope.checkedOrderGL.cog);
		
		if(typeof $scope.graphInput=='undefined'){
		
		var options = {url: checkTable,
               method: 'GET', 
               params: {
                        }
                          };
						  
				 var promise=$scope.getCheckTable(options);//$scope.getRedundancyInfo(options);
						  promise.success(function (data) {
				$scope.TableExist=data;
                $scope.error = '';
           })
          .error(function (data, status) {
              if (status === 404) {
                $scope.error = 'REST server is offline!';
              } else {
                $scope.error = 'Error: ' + status;
              }
          }).then(function(){
		  
		  console.log($scope.TableExist);
		  
				if($scope.TableExist.count[0].number==0){
					
					options = {url: AllRedsSupps,
							method: 'GET', 
							params: {
								}
                          };
						  
						   var promise1=$scope.getRedsSupps(options);
						    promise1.success(function (data) {
							$scope.RedsSupps=data;
							$scope.error = '';
						})
							.error(function (data, status) {
							if (status === 404) {
							$scope.error = 'REST server is offline!';
						} else {
								$scope.error = 'Error: ' + status;
							}
							}).then(function(){
							
						
							var redSupps=new HashMap();
							console.log($scope.RedsSupps);
							console.log('Q');
							console.log(Q);
						
						var promise3 = Q.all( [
						loadToStruct(redSupps,$scope)
							])
						
						Q.allSettled(promise3).then(function(results){
						results.forEach(function(result){
						
						if (result.state === "fulfilled") {
								var redSupps = result.value;
								
							var graph= new HashMap();
							console.log("then part!");
							console.log(redSupps);
							console.log(redSupps.count());

							var i=0;
							var j=i+1;
							var numReds = redSupps.count();
							var myVar=setInterval(function() {

									var perc= (i/numReds)*100;
									
							document.getElementById("graphProgG").innerHTML = "Graph computation: "+perc.toFixed(2)+"%";
								
								var set1 = redSupps.get(i);
								
								for(j=i+1;j<numReds;j++){
								var set2 = redSupps.get(j);
								
								var intersection=0;
								var set1val = set1.values();
								
								for(var z=0;z<set1val.length;z++)
									if(set2.contains(set1val[z]))
										intersection=intersection+1;
										
								var edge = intersection/(set1.size()+set2.size()-intersection);
								
								if(!graph.has(i)){
									var t=new Array(numReds);
									t[i]=1.0;
									graph.set(i,t);
								}
								
								if(!graph.has(j)){
									var t=new Array(numReds);
									t[j]=1.0;
									graph.set(j,t);
								}
								
								var t=graph.get(i);
								t[j]=edge;
								graph.set(i,t);
								
								t=graph.get(j);
								t[i]=edge;
								graph.set(j,t);
								}
								
			
								if(i==(numReds-1) && j==(numReds)){
										clearInterval(myVar);
										document.getElementById("graphProgG").innerHTML = "Graph computation: "+"100%";
										console.log(graph);
										
										var totalNumberP = parseInt(graph.count())*parseInt(graph.count());
										var numRedsinBucketP = Math.floor(2571800/parseInt(graph.count()));//2571800
										var numItersP = Math.ceil(totalNumberP/(numRedsinBucketP*parseInt(graph.count())));
										console.log('Num iters: '+numItersP);
								var promisesP=new Array();
								var retDataAll=new Array(graph.count());
								for(var parts=0;parts<numItersP;parts++){
									var startIndex = parts*numRedsinBucketP;
									var endIndex = startIndex + numRedsinBucketP;
									var size = numRedsinBucketP;
									
									if(endIndex>=graph.count()){
										var diff = endIndex - graph.count();
										size = size-diff;
									}
									
									console.log(endIndex);
									console.log(size);
									
									var retData=new Array(size/*graph.count()*/);
									
									var dat;
										
										for(var z=startIndex;z<startIndex+size/*numRedsinBucketP*//*graph.count()*/;z++)//2000
											retData[z-startIndex]=graph.get(z);
											retDataAll[z]=graph.get(z);;
											console.log("retData");
												console.log(retData);
											
											options = {url: saveGraphG,
												method: 'POST', 
												params: {
													},
											    data: { graph:  JSON.stringify(retData), start: startIndex		
											}
												};

												
												
										promisesP.push($scope.setGraphData(options));
									}
									
											var promise5 = Q.all(promisesP).then(function(){
														console.log("Create parameters and define scope variable here");//put watch on it in the scope.
														retData = retDataAll;
														
														var inputForAlgo={};
														
														for(var i=0;i<retData.length;i++){
																var eds1={};
															for(var j=0;j<retData[i].length;j++){
																if(i==j)
																	continue;
																if(typeof retData[i][j] == 'undefined')
																	 continue;//retData[i][j]=0.0;//continue;
																	
																	eds1[j]=1.0-retData[i][j];
															}
																inputForAlgo[i]=eds1;
														}
														
														console.log("Algorithm input: ");
														console.log(inputForAlgo);
														
														var threshold1=1-globalThreshold;//1-0.2;
														var forbiden1 = new HashSet();
														
														var present = new HashSet();
														
														for(var pr=0;pr<$scope.AllReds.redescriptions.length;pr++)
																present.add($scope.AllReds.redescriptions[pr].id);
																
														for(var pr=0;pr<retData.length;pr++)
																if(!present.contains(pr))
																	forbiden1.add(pr+"");
														
														var pathsFinal = new PriorityQueue();
														var pathsCandidates = new PriorityQueue();
 														 var graph = new Graph(inputForAlgo,threshold1,forbiden1);
														 var inputArr = new Array();
														 
														 for(var t=0;t<$scope.checkedOrderGL.cog.length;t++)
																inputArr[t]=$scope.checkedOrderGL.cog[t]+"";
														 
														 var sp=graph.findShortestPath(inputArr);
														console.log('SP: ');
														console.log(sp);
														console.log('checked order: ');
														console.log($scope.checkedOrderGL.cog);
														console.log('Forbiden nodes.');
														console.log(forbiden1.values());
													
													if(sp!=null){			
																var cost=0;
														for(var i=0;i<sp.length-1;i++){
																	cost = cost + graph.findEdge(sp[i],sp[i+1]);
															}
														
														sp.forbidenEdges=new Array();														
												
														sp.cost=cost;
														pathsFinal.push(cost,sp);
														pathsCandidates.push(cost,sp);
													}
														
														while(pathsFinal.length()<globalNumPaths){//10
																if(pathsCandidates.length()==0)
																		break;
															var tmpPath = pathsCandidates.pop();
															var startNodes = new Array();
															var endNodes = new Array();
															
															for(var i=0;i<tmpPath.forbidenEdges.length;i++){
																startNodes.push(tmpPath.forbidenEdges[i].s);
																endNodes.push(tmpPath.forbidenEdges[i].e);
															}
															
															for(var i=0;i<tmpPath.length-1;i++){
																	startNodes.push(tmpPath[i]);
																	endNodes.push(tmpPath[i+1]);
																	graph.setEdges(startNodes,endNodes);
																	
																	inputArr = new Array();
														 
														 for(var t=0;t<$scope.checkedOrderGL.cog.length;t++)
																inputArr[t]=$scope.checkedOrderGL.cog[t]+"";
																
																	var sp1=graph.findShortestPath(inputArr,forbiden1);
								
																	if(sp1!=null){
																	
																	sp1.forbidenEdges=new Array();
																	for(var j=0;j<startNodes.length;j++){
																		var ed={}; ed.s=startNodes[j]; ed.e=endNodes[j];
																		sp1.forbidenEdges.push(ed);
																	}
																		
																		cost=0;
																		for(var i=0;i<sp1.length-1;i++){
																			cost = cost + graph.findEdge(sp1[i],sp1[i+1]);
																	}
																	
																	sp1.cost=cost;
																	if(!pathsCandidates.contains(sp1))
																		pathsCandidates.push(cost,sp1);
																	}
																	
																	graph.restoreEdges(startNodes,endNodes);
																	startNodes.splice(startNodes.length-1,1);
																	endNodes.splice(endNodes.length-1,1);
															}
															
															if(pathsCandidates.length()==0)
																break;
															
															var spT=pathsCandidates.pop();
															if(!pathsFinal.contains(spT)){
																	pathsFinal.push(spT.cost,spT);//check if this path exists.
																	pathsCandidates.push(spT.cost,spT);
															}
															else{
																	while(pathsFinal.contains(spT)){
																		spT=pathsCandidates.pop();
																	}
																	if(spT!=null){
																	pathsFinal.push(spT.cost,spT);
																	pathsCandidates.push(spT.cost,spT);
																	}
															}
														}
														
														var drawGraph={};
														drawGraph.nodes = new Array();
														drawGraph.links = new Array();
														var usedNodes = new HashSet();
														console.log('Paths: ');
														var rank=1;
														
														drawGraph.startNode = $scope.checkedOrderGL.cog[0]+"";
														usedNodes.add($scope.checkedOrderGL.cog[0]+"");
														drawGraph.endNode = $scope.checkedOrderGL.cog[$scope.checkedOrderGL.cog.length-1]+"";
														usedNodes.add($scope.checkedOrderGL.cog[$scope.checkedOrderGL.cog.length-1]+"");
														drawGraph.intermediary = new HashSet();
														for(var k=1;k<$scope.checkedOrderGL.cog.length-1;k++){
															drawGraph.intermediary.add($scope.checkedOrderGL.cog[k]+"");
															usedNodes.add($scope.checkedOrderGL.cog[k]+"");
															}
														
														while(pathsFinal.length()>0){
															var sp = pathsFinal.pop();
															console.log(rank+'. '+sp);
															console.log(sp);
															console.log(sp.length);
															for(var i=0;i<sp.length-1;i++){
																 var contained=0;
																 usedNodes.add(sp[i]);
																 for(var j=0;j<drawGraph.links.length;j++){
																	if(drawGraph.links[j].source==sp[i] && drawGraph.links[j].target==sp[i+1]){
																		contained=1;
																		break;
																	}
																}
																	
																	if(contained==0){
																		var ed={};
																		ed.source=sp[i]; ed.target=sp[i+1]; ed.group=rank; ed.value=graph.findEdge(sp[i],sp[i+1]);
																		drawGraph.nGr=rank;
																		drawGraph.links.push(ed);
																	}			
															}
															usedNodes.add(sp[sp.length-1]);
															//drawGraph.endNode=sp[sp.length-1];
															rank=rank+1;
														}
														
														//create edges between all present nodes not on a path as default edges, code -1, grey color
														
														var unAr=usedNodes.values();
														
														for(var un1=0;un1<unAr.length-1;un1++){
															for(var un2=un1+1;un2<unAr.length;un2++){
															 var contained=0;
																 for(var j=0;j<drawGraph.links.length;j++){
																	if((drawGraph.links[j].source==unAr[un1] && drawGraph.links[j].target==unAr[un2]) || (drawGraph.links[j].source==unAr[un2] && drawGraph.links[j].target==unAr[un1])){
																		contained=1;
																		break;
																	}
																}
																if(contained==0 && graph.findEdge(unAr[un1],unAr[un2])<=threshold1){
																var ed={};
																		ed.source=unAr[un1]; ed.target=unAr[un2]; ed.group=-1; ed.value=graph.findEdge(unAr[un1],unAr[un2]);
																		drawGraph.links.push(ed);
																}
															}
														}
														
														var selReds=new Array();//redescriptions that need to be displayed
														
														for(var i=0;i<$scope.riGG.selectionReds.redescriptions.length;i++){
																if(usedNodes.contains($scope.riGG.selectionReds.redescriptions[i].id+""))
																		selReds.push($scope.riGG.selectionReds.redescriptions[i]);
														}
														
														var una = usedNodes.values();
														
														var mapping = new HashMap();
														
														var ind=0;
														for(var i=0;i<una.length;i++){
															mapping.set(una[i],ind);
															ind=ind+1;
															}
															
														for(var i=0;i<drawGraph.links.length;i++){
																drawGraph.links[i].source=mapping.get(drawGraph.links[i].source);
																drawGraph.links[i].target=mapping.get(drawGraph.links[i].target);
															}
														
														for(var i=0;i<una.length;i++){
															var n={};
															n.id=una[i];
															
															for(var j=0;j<selReds.length;j++)
																if(selReds[j].id+""==una[i]){
																	n.lq=selReds[j].col1;
																	n.rq=selReds[j].col2;
																	n.js=selReds[j].col3;
																	n.supp=selReds[j].col4;
																	n.pVal=selReds[j].col5;
																} //uncomment when dealing with original data

															drawGraph.nodes.push(n);
														}
														
														console.log('scope');
														console.log($scope);
														//redIds.values();
													
														$scope.RedRelationGraph=drawGraph;	//save graphINput to scope.graphInput variable	
														$scope.checkedOrderGL.cog=[];
														$scope.graphInput = inputForAlgo;
														
														$('#git-list').each(function (i, row) {

															var $row = $(row),
														$checkedBoxes = $row.find('input:checked');

														$checkedBoxes.each(function (i, checkbox) {

														var $checkbox = $(checkbox);
														$checkbox.attr('checked', false); 
														});
													});
	
											})
										
										
										return;
											}
											
											i=i+1;
							}, 5);	
							}
							})
						})							
									//compute the graph, save the graph and compute the input for the algorithm, run the algorithm and draw the result.
							})
							
							}
				else{
				
				var getInParts = function(startIndex, endIndex, numReds, $scope){
				if(typeof($scope.rawGraph)=='undefined')
						$scope.rawGraph = [];
					return Q.spread([startIndex, endIndex, $scope], function(startIndex, endIndex,$scope){
							var options = {url: saveGraph,
												method: 'GET', 
												params: {
													start: JSON.stringify(startIndex),
													end: JSON.stringify(endIndex),
													nr: JSON.stringify(numReds)
													}
												};
												
									var tmpPromise = $scope.getGraphData(options);	
									
									return tmpPromise;
									
									var tmpRes;
									
									tmpPromise.success(function (data) {
											tmpRes=data;
											console.log('data');
											console.log(tmpRes);
												$scope.error = '';
										})
										.error(function (data, status) {
										if (status === 404) {
											$scope.error = 'REST server is offline!';
										} else {
												$scope.error = 'Error: ' + status;
											}
											}).then(function(){
											
											console.log('got a part of data');
											console.log(tmpRes);
											var tmp=new Array();
											
											
											
											return tmp;
											//convert to HashMap arrayList
											
											});
												
					})
				};
				
				var optionsNR = {url: numredsLink,
								 method: 'GET',
								 params: {}
								 };
								 
				var promiseNR = $scope.generalGETRequest(optionsNR);
				
				
				promiseNR.success(function (data) {
											$scope.numReds = data;
												$scope.error = '';
										})
										.error(function (data, status) {
										if (status === 404) {
											$scope.error = 'REST server is offline!';
										} else {
												$scope.error = 'Error: ' + status;
											}
											}).then(function(){
											
											console.log('num reds:');
											console.log($scope.numReds); 
											console.log($scope.numReds.numReds[0].numReds);
											
											var numReds = $scope.numReds.numReds[0].numReds;
											//convert to HashMap arrayList
											
											var totalNumber = numReds*numReds;
											var numRedsinBucket = Math.floor(2571800/numReds);
											console.log('numRedsInBucket: '+numRedsinBucket);
											var numIters = Math.ceil(totalNumber/(numRedsinBucket*parseInt(numReds)));
											console.log('numIters: '+numIters);

									var promises=new Array();
									
									for(var parts=0;parts<numIters;parts++){
									var startIndex = parts*numRedsinBucket;
									var endIndex = (parts+1)*numRedsinBucket;
									if(endIndex>numReds)
										endIndex=numReds;
										promises.push(getInParts(startIndex,endIndex,numReds,$scope));
									}
									
									var joinedPromise = Q.all(promises).then(function(values){
									
									console.log('All data received!');
									console.log('values');
									console.log(values);
									
									
									var input = [];
									
									console.log('computing input: ');
									console.log('values length: '+values.length);
									console.log('graph length: '+values[0].data.GraphData.length);
									
									for(var iv=0;iv<values.length;iv++){
											for(var iv1=0;iv1<values[iv].data.GraphData.length;iv1++)
												input.push(values[iv].data.GraphData[iv1]);
												console.log(input.length);
									}
									
										console.log('joined input: ');
										console.log(input);
										
										values=[];
	
										console.log("Create parameters and define scope variable here");//put watch on it in the scope.
														
														var inputForAlgo={};
														
														for(var i=0;i<input.length;i++){
																var eds1={};
															for(var j=0;j<input[i].length;j++){
																if(i==j)
																	continue;
																if(typeof input[i][j] == 'undefined')
																	 continue;//retData[i][j]=0.0;//continue;
																	
																	eds1[j]=1.0-input[i][j];
															}
																inputForAlgo[i]=eds1;
														}
														
														console.log("Algorithm input: ");
														console.log(inputForAlgo);
														
														var threshold1=1-globalThreshold;//1-0.2;
														var forbiden1 = new HashSet();
														
														var present = new HashSet();
														
														console.log('scope');
														console.log($scope.riGG.selectionReds.redescriptions);
														
														for(var pr=0;pr<$scope.riGG.selectionReds.redescriptions.length;pr++)
																present.add($scope.riGG.selectionReds.redescriptions[pr].id);
																
														for(var pr=0;pr<input.length;pr++)
																if(!present.contains(pr))
																	forbiden1.add(pr+"");
														
														var pathsFinal = new PriorityQueue();
														var pathsCandidates = new PriorityQueue();
 														 var graph = new Graph(inputForAlgo,threshold1,forbiden1);
														 var inputArr = new Array();
														 
														 for(var t=0;t<$scope.checkedOrderGL.cog.length;t++)
																inputArr[t]=$scope.checkedOrderGL.cog[t]+"";
														 
														 var sp=graph.findShortestPath(inputArr);
														console.log('SP: ');
														console.log(sp);
														console.log('checked order: ');
														console.log($scope.checkedOrderGL.cog);
														console.log('Forbiden nodes.');
														console.log(forbiden1.values());
													
													if(sp!=null){			
																var cost=0;
														for(var i=0;i<sp.length-1;i++){
																	cost = cost + graph.findEdge(sp[i],sp[i+1]);
															}
														
														sp.forbidenEdges=new Array();														
												
														sp.cost=cost;
														pathsFinal.push(cost,sp);
														pathsCandidates.push(cost,sp);
													}
														
														while(pathsFinal.length()<globalNumPaths){//10
																if(pathsCandidates.length()==0)
																		break;
															var tmpPath = pathsCandidates.pop();
															var startNodes = new Array();
															var endNodes = new Array();
															
															for(var i=0;i<tmpPath.forbidenEdges.length;i++){
																startNodes.push(tmpPath.forbidenEdges[i].s);
																endNodes.push(tmpPath.forbidenEdges[i].e);
															}
															
															for(var i=0;i<tmpPath.length-1;i++){
																	startNodes.push(tmpPath[i]);
																	endNodes.push(tmpPath[i+1]);
																	graph.setEdges(startNodes,endNodes);
																	
																	inputArr = new Array();
														 
														 for(var t=0;t<$scope.checkedOrderGL.cog.length;t++)
																inputArr[t]=$scope.checkedOrderGL.cog[t]+"";
																
																	var sp1=graph.findShortestPath(inputArr,forbiden1);
								
																	if(sp1!=null){
																	
																	sp1.forbidenEdges=new Array();
																	for(var j=0;j<startNodes.length;j++){
																		var ed={}; ed.s=startNodes[j]; ed.e=endNodes[j];
																		sp1.forbidenEdges.push(ed);
																	}
																		
																		cost=0;
																		for(var i=0;i<sp1.length-1;i++){
																			cost = cost + graph.findEdge(sp1[i],sp1[i+1]);
																	}
																	
																	sp1.cost=cost;
																	if(!pathsCandidates.contains(sp1))
																		pathsCandidates.push(cost,sp1);
																	}
																	
																	graph.restoreEdges(startNodes,endNodes);
																	startNodes.splice(startNodes.length-1,1);
																	endNodes.splice(endNodes.length-1,1);
															}
															
															if(pathsCandidates.length()==0)
																break;
															
															var spT=pathsCandidates.pop();
															if(!pathsFinal.contains(spT)){
																	pathsFinal.push(spT.cost,spT);//check if this path exists.
																	pathsCandidates.push(spT.cost,spT);
															}
															else{
																	while(pathsFinal.contains(spT)){
																		spT=pathsCandidates.pop();
																	}
																	if(spT!=null){
																	pathsFinal.push(spT.cost,spT);
																	pathsCandidates.push(spT.cost,spT);
																	}
															}
															
															//console.log('tmp path1: ');
															//console.log(spT);
														}
														
														var drawGraph={};
														drawGraph.nodes = new Array();
														drawGraph.links = new Array();
														var usedNodes = new HashSet();
														console.log('Paths: ');
														var rank=1;
														
														drawGraph.startNode = $scope.checkedOrderGL.cog[0]+"";
														usedNodes.add($scope.checkedOrderGL.cog[0]+"");
														drawGraph.endNode = $scope.checkedOrderGL.cog[$scope.checkedOrderGL.cog.length-1]+"";
														usedNodes.add($scope.checkedOrderGL.cog[$scope.checkedOrderGL.cog.length-1]+"");
														drawGraph.intermediary = new HashSet();
														for(var k=1;k<$scope.checkedOrderGL.cog.length-1;k++){
															drawGraph.intermediary.add($scope.checkedOrderGL.cog[k]+"");
															usedNodes.add($scope.checkedOrderGL.cog[k]+"");
															}
														
														while(pathsFinal.length()>0){
															var sp = pathsFinal.pop();
															console.log(rank+'. '+sp);
															console.log(sp);
															console.log(sp.length);
															for(var i=0;i<sp.length-1;i++){
															//if(i==0)
															//drawGraph.startNode=sp[i];
																 var contained=0;
																 usedNodes.add(sp[i]);
																 for(var j=0;j<drawGraph.links.length;j++){
																	if(drawGraph.links[j].source==sp[i] && drawGraph.links[j].target==sp[i+1]){
																		contained=1;
																		break;
																	}
																}
																	
																	if(contained==0){
																		var ed={};
																		ed.source=sp[i]; ed.target=sp[i+1]; ed.group=rank; ed.value=graph.findEdge(sp[i],sp[i+1]);
																		drawGraph.nGr=rank;
																		//console.log('ed');
																		//console.log(ed);
																		drawGraph.links.push(ed);
																	}			
															}
															usedNodes.add(sp[sp.length-1]);
															//drawGraph.endNode=sp[sp.length-1];
															rank=rank+1;
														}
														
														//create edges between all present nodes not on a path as default edges, code -1, grey color
														
														var unAr=usedNodes.values();
														console.log(unAr);
														
														for(var un1=0;un1<unAr.length-1;un1++){
															for(var un2=un1+1;un2<unAr.length;un2++){
															 var contained=0;
																 for(var j=0;j<drawGraph.links.length;j++){
																	if((drawGraph.links[j].source==unAr[un1] && drawGraph.links[j].target==unAr[un2]) || (drawGraph.links[j].source==unAr[un2] && drawGraph.links[j].target==unAr[un1])){
																		contained=1;
																		break;
																	}
																}
																if(contained==0 && graph.findEdge(unAr[un1],unAr[un2])<=threshold1){
																var ed={};
																		ed.source=unAr[un1]; ed.target=unAr[un2]; ed.group=-1; ed.value=graph.findEdge(unAr[un1],unAr[un2]);
																		drawGraph.links.push(ed);
																}
															}
														}
														
														console.log(drawGraph);
														
														var selReds=new Array();//redescriptions that need to be displayed
														
														for(var i=0;i<$scope.riGG.selectionReds.redescriptions.length;i++){
																if(usedNodes.contains($scope.riGG.selectionReds.redescriptions[i].id+""))
																		selReds.push($scope.riGG.selectionReds.redescriptions[i]);
														}
														
														console.log('selReds');
														console.log(selReds);
														
														var una = usedNodes.values();
														console.log(una);
														
														var mapping = new HashMap();
														
														var ind=0;
														for(var i=0;i<una.length;i++){
															mapping.set(una[i],ind);
															ind=ind+1;
															}
															
														for(var i=0;i<drawGraph.links.length;i++){
																drawGraph.links[i].source=mapping.get(drawGraph.links[i].source);
																drawGraph.links[i].target=mapping.get(drawGraph.links[i].target);
															}
															
															console.log(drawGraph);
														
														for(var i=0;i<una.length;i++){
															var n={};
															n.id=una[i];
															
															for(var j=0;j<selReds.length;j++)
																if(selReds[j].id+""==una[i]){
																	n.lq=selReds[j].col1;
																	n.rq=selReds[j].col2;
																	n.js=selReds[j].col3;
																	n.supp=selReds[j].col4;
																	n.pVal=selReds[j].col5;
																} //uncomment when dealing with original data
															console.log('n');
															console.log(n);
															drawGraph.nodes.push(n);
														}
														
														console.log('scope');
														console.log($scope);
														//redIds.values();
													
														$scope.RedRelationGraph=drawGraph;	//save graphINput to scope.graphInput variable	
														$scope.checkedOrderGL.cog=[];
														$scope.graphInput = inputForAlgo;
														
														$('#git-list').each(function (i, row) { //make it work

															var $row = $(row),
														$checkedBoxes = $row.find('input:checked');

														console.log($row);
														
														$checkedBoxes.each(function (i, checkbox) {

														var $checkbox = $(checkbox);
														$checkbox.attr('checked', false); 
														});
													});
									});
										
							});
				
						//load the graph and compute the input for the algorithm, run the algorithm and draw the result.
					
				}
		  
				});
			}
			else{
			
													console.log("Algorithm input: ");
														console.log($scope.graphInput);
													 var inputForAlgo = $scope.graphInput;
														
														var threshold1=1-globalThreshold;//1-0.2;
														var forbiden1 = new HashSet();
														
														var present = new HashSet();
														
														for(var pr=0;pr<$scope.riGG.selectionReds.redescriptions.length;pr++)
																present.add($scope.riGG.selectionReds.redescriptions[pr].id);
																
														for(var pr=0;pr<$scope.numReds.numReds[0].numReds;pr++)
																if(!present.contains(pr))
																	forbiden1.add(pr+"");
														
														var pathsFinal = new PriorityQueue();
														var pathsCandidates = new PriorityQueue();
 														 var graph = new Graph(inputForAlgo,threshold1,forbiden1);
														 var inputArr = new Array();
														 
														 for(var t=0;t<$scope.checkedOrderGL.cog.length;t++)
																inputArr[t]=$scope.checkedOrderGL.cog[t]+"";
														 
														 var sp=graph.findShortestPath(inputArr);
														console.log('SP: ');
														console.log(sp);
														console.log('checked order: ');
														console.log($scope.checkedOrderGL.cog);
														console.log('Forbiden nodes.');
														console.log(forbiden1.values());
													
													if(sp!=null){			
																var cost=0;
														for(var i=0;i<sp.length-1;i++){
																	cost = cost + graph.findEdge(sp[i],sp[i+1]);
															}
														
														sp.forbidenEdges=new Array();														
												
														sp.cost=cost;
														pathsFinal.push(cost,sp);
														pathsCandidates.push(cost,sp);
													}
														
														while(pathsFinal.length()<globalNumPaths){//10
																if(pathsCandidates.length()==0)
																		break;
															var tmpPath = pathsCandidates.pop();
															var startNodes = new Array();
															var endNodes = new Array();
															
															for(var i=0;i<tmpPath.forbidenEdges.length;i++){
																startNodes.push(tmpPath.forbidenEdges[i].s);
																endNodes.push(tmpPath.forbidenEdges[i].e);
															}
															
															for(var i=0;i<tmpPath.length-1;i++){
																	startNodes.push(tmpPath[i]);
																	endNodes.push(tmpPath[i+1]);
																	graph.setEdges(startNodes,endNodes);
																	
																	inputArr = new Array();
														 
														 for(var t=0;t<$scope.checkedOrderGL.cog.length;t++)
																inputArr[t]=$scope.checkedOrderGL.cog[t]+"";
																
																	var sp1=graph.findShortestPath(inputArr,forbiden1);
								
																	if(sp1!=null){
																	
																	sp1.forbidenEdges=new Array();
																	for(var j=0;j<startNodes.length;j++){
																		var ed={}; ed.s=startNodes[j]; ed.e=endNodes[j];
																		sp1.forbidenEdges.push(ed);
																	}
																		
																		cost=0;
																		for(var i=0;i<sp1.length-1;i++){
																			cost = cost + graph.findEdge(sp1[i],sp1[i+1]);
																	}
																	
																	sp1.cost=cost;
																	if(!pathsCandidates.contains(sp1))
																		pathsCandidates.push(cost,sp1);
																	}
																	
																	graph.restoreEdges(startNodes,endNodes);
																	startNodes.splice(startNodes.length-1,1);
																	endNodes.splice(endNodes.length-1,1);
															}
															
															if(pathsCandidates.length()==0)
																break;
															
															var spT=pathsCandidates.pop();
															if(!pathsFinal.contains(spT)){
																	pathsFinal.push(spT.cost,spT);//check if this path exists.
																	pathsCandidates.push(spT.cost,spT);
															}
															else{
																	while(pathsFinal.contains(spT)){
																		spT=pathsCandidates.pop();
																	}
																	if(spT!=null){
																	pathsFinal.push(spT.cost,spT);
																	pathsCandidates.push(spT.cost,spT);
																	}
															}
															
															//console.log('tmp path1: ');
															//console.log(spT);
														}
														
														var drawGraph={};
														drawGraph.nodes = new Array();
														drawGraph.links = new Array();
														var usedNodes = new HashSet();
														console.log('Paths: ');
														var rank=1;
														
														drawGraph.startNode = $scope.checkedOrderGL.cog[0]+"";
														usedNodes.add($scope.checkedOrderGL.cog[0]+"");
														drawGraph.endNode = $scope.checkedOrderGL.cog[$scope.checkedOrderGL.cog.length-1]+"";
														usedNodes.add($scope.checkedOrderGL.cog[$scope.checkedOrderGL.cog.length-1]+"");
														drawGraph.intermediary = new HashSet();
														for(var k=1;k<$scope.checkedOrderGL.cog.length-1;k++){
															drawGraph.intermediary.add($scope.checkedOrderGL.cog[k]+"");
															usedNodes.add($scope.checkedOrderGL.cog[k]+"");
															}
														
														while(pathsFinal.length()>0){
															var sp = pathsFinal.pop();
															console.log(rank+'. '+sp);
															console.log(sp);
															console.log(sp.length);
															for(var i=0;i<sp.length-1;i++){
															//if(i==0)
															//drawGraph.startNode=sp[i];
																 var contained=0;
																 usedNodes.add(sp[i]);
																 for(var j=0;j<drawGraph.links.length;j++){
																	if(drawGraph.links[j].source==sp[i] && drawGraph.links[j].target==sp[i+1]){
																		contained=1;
																		break;
																	}
																}
																	
																	if(contained==0){
																		var ed={};
																		ed.source=sp[i]; ed.target=sp[i+1]; ed.group=rank; ed.value=graph.findEdge(sp[i],sp[i+1]);
																		drawGraph.nGr=rank;
																		//console.log('ed');
																		//console.log(ed);
																		drawGraph.links.push(ed);
																	}			
															}
															usedNodes.add(sp[sp.length-1]);
															//drawGraph.endNode=sp[sp.length-1];
															rank=rank+1;
														}
														
														//create edges between all present nodes not on a path as default edges, code -1, grey color
														
														var unAr=usedNodes.values();
														
														for(var un1=0;un1<unAr.length-1;un1++){
															for(var un2=un1+1;un2<unAr.length;un2++){
															 var contained=0;
																 for(var j=0;j<drawGraph.links.length;j++){
																	if((drawGraph.links[j].source==unAr[un1] && drawGraph.links[j].target==unAr[un2]) || (drawGraph.links[j].source==unAr[un2] && drawGraph.links[j].target==unAr[un1])){
																		contained=1;
																		break;
																	}
																}
																if(contained==0 && graph.findEdge(unAr[un1],unAr[un2])<=threshold1){
																var ed={};
																		ed.source=unAr[un1]; ed.target=unAr[un2]; ed.group=-1; ed.value=graph.findEdge(unAr[un1],unAr[un2]);
																		drawGraph.links.push(ed);
																}
															}
														}
														
														var selReds=new Array();//redescriptions that need to be displayed
														
														for(var i=0;i<$scope.riGG.selectionReds.redescriptions.length;i++){
																if(usedNodes.contains($scope.riGG.selectionReds.redescriptions[i].id+""))
																		selReds.push($scope.riGG.selectionReds.redescriptions[i]);
														}
														
														var una = usedNodes.values();
														
														var mapping = new HashMap();
														
														var ind=0;
														for(var i=0;i<una.length;i++){
															mapping.set(una[i],ind);
															ind=ind+1;
															}
															
														for(var i=0;i<drawGraph.links.length;i++){
																drawGraph.links[i].source=mapping.get(drawGraph.links[i].source);
																drawGraph.links[i].target=mapping.get(drawGraph.links[i].target);
															}
														
														for(var i=0;i<una.length;i++){
															var n={};
															n.id=una[i];
															
															for(var j=0;j<selReds.length;j++)
																if(selReds[j].id+""==una[i]){
																	n.lq=selReds[j].col1;
																	n.rq=selReds[j].col2;
																	n.js=selReds[j].col3;
																	n.supp=selReds[j].col4;
																	n.pVal=selReds[j].col5;
																} //uncomment when dealing with original data

															drawGraph.nodes.push(n);
														}
														
														console.log('scope');
														console.log($scope);
														//redIds.values();
													
														$scope.RedRelationGraph=drawGraph;	//save graphINput to scope.graphInput variable	
														$scope.checkedOrderGL.cog=[];
														$scope.graphInput = inputForAlgo;
														
														$('#git-list').each(function (i, row) {

															var $row = $(row),
														$checkedBoxes = $row.find('input:checked');

														$checkedBoxes.each(function (i, checkbox) {
														console.log($row);
														var $checkbox = $(checkbox);
														$checkbox.attr('checked', false); 
														});
													});
			
			$scope.$apply();

			}
		}
}



function JSON2CSV(objArray) {
    var array = typeof objArray != 'object' ? JSON.parse(objArray) : objArray;

    var str = '';
    var line = '';

    if ($("#labels").is(':checked')) {
        var head = array[0];
        if ($("#quote").is(':checked')) {
            for (var index in array[0]) {
                var value = index + "";
                line += '"' + value.replace(/"/g, '""') + '",';
            }
        } else {
            for (var index in array[0]) {
                line += index + ',';
            }
        }

        line = line.slice(0, -1);
        str += line + '\r\n';
    }

    for (var i = 0; i < array.length; i++) {
        var line = '';

        if ($("#quote").is(':checked')) {
            for (var index in array[i]) {
                var value = array[i][index] + "";
                line += '"' + value.replace(/"/g, '""') + '",';
            }
        } else {
            for (var index in array[i]) {
                line += array[i][index] + ',';
            }
        }

        line = line.slice(0, -1);
        str += line + '\r\n';
    }
    return str;
    
}

var globalVarG;

function exportFunctionG(){
	   var redJson=JSON.stringify(globalVarG);

		var csv = JSON2CSV(redJson);
	   
	   var blob = new Blob([csv], {type: "text/plain;charset=utf-8"});
		saveAs(blob, "redescriptions.csv");
	   
   };
   
var globalVarG1;

 function exportFunctionSuppG(){
 //console.log("globalVarG1");
 //console.log(globalVarG1);
	   var redJson=JSON.stringify(globalVarG1);

		var csv = JSON2CSV(redJson);
	   
	   var blob = new Blob([csv], {type: "text/plain;charset=utf-8"});
		saveAs(blob, "redescriptionSupport.csv");
	   
   };      
   
  var GlScope;
  var GlRedescriptions;
var databaseConfig="http://localhost:8081/redundancyAll";
var databaseConfig1="http://localhost:8081/redundancyinfo1";
//var Q = require('q');
	
var AllRedsAttrs="http://localhost:8081/redundancyAttrs";
var loadGraph="http://localhost:8081/graphDataAttr";
var saveGraphAttr="http://localhost:8081/graphDataAttr";
var saveGraphAttrG="http://localhost:8081/graphDataAttrG";
	
	function filteringG(pload,$scope, elOv, atOv){
     
	
	console.log('filtering');
	console.log($scope.AllReds.redescriptions);
	
	var toDelete = new HashSet();
					
					//sort reds
					$scope.AllReds.redescriptions.sort(function(a, b){
					
					if(a.col3==b.col3){
						
						if(a.col5==b.col5){
							
							if(a.col4==b.col4){
									
									if(a.col5==b.col5){
										return a.col6-b.col6;
									}
									else{
										return a.col5-b.col5;
									}
									
							}
							else{
								return b.col4-a.col4;
							}
						
						}
						else{
							return a.col5-b.col5;
						}
						
					}
					else{
						return b.col3-a.col3;
					}
					
					});
	
	console.log('filtering');
	console.log($scope.AllReds.redescriptions);
	
	for(i=0;i<$scope.AllReds.redescriptions.length-1;i++)
							for(j=i+1;j<$scope.AllReds.redescriptions.length;j++){
								
								if(toDelete.contains($scope.AllReds.redescriptions[j].id))
											continue;
								
								var perc=(i*$scope.AllReds.redescriptions.length+j)/($scope.AllReds.redescriptions.length*$scope.AllReds.redescriptions.length)*100;
							
								
												var jsEl= 1.0-$scope.graphInput[$scope.AllReds.redescriptions[i].id+""][$scope.AllReds.redescriptions[j].id+""];
												//console.log("jsEl: "+jsEl);
												if(jsEl*100>=elOv){
												if($scope.AllReds.redescriptions[i].col3>$scope.AllReds.redescriptions[j].col3){
													toDelete.add($scope.AllReds.redescriptions[j].id);
													     }
												else
													toDelete.add($scope.AllReds.redescriptions[i].id);
													//break;
													}	

												var jsAt= 1.0-$scope.graphInputAttrs[$scope.AllReds.redescriptions[i].id+""][$scope.AllReds.redescriptions[j].id+""];
												//console.log("jsAt: "+jsAt);
												if(jsAt*100>=atOv){
												if($scope.AllReds.redescriptions[i].col3>$scope.AllReds.redescriptions[j].col3){
													toDelete.add($scope.AllReds.redescriptions[j].id);
													     }
												else
													toDelete.add($scope.AllReds.redescriptions[i].id);
													//break;
													}
													
							}
							
						//while(toDelete.size()>0){
							for(i=0;i<$scope.AllReds.redescriptions.length;i++){
								if(toDelete.contains($scope.AllReds.redescriptions[i].id)){
									toDelete.remove($scope.AllReds.redescriptions[i].id);
									$scope.AllReds.redescriptions.splice(i,1);
									i--;
								}
									
						//	}		
						}
						
						console.log($scope.AllReds.redescriptions);
	
			//pload.style.visibility="hidden";
	}

	var getInPartsAttr = function(startIndex, endIndex, numReds, $scope){
				if(typeof($scope.graphInputAttrs)=='undefined')
						$scope.graphInputAttrs = [];
					return Q.spread([startIndex, endIndex, $scope], function(startIndex, endIndex,$scope){
							var options = {url: saveGraphAttr,
												method: 'GET', 
												params: {
													start: JSON.stringify(startIndex),
													end: JSON.stringify(endIndex),
													nr: JSON.stringify(numReds)
													}
												};
												
									var tmpPromise = $scope.getGraphData(options);	
									
									return tmpPromise;
									
									var tmpRes;
									
									tmpPromise.success(function (data) {
											tmpRes=data;
											console.log('data');
											console.log(tmpRes);
												$scope.error = '';
										})
										.error(function (data, status) {
										if (status === 404) {
											$scope.error = 'REST server is offline!';
										} else {
												$scope.error = 'Error: ' + status;
											}
											}).then(function(){
											
											console.log('got a part of data');
											console.log(tmpRes);
											var tmp=new Array();
											
											
											
											return tmp;
											//convert to HashMap arrayList
											
											});
												
					})
				};
	
  function filterRedsNewG(){

  var checkTable="http://localhost:8081/checkTable";
  var checkTableAttrs="http://localhost:8081/checkTableAttrs";
  var numredsLink="http://localhost:8081/numReds";
  var AllRedsSupps="http://localhost:8081/redundancySupp";
  var loadGraph="http://localhost:8081/graphData";
  var saveGraph="http://localhost:8081/graphData";
  var saveGraphG="http://localhost:8081/graphDataG";
  //var numredsLink="http://localhost:8081/numReds";
  
   var pload=document.getElementById("loader");
  //pload.style.visibility="visible";
  var appElement = document.querySelector('[ng-app=redApp]');
   var $scope = angular.element(appElement).scope();
   
    var elOv=$("#eoverIn").val(); var atOv=$("#atoverIn").val();
	
		console.log('FRN called!');
		console.log($scope.RedsInSomClust);
		
		$scope.AllReds = $scope.riAG.AllReds; 
		console.log("AllReds");
		console.log($scope.AllReds);

			if(typeof $scope.graphInput=='undefined'){
		
		var options = {url: checkTable,
               method: 'GET', 
               params: {
                        }
                          };
						  
				 var promise=$scope.getCheckTable(options);//$scope.getRedundancyInfo(options);
						  promise.success(function (data) {
				$scope.TableExist=data;
                $scope.error = '';
           })
          .error(function (data, status) {
              if (status === 404) {
                $scope.error = 'REST server is offline!';
              } else {
                $scope.error = 'Error: ' + status;
              }
          }).then(function(){
		  
		  console.log($scope.TableExist);
		  
				if($scope.TableExist.count[0].number==0){
					
					options = {url: AllRedsSupps,
							method: 'GET', 
							params: {
								}
                          };
						  
						   var promise1=$scope.getRedsSupps(options);
						    promise1.success(function (data) {
							$scope.RedsSupps=data;
							$scope.error = '';
						})
							.error(function (data, status) {
							if (status === 404) {
							$scope.error = 'REST server is offline!';
						} else {
								$scope.error = 'Error: ' + status;
							}
							}).then(function(){
							
						
							var redSupps=new HashMap();
							console.log($scope.RedsSupps);
							console.log('Q');
							console.log(Q);
						
						
						var promise3 = Q.all( [
						loadToStruct(redSupps,$scope)
							])
						
						Q.allSettled(promise3).then(function(results){
						results.forEach(function(result){
						
						if (result.state === "fulfilled") {
								var redSupps = result.value;
								
							var graph= new HashMap();
							console.log("then part!");
							console.log(redSupps);
							console.log(redSupps.count());

							var i=0;
							var j=i+1;
							var numReds = redSupps.count();
							var myVar=setInterval(function() {

									var perc= (i/numReds)*100;
									
							document.getElementById("graphProgG").innerHTML = "Graph computation: "+perc.toFixed(2)+"%";
								
								var set1 = redSupps.get(i);
								
								for(j=i+1;j<numReds;j++){
								var set2 = redSupps.get(j);
								
								var intersection=0;
								var set1val = set1.values();
								
								for(var z=0;z<set1val.length;z++)
									if(set2.contains(set1val[z]))
										intersection=intersection+1;
										
								var edge = intersection/(set1.size()+set2.size()-intersection);
								
								if(!graph.has(i)){
									var t=new Array(numReds);
									t[i]=1.0;
									graph.set(i,t);
								}
								
								if(!graph.has(j)){
									var t=new Array(numReds);
									t[j]=1.0;
									graph.set(j,t);
								}
								
								var t=graph.get(i);
								t[j]=edge;
								graph.set(i,t);
								
								t=graph.get(j);
								t[i]=edge;
								graph.set(j,t);
								}
								
			
								if(i==(numReds-1) && j==(numReds)){
										clearInterval(myVar);
										document.getElementById("graphProgG").innerHTML = "Graph computation: "+"100%";
										console.log(graph);
										
													var totalNumberP = parseInt(graph.count())*parseInt(graph.count());
										var numRedsinBucketP = Math.floor(2571800/parseInt(graph.count()));//2571800
										var numItersP = Math.ceil(totalNumberP/(numRedsinBucketP*parseInt(graph.count())));
										console.log('Num iters: '+numItersP);
								var promisesP=new Array();
								var retDataAll=new Array(graph.count());
								for(var parts=0;parts<numItersP;parts++){
									var startIndex = parts*numRedsinBucketP;
									var endIndex = startIndex + numRedsinBucketP;
									var size = numRedsinBucketP;
									
									if(endIndex>=graph.count()){
										var diff = endIndex - graph.count();
										size = size-diff;
									}
									
									console.log(endIndex);
									console.log(size);
									
									var retData=new Array(size/*graph.count()*/);
									
									var dat;
										
										for(var z=startIndex;z<startIndex+size/*numRedsinBucketP*//*graph.count()*/;z++)//2000
											retData[z-startIndex]=graph.get(z);
											retDataAll[z]=graph.get(z);;
											console.log("retData");
												console.log(retData);
											
											options = {url: saveGraphG,
												method: 'POST', 
												params: {
													},
											    data: { graph:  JSON.stringify(retData), start: startIndex		
											}
												};

												
												
										promisesP.push($scope.setGraphData(options));
									}
									
											var promise5 = Q.all(promisesP).then(function(){
														
														retData = retDataAll;
														var inputForAlgo={};
														
														for(var i=0;i<retData.length;i++){
																var eds1={};
															for(var j=0;j<retData[i].length;j++){
																if(i==j)
																	continue;
																if(typeof retData[i][j] == 'undefined')
																	 continue;//retData[i][j]=0.0;//continue;
																	
																	eds1[j]=1.0-retData[i][j];
															}
																inputForAlgo[i]=eds1;
														}
											
														$scope.checkedOrderGL.cog=[];
														$scope.graphInput = inputForAlgo;
											
														console.log("Create parameters and define scope variable here");//put watch on it in the scope.
														//retData[i][j] //use to implement filtering
																		//add three cases for attributes
																		
														if(typeof $scope.graphInputAttrs=='undefined'){
		
																var options = {url: checkTableAttrs,
																				method: 'GET', 
																				params: {
																					}
																				};
						  
																var promiseCT=$scope.getCheckTable(options);//$scope.getRedundancyInfo(options);
																	promiseCT.success(function (data) {
																	$scope.TableExistAttrs=data;
																	$scope.error = '';
																				})
																	.error(function (data, status) {
																		if (status === 404) {
																			$scope.error = 'REST server is offline!';
																			} else {
																			$scope.error = 'Error: ' + status;
																			}
																	}).then(function(){
																		
																		console.log('table exists attrs');
																		console.log($scope.TableExistAttrs);
		  
																			if($scope.TableExistAttrs.count[0].number==0){
																					
																					var optionsAttr = {url: AllRedsAttrs,
																											method: 'GET', 
																											params: {
																												}
																											};
						  
																					var promise1=$scope.getRedsAttrs(optionsAttr);
																					console.log('promise1');
																					console.log(promise1);
						   
																					promise1.success(function (data) {
																							console.log('success get attrs!');
																							console.log(data);
																							$scope.RedsAttrs=data;
																							$scope.error = '';
																								})
																							.error(function (data, status) {
																								console.log('error get attrs!');
																							if (status === 404) {
																								$scope.error = 'REST server is offline!';
																							} else {
																								$scope.error = 'Error: ' + status;
																								}
																							}).then(function(){
																									console.log('attributes recieved');
																									console.log($scope.RedsAttrs);
																									var redAttrs=new HashMap();
																									console.log($scope.RedsAttrs);
																									console.log('Q');
																									console.log(Q);
						
																										var promise3 = Q.all( [
																												loadToStructAttrs(redAttrs,$scope) //mozda ne treba
																													])
						
																										Q.allSettled(promise3).then(function(results){
																												results.forEach(function(result){
						
																												if (result.state === "fulfilled") {
																														var redAttrs = result.value;
																														console.log('result Attr');
																														console.log(result.value);
								
																							var graphAttr= new HashMap();
																									console.log("then part!");
																									console.log(redAttrs);
																									console.log(redAttrs.count());

																										var i=0;
																										var j=i+1;
																								var numReds = redAttrs.count();
																								
																						var myVar=setInterval(function() {

																							var perc= (i/numReds)*100;
										
																								document.getElementById("graphProgG").innerHTML = "Graph computation: "+perc.toFixed(2)+"%";
								
																							var set1 = redAttrs.get(i);
								
																						for(j=i+1;j<numReds;j++){
																								var set2 = redAttrs.get(j);
								
																								var intersection=0;
																								var set1val = set1.values();
								
																							for(var z=0;z<set1val.length;z++)
																									if(set2.contains(set1val[z]))
																											intersection=intersection+1;
										
																										var edge = intersection/(set1.size()+set2.size()-intersection);
								
																									if(!graphAttr.has(i)){
																											var t=new Array(numReds);
																											t[i]=1.0;
																											graphAttr.set(i,t);
																										}
									
																									if(!graphAttr.has(j)){
																											var t=new Array(numReds);
																												t[j]=1.0;
																												graphAttr.set(j,t);
																											}
								
																									var t=graphAttr.get(i);
																										t[j]=edge;
																										graphAttr.set(i,t);
								
																										t=graphAttr.get(j);
																										t[i]=edge;
																										graphAttr.set(j,t);
																									}
								
			
																			if(i==(numReds-1) && j==(numReds)){
																					clearInterval(myVar);
																					document.getElementById("graphProgG").innerHTML = "Graph computation: "+"100%";
																					console.log(graphAttr);
										
																					var totalNumberP = parseInt(graphAttr.count())*parseInt(graphAttr.count());
										var numRedsinBucketP = Math.floor(2571800/parseInt(graphAttr.count()));//2571800
										var numItersP = Math.ceil(totalNumberP/(numRedsinBucketP*parseInt(graphAttr.count())));
										console.log('Num iters: '+numItersP);
								
								var promisesP=new Array();
								var retDataAll=new Array(graphAttr.count());
								for(var parts=0;parts<numItersP;parts++){
									var startIndex = parts*numRedsinBucketP;
									var endIndex = startIndex + numRedsinBucketP;
									var size = numRedsinBucketP;
									
									if(endIndex>=graphAttr.count()){
										var diff = endIndex - graphAttr.count();
										size = size-diff;
									}
									
									console.log(endIndex);
									console.log(size);
									
									var retData=new Array(size/*graphAttr.count()*/);
									
									var dat;
										
										for(var z=startIndex;z<startIndex+size/*numRedsinBucketP*//*graphAttr.count()*/;z++)//2000
											retData[z-startIndex]=graphAttr.get(z);
											retDataAll[z]=graphAttr.get(z);;
											console.log("retData");
												console.log(retData);
											
											options = {url: saveGraphAttrG,
												method: 'POST', 
												params: {
													},
											    data: { graphAttr:  JSON.stringify(retData), start: startIndex		
											}
												};

												
												
										promisesP.push($scope.setGraphData(options));
									}
									 
											var gcpromise = Q.all(promisesP).then(function(){
											
																								retData = retDataAll;
																								var inputForAlgoAttrs={};
														
																								for(var i=0;i<retData.length;i++){
																										var eds1={};
																										for(var j=0;j<retData[i].length;j++){
																											if(i==j)
																												continue;
																											if(typeof retData[i][j] == 'undefined')
																												continue;//retData[i][j]=0.0;//continue;
																	
																											eds1[j]=1.0-retData[i][j];
																										}
																									inputForAlgoAttrs[i]=eds1;
																									}
											
																											$scope.checkedOrderGL.cog=[];
																											$scope.graphInputAttrs = inputForAlgoAttrs;
																											
																											//use graphInput and graphInputAttrs
																											filteringG(pload,$scope,elOv,atOv);
																											$scope.$apply();
																											});
																									}
																									
																									i=i+1;
																								  },5)
																								}
																							})
																					})
																				})																					
																			}
																			else{
																				
																					var optionsNR = {url: numredsLink,
																										method: 'GET',
																										params: {}
																									};
								 
																					var promiseNR = $scope.generalGETRequest(optionsNR);
				
				
																						promiseNR.success(function (data) {
																										$scope.numReds = data;
																										$scope.error = '';
																							})
																									.error(function (data, status) {
																									if (status === 404) {
																											$scope.error = 'REST server is offline!';
																									} else {
																										$scope.error = 'Error: ' + status;
																										}
																									}).then(function(){
											
																										console.log('num reds:');
																										console.log($scope.numReds); 
																										console.log($scope.numReds.numReds[0].numReds);
											
																										var numReds = $scope.numReds.numReds[0].numReds;																				
																					
																										//var promiseGR=getAttrGraph($scope);

																														var totalNumber = numReds*numReds;
																														var numRedsinBucket = Math.floor(2571800/numReds);
																														console.log('numRedsInBucket: '+numRedsinBucket);
																														var numIters = Math.ceil(totalNumber/(numRedsinBucket*parseInt(numReds)));
																														console.log('numIters: '+numIters);

																														var promises=new Array();
									
																															for(var parts=0;parts<numIters;parts++){
																																	var startIndex = parts*numRedsinBucket;
																																	var endIndex = (parts+1)*numRedsinBucket;
																																		if(endIndex>numReds)
																																				endIndex=numReds;
																																				promises.push(getInPartsAttr(startIndex,endIndex,numReds,$scope));
																																			}
									
																															var joinedPromise = Q.all(promises);
																										
																										joinedPromise.then(function(values){
									
																													console.log('All data received!');
																													console.log('values');
																													console.log(values);
									
																													var inputAttrs = [];
									
																													console.log('computing input: ');
																													console.log('values length: '+values.length);
																													console.log('graph length: '+values[0].data.GraphDataAttr.length);
									
																														for(var iv=0;iv<values.length;iv++){
																																		for(var iv1=0;iv1<values[iv].data.GraphDataAttr.length;iv1++)
																																				inputAttrs.push(values[iv].data.GraphDataAttr[iv1]);
																																						console.log(inputAttrs.length);
																														}
									
																															console.log('joined input: ');
																															console.log(inputAttrs);
										
																															values=[];
	
																															console.log("Create parameters and define scope variable here");//put watch on it in the scope.
														
																															var inputForAlgoAttrs={};
														
																																for(var i=0;i<inputAttrs.length;i++){
																																				var eds1={};
																																		for(var j=0;j<inputAttrs[i].length;j++){
																																				if(i==j)
																																					continue;
																																				if(typeof inputAttrs[i][j] == 'undefined')
																																					continue;//retData[i][j]=0.0;//continue;
																	
																																				eds1[j]=1.0-inputAttrs[i][j];
																																				}
																																			inputForAlgoAttrs[i]=eds1;
																																			}

																																			$scope.checkedOrderGL.cog=[];
																																			$scope.graphInputAttrs = inputForAlgoAttrs;
																																			filteringG(pload,$scope,elOv,atOv);
																																			$scope.$apply();
																																		//add three cases for attributes
																																		//use GraphInput and GraphInputAttrs
																																});
																														});
																								}
																							})
																					}
															else{
															filteringG(pload,$scope,elOv,atOv);
															$scope.$apply();
																//use graphInput and graphInputAttrs
															}
															
											})
										
										
										return;
											}
											
											i=i+1;
							}, 5);	
							}
							})
						})							
									//compute the graph, save the graph and compute the input for the algorithm, run the algorithm and draw the result.
							})
							
							}
				else{
				
				var getInParts = function(startIndex, endIndex, numReds, $scope){
				if(typeof($scope.rawGraph)=='undefined')
						$scope.rawGraph = [];
					return Q.spread([startIndex, endIndex, $scope], function(startIndex, endIndex,$scope){
							var options = {url: saveGraph,
												method: 'GET', 
												params: {
													start: JSON.stringify(startIndex),
													end: JSON.stringify(endIndex),
													nr: JSON.stringify(numReds)
													}
												};
												
									var tmpPromise = $scope.getGraphData(options);	
									
									return tmpPromise;
									
									var tmpRes;
									
									tmpPromise.success(function (data) {
											tmpRes=data;
											console.log('data');
											console.log(tmpRes);
												$scope.error = '';
										})
										.error(function (data, status) {
										if (status === 404) {
											$scope.error = 'REST server is offline!';
										} else {
												$scope.error = 'Error: ' + status;
											}
											}).then(function(){
											
											console.log('got a part of data');
											console.log(tmpRes);
											var tmp=new Array();
											
											
											
											return tmp;
											//convert to HashMap arrayList
											
											});
												
					})
				};
				
				var optionsNR = {url: numredsLink,
								 method: 'GET',
								 params: {}
								 };
								 
				var promiseNR = $scope.generalGETRequest(optionsNR);
				
				
				promiseNR.success(function (data) {
											$scope.numReds = data;
												$scope.error = '';
										})
										.error(function (data, status) {
										if (status === 404) {
											$scope.error = 'REST server is offline!';
										} else {
												$scope.error = 'Error: ' + status;
											}
											}).then(function(){
											
											console.log('num reds:');
											console.log($scope.numReds); 
											console.log($scope.numReds.numReds[0].numReds);
											
											var numReds = $scope.numReds.numReds[0].numReds;
											//convert to HashMap arrayList
											
											var totalNumber = numReds*numReds;
											var numRedsinBucket = Math.floor(2571800/numReds);
											console.log('numRedsInBucket: '+numRedsinBucket);
											var numIters = Math.ceil(totalNumber/(numRedsinBucket*parseInt(numReds)));
											console.log('numIters: '+numIters);

									var promises=new Array();
									
									for(var parts=0;parts<numIters;parts++){
									var startIndex = parts*numRedsinBucket;
									var endIndex = (parts+1)*numRedsinBucket;
									if(endIndex>numReds)
										endIndex=numReds;
										promises.push(getInParts(startIndex,endIndex,numReds,$scope));
									}
									
									var joinedPromise = Q.all(promises).then(function(values){
									
									console.log('All data received!');
									console.log('values');
									console.log(values);
									
									var input = [];
									
									console.log('computing input: ');
									console.log('values length: '+values.length);
									console.log('graph length: '+values[0].data.GraphData.length);
									
									for(var iv=0;iv<values.length;iv++){
											for(var iv1=0;iv1<values[iv].data.GraphData.length;iv1++)
												input.push(values[iv].data.GraphData[iv1]);
												console.log(input.length);
									}
									
										console.log('joined input: ');
										console.log(input);
										
										values=[];
	
										console.log("Create parameters and define scope variable here");//put watch on it in the scope.
														
														var inputForAlgo={};
														
														for(var i=0;i<input.length;i++){
																var eds1={};
															for(var j=0;j<input[i].length;j++){
																if(i==j)
																	continue;
																if(typeof input[i][j] == 'undefined')
																	 continue;//retData[i][j]=0.0;//continue;
																	
																	eds1[j]=1.0-input[i][j];
															}
																inputForAlgo[i]=eds1;
														}

														$scope.checkedOrderGL.cog=[];
														$scope.graphInput = inputForAlgo;
														//add three cases for attributes
														
													if(typeof $scope.graphInputAttrs=='undefined'){
		
																var options = {url: checkTableAttrs,
																				method: 'GET', 
																				params: {
																					}
																				};
						  
																var promiseCT=$scope.getCheckTable(options);//$scope.getRedundancyInfo(options);
																	promiseCT.success(function (data) {
																	$scope.TableExistAttrs=data;
																	$scope.error = '';
																				})
																	.error(function (data, status) {
																		if (status === 404) {
																			$scope.error = 'REST server is offline!';
																			} else {
																			$scope.error = 'Error: ' + status;
																			}
																	}).then(function(){
																		
																		console.log('table exists attrs');
																		console.log($scope.TableExistAttrs);
		  
																			if($scope.TableExistAttrs.count[0].number==0){
																					
																					var optionsAttr = {url: AllRedsAttrs,
																											method: 'GET', 
																											params: {
																												}
																											};
						  
																					var promise1=$scope.getRedsAttrs(optionsAttr);
																					console.log('promise1');
																					console.log(promise1);
						   
																					promise1.success(function (data) {
																							console.log('success get attrs!');
																							console.log(data);
																							$scope.RedsAttrs=data;
																							$scope.error = '';
																								})
																							.error(function (data, status) {
																								console.log('error get attrs!');
																							if (status === 404) {
																								$scope.error = 'REST server is offline!';
																							} else {
																								$scope.error = 'Error: ' + status;
																								}
																							}).then(function(){
																									console.log('attributes recieved');
																									console.log($scope.RedsAttrs);
																									var redAttrs=new HashMap();
																									console.log($scope.RedsAttrs);
																									console.log('Q');
																									console.log(Q);
						
																										var promise3 = Q.all( [
																												loadToStructAttrs(redAttrs,$scope) //mozda ne treba
																													])
						
																										Q.allSettled(promise3).then(function(results){
																												results.forEach(function(result){
						
																												if (result.state === "fulfilled") {
																														var redAttrs = result.value;
																														console.log('result Attr');
																														console.log(result.value);

																							var graphAttr= new HashMap();
																									console.log("then part!");
																									console.log(redAttrs);
																									console.log(redAttrs.count());

																										var i=0;
																										var j=i+1;
																								var numReds = redAttrs.count();
																								
																						var myVar=setInterval(function() {

																							var perc= (i/numReds)*100;
										
																								document.getElementById("graphProgG").innerHTML = "Graph computation: "+perc.toFixed(2)+"%";
								
																							var set1 = redAttrs.get(i);
								
																						for(j=i+1;j<numReds;j++){
																								var set2 = redAttrs.get(j);
								
																								var intersection=0;
																								var set1val = set1.values();
								
																							for(var z=0;z<set1val.length;z++)
																									if(set2.contains(set1val[z]))
																											intersection=intersection+1;
										
																										var edge = intersection/(set1.size()+set2.size()-intersection);
								
																									if(!graphAttr.has(i)){
																											var t=new Array(numReds);
																											t[i]=1.0;
																											graphAttr.set(i,t);
																										}
									
																									if(!graphAttr.has(j)){
																											var t=new Array(numReds);
																												t[j]=1.0;
																												graphAttr.set(j,t);
																											}
								
																									var t=graphAttr.get(i);
																										t[j]=edge;
																										graphAttr.set(i,t);
								
																										t=graphAttr.get(j);
																										t[i]=edge;
																										graphAttr.set(j,t);
																									}
								
			
																			if(i==(numReds-1) && j==(numReds)){
																					clearInterval(myVar);
																					document.getElementById("graphProgG").innerHTML = "Graph computation: "+"100%";
																					console.log(graphAttr);
										
																					var totalNumberP = parseInt(graphAttr.count())*parseInt(graphAttr.count());
																					var numRedsinBucketP = Math.floor(2571800/parseInt(graphAttr.count()));//2571800
																					var numItersP = Math.ceil(totalNumberP/(numRedsinBucketP*parseInt(graphAttr.count())));
																					console.log('Num iters: '+numItersP);
																				
																					var promisesP=new Array();
																					var retDataAll=new Array(graphAttr.count());
																					for(var parts=0;parts<numItersP;parts++){
																						var startIndex = parts*numRedsinBucketP;
																						var endIndex = startIndex + numRedsinBucketP;
																						var size = numRedsinBucketP;
									
																						if(endIndex>=graphAttr.count()){
																							var diff = endIndex - graphAttr.count();
																							size = size-diff;
																						}
																						
																						console.log(endIndex);
																						console.log(size);
																						
																						var retData=new Array(size/*graphAttr.count()*/);
																						
																						var dat;
										
																							for(var z=startIndex;z<startIndex+size/*numRedsinBucketP*//*graphAttr.count()*/;z++)//2000
																								retData[z-startIndex]=graphAttr.get(z);
																								retDataAll[z]=graphAttr.get(z);;
																								console.log("retData");
																									console.log(retData);
																								
																								options = {url: saveGraphAttrG,
																									method: 'POST', 
																									params: {
																										},
																									data: { graphAttr:  JSON.stringify(retData), start: startIndex		
																								}
																									};

																									
																									
																							promisesP.push($scope.setGraphData(options));
																						}
																						
																	var gcpromise = Q.all(promisesP).then(function(){
											
																								retData = retDataAll;
																								var inputForAlgoAttrs={};
														
																								for(var i=0;i<retData.length;i++){
																										var eds1={};
																										for(var j=0;j<retData[i].length;j++){
																											if(i==j)
																												continue;
																											if(typeof retData[i][j] == 'undefined')
																												continue;//retData[i][j]=0.0;//continue;
																	
																											eds1[j]=1.0-retData[i][j];
																										}
																									inputForAlgoAttrs[i]=eds1;
																									}
											
																											$scope.checkedOrderGL.cog=[];
																											$scope.graphInputAttrs = inputForAlgoAttrs;
																											
																											//use graphInput and graphInputAttrs
																											filteringG(pload,$scope,elOv,atOv);
																											$scope.$apply();
																											});
																									}
																									
																									i=i+1;
																								  },5)
																								}
																							})
																					})
																				})																					
																			}
																			else{
																				
																					var optionsNR = {url: numredsLink,
																										method: 'GET',
																										params: {}
																									};
								 
																					var promiseNR = $scope.generalGETRequest(optionsNR);
				
				
																						promiseNR.success(function (data) {
																										$scope.numReds = data;
																										$scope.error = '';
																							})
																									.error(function (data, status) {
																									if (status === 404) {
																											$scope.error = 'REST server is offline!';
																									} else {
																										$scope.error = 'Error: ' + status;
																										}
																									}).then(function(){
											
																										console.log('num reds:');
																										console.log($scope.numReds); 
																										console.log($scope.numReds.numReds[0].numReds);
											
																										var numReds = $scope.numReds.numReds[0].numReds;																				
																					
																										//var promiseGR=getAttrGraph($scope);

																														var totalNumber = numReds*numReds;
																														var numRedsinBucket = Math.floor(2571800/numReds);
																														console.log('numRedsInBucket: '+numRedsinBucket);
																														var numIters = Math.ceil(totalNumber/(numRedsinBucket*parseInt(numReds)));
																														console.log('numIters: '+numIters);

																														var promises=new Array();
									
																															for(var parts=0;parts<numIters;parts++){
																																	var startIndex = parts*numRedsinBucket;
																																	var endIndex = (parts+1)*numRedsinBucket;
																																		if(endIndex>numReds)
																																				endIndex=numReds;
																																				promises.push(getInPartsAttr(startIndex,endIndex,numReds,$scope));
																																			}
									
																															var joinedPromise = Q.all(promises);
																										
																										joinedPromise.then(function(values){
									
																													console.log('All data received!');
																													console.log('values');
																													console.log(values);
									
																													var inputAttrs = [];
									
																													console.log('computing input: ');
																													console.log('values length: '+values.length);
																													console.log('graph length: '+values[0].data.GraphDataAttr.length);
									
																														for(var iv=0;iv<values.length;iv++){
																																		for(var iv1=0;iv1<values[iv].data.GraphDataAttr.length;iv1++)
																																				inputAttrs.push(values[iv].data.GraphDataAttr[iv1]);
																																						console.log(inputAttrs.length);
																														}
									
																															console.log('joined input: ');
																															console.log(inputAttrs);
										
																															values=[];
	
																															console.log("Create parameters and define scope variable here");//put watch on it in the scope.
														
																															var inputForAlgoAttrs={};
														
																																for(var i=0;i<inputAttrs.length;i++){
																																				var eds1={};
																																		for(var j=0;j<inputAttrs[i].length;j++){
																																				if(i==j)
																																					continue;
																																				if(typeof inputAttrs[i][j] == 'undefined')
																																					continue;//retData[i][j]=0.0;//continue;
																	
																																				eds1[j]=1.0-inputAttrs[i][j];
																																				}
																																			inputForAlgoAttrs[i]=eds1;
																																			}

																																			$scope.checkedOrderGL.cog=[];
																																			$scope.graphInputAttrs = inputForAlgoAttrs;
																																			filteringG(pload,$scope,elOv,atOv);
																																			$scope.$apply();
																																		//add three cases for attributes
																																		//use GraphInput and GraphInputAttrs
																																});
																														});
																								}
																							})
																					}
															else{
															filteringG(pload,$scope,elOv,atOv);
															$scope.$apply();
																//use graphInput and graphInputAttrs
															}			
									
									});
											
									});
				
						//load the graph and compute the input for the algorithm, run the algorithm and draw the result.
					
				}
		  
				});
			}
			else{
			//use graphInput for filtering
													console.log("Algorithm input: ");
														console.log($scope.graphInput);
													 var inputForAlgo = $scope.graphInput;
														
														
														$scope.checkedOrderGL.cog=[];
														$scope.graphInput = inputForAlgo;
														//add three cases for attributes
														
											if(typeof $scope.graphInputAttrs=='undefined'){
		
																var options = {url: checkTableAttrs,
																				method: 'GET', 
																				params: {
																					}
																				};
						  
																var promiseCT=$scope.getCheckTable(options);//$scope.getRedundancyInfo(options);
																	promiseCT.success(function (data) {
																	$scope.TableExistAttrs=data;
																	$scope.error = '';
																				})
																	.error(function (data, status) {
																		if (status === 404) {
																			$scope.error = 'REST server is offline!';
																			} else {
																			$scope.error = 'Error: ' + status;
																			}
																	}).then(function(){
																		
																		console.log('table exists attrs');
																		console.log($scope.TableExistAttrs);
		  
																			if($scope.TableExistAttrs.count[0].number==0){
																					
																					var optionsAttr = {url: AllRedsAttrs,
																											method: 'GET', 
																											params: {
																												}
																											};
						  
																					var promise1=$scope.getRedsAttrs(optionsAttr);
																					console.log('promise1');
																					console.log(promise1);
						   
																					promise1.success(function (data) {
																							console.log('success get attrs!');
																							console.log(data);
																							$scope.RedsAttrs=data;
																							$scope.error = '';
																								})
																							.error(function (data, status) {
																								console.log('error get attrs!');
																							if (status === 404) {
																								$scope.error = 'REST server is offline!';
																							} else {
																								$scope.error = 'Error: ' + status;
																								}
																							}).then(function(){
																									console.log('attributes recieved');
																									console.log($scope.RedsAttrs);
																									var redAttrs=new HashMap();
																									console.log($scope.RedsAttrs);
																									console.log('Q');
																									console.log(Q);
						
																										var promise3 = Q.all( [
																												loadToStructAttrs(redAttrs,$scope) //mozda ne treba
																													])
						
																										Q.allSettled(promise3).then(function(results){
																												results.forEach(function(result){
						
																												if (result.state === "fulfilled") {
																														var redAttrs = result.value;
																														console.log('result Attr');
																														console.log(result.value);
																														
																							var graphAttr= new HashMap();
																									console.log("then part!");
																									console.log(redAttrs);
																									console.log(redAttrs.count());

																										var i=0;
																										var j=i+1;
																								var numReds = redAttrs.count();
																								
																						var myVar=setInterval(function() {

																							var perc= (i/numReds)*100;
										
																								document.getElementById("graphProgG").innerHTML = "Graph computation: "+perc.toFixed(2)+"%";
								
																							var set1 = redAttrs.get(i);
								
																						for(j=i+1;j<numReds;j++){
																								var set2 = redAttrs.get(j);
								
																								var intersection=0;
																								var set1val = set1.values();
								
																							for(var z=0;z<set1val.length;z++)
																									if(set2.contains(set1val[z]))
																											intersection=intersection+1;
										
																										var edge = intersection/(set1.size()+set2.size()-intersection);
								
																									if(!graphAttr.has(i)){
																											var t=new Array(numReds);
																											t[i]=1.0;
																											graphAttr.set(i,t);
																										}
									
																									if(!graphAttr.has(j)){
																											var t=new Array(numReds);
																												t[j]=1.0;
																												graphAttr.set(j,t);
																											}
								
																									var t=graphAttr.get(i);
																										t[j]=edge;
																										graphAttr.set(i,t);
								
																										t=graphAttr.get(j);
																										t[i]=edge;
																										graphAttr.set(j,t);
																									}
								
			
																			if(i==(numReds-1) && j==(numReds)){
																					clearInterval(myVar);
																					document.getElementById("graphProgG").innerHTML = "Graph computation: "+"100%";
																					console.log(graphAttr);
										
																					var totalNumberP = parseInt(graphAttr.count())*parseInt(graphAttr.count());
																					var numRedsinBucketP = Math.floor(2571800/parseInt(graphAttr.count()));//2571800
																					var numItersP = Math.ceil(totalNumberP/(numRedsinBucketP*parseInt(graphAttr.count())));
																					console.log('Num iters: '+numItersP);
																				
																					var promisesP=new Array();
																					var retDataAll=new Array(graphAttr.count());
																					for(var parts=0;parts<numItersP;parts++){
																						var startIndex = parts*numRedsinBucketP;
																						var endIndex = startIndex + numRedsinBucketP;
																						var size = numRedsinBucketP;
									
																						if(endIndex>=graphAttr.count()){
																							var diff = endIndex - graphAttr.count();
																							size = size-diff;
																						}
																						
																						console.log(endIndex);
																						console.log(size);
																						
																						var retData=new Array(size/*graphAttr.count()*/);
																						
																						var dat;
										
																							for(var z=startIndex;z<startIndex+size/*numRedsinBucketP*//*graphAttr.count()*/;z++)//2000
																								retData[z-startIndex]=graphAttr.get(z);
																								retDataAll[z]=graphAttr.get(z);;
																								console.log("retData");
																									console.log(retData);
																								
																								options = {url: saveGraphAttrG,
																									method: 'POST', 
																									params: {
																										},
																									data: { graphAttr:  JSON.stringify(retData), start: startIndex		
																								}
																									};

																									
																									
																							promisesP.push($scope.setGraphData(options));
																						}
																						
											var gcpromise = Q.all(promisesP).then(function(){
											
																								retData = retDataAll;
																								var inputForAlgoAttrs={};
														
																								for(var i=0;i<retData.length;i++){
																										var eds1={};
																										for(var j=0;j<retData[i].length;j++){
																											if(i==j)
																												continue;
																											if(typeof retData[i][j] == 'undefined')
																												continue;//retData[i][j]=0.0;//continue;
																	
																											eds1[j]=1.0-retData[i][j];
																										}
																									inputForAlgoAttrs[i]=eds1;
																									}
											
																											$scope.checkedOrderGL.cog=[];
																											$scope.graphInputAttrs = inputForAlgoAttrs;
																											
																											//use graphInput and graphInputAttrs
																											filteringG(pload,$scope,elOv,atOv);
																											$scope.$apply();
																											});
																									}
																									
																									i=i+1;
																								  },5)
																								}
																							})
																					})
																				})																					
																			}
																			else{
																				
																					var optionsNR = {url: numredsLink,
																										method: 'GET',
																										params: {}
																									};
								 
																					var promiseNR = $scope.generalGETRequest(optionsNR);
				
				
																						promiseNR.success(function (data) {
																										$scope.numReds = data;
																										$scope.error = '';
																							})
																									.error(function (data, status) {
																									if (status === 404) {
																											$scope.error = 'REST server is offline!';
																									} else {
																										$scope.error = 'Error: ' + status;
																										}
																									}).then(function(){
											
																										console.log('num reds:');
																										console.log($scope.numReds); 
																										console.log($scope.numReds.numReds[0].numReds);
											
																										var numReds = $scope.numReds.numReds[0].numReds;																				
																					
																										//var promiseGR=getAttrGraph($scope);

																														var totalNumber = numReds*numReds;
																														var numRedsinBucket = Math.floor(2571800/numReds);
																														console.log('numRedsInBucket: '+numRedsinBucket);
																														var numIters = Math.ceil(totalNumber/(numRedsinBucket*parseInt(numReds)));
																														console.log('numIters: '+numIters);

																														var promises=new Array();
									
																															for(var parts=0;parts<numIters;parts++){
																																	var startIndex = parts*numRedsinBucket;
																																	var endIndex = (parts+1)*numRedsinBucket;
																																		if(endIndex>numReds)
																																				endIndex=numReds;
																																				promises.push(getInPartsAttr(startIndex,endIndex,numReds,$scope));
																																			}
									
																															var joinedPromise = Q.all(promises);
																										
																										joinedPromise.then(function(values){
									
																													console.log('All data received!');
																													console.log('values');
																													console.log(values);
									
																													var inputAttrs = [];
									
																													console.log('computing input: ');
																													console.log('values length: '+values.length);
																													console.log('graph length: '+values[0].data.GraphDataAttr.length);
									
																														for(var iv=0;iv<values.length;iv++){
																																		for(var iv1=0;iv1<values[iv].data.GraphDataAttr.length;iv1++)
																																				inputAttrs.push(values[iv].data.GraphDataAttr[iv1]);
																																						console.log(inputAttrs.length);
																														}
									
																															console.log('joined input: ');
																															console.log(inputAttrs);
										
																															values=[];
	
																															console.log("Create parameters and define scope variable here");//put watch on it in the scope.
														
																															var inputForAlgoAttrs={};
														
																																for(var i=0;i<inputAttrs.length;i++){
																																				var eds1={};
																																		for(var j=0;j<inputAttrs[i].length;j++){
																																				if(i==j)
																																					continue;
																																				if(typeof inputAttrs[i][j] == 'undefined')
																																					continue;//retData[i][j]=0.0;//continue;
																	
																																				eds1[j]=1.0-inputAttrs[i][j];
																																				}
																																			inputForAlgoAttrs[i]=eds1;
																																			}

																																			$scope.checkedOrderGL.cog=[];
																																			$scope.graphInputAttrs = inputForAlgoAttrs;
																																			filteringG(pload,$scope,elOv,atOv);
																																			$scope.$apply();
																																		//add three cases for attributes
																																		//use GraphInput and GraphInputAttrs
																																});
																														});
																								}
																							})
																					}
															else{
															filteringG(pload,$scope,elOv,atOv);
															$scope.$apply();
																//use graphInput and graphInputAttrs
															}
			}
		} 
	
	
  function filterReds(){
  var appElement = document.querySelector('[ng-app=redApp]');
   var $scope = angular.element(appElement).scope();
    //var $http = angular.element(appElement).http();
	console.log(angular.element(appElement));
	
	var pload=document.getElementById("loader");
		pload.style.visibility="visible";
	
  
  var appElement = document.querySelector('[ng-app=redApp]');
   var $scope = angular.element(appElement).scope();
	
	 var groupMaps= new HashMap();
	 
	 
	 var elOv=$("#eoverIn").val(); var atOv=$("#atoverIn").val();

  var redescriptionElements=new HashMap();
  var redescriptionAttributes = new HashMap();
    var redescriptionElements1=new HashMap();
  var redescriptionAttributes1 = new HashMap(); //console.log(Q);

  var options = {url: databaseConfig,
               method: 'GET', 
               params: {
               ids: 0
                        }
                          };

						  var promise=$scope.getRedundancyAll(options);
						  promise.success(function (data) {

                $scope.RedundancyAll = data;
                $scope.error = '';
           })
          .error(function (data, status) {
		 // console.log("Database query failed!");
              if (status === 404) {
                $scope.error = 'REST server is offline!';
              } else {
                $scope.error = 'Error: ' + status;
              }
          }).then(function(){
		  					
							
	for(k=0;k<$scope.RedundancyAll.redElems.length;k++){
			if(!redescriptionElements.has($scope.RedundancyAll.redElems[k].id)){
					var stmp=new HashSet();
					stmp.add($scope.RedundancyAll.redElems[k].elementID);
					redescriptionElements.set($scope.RedundancyAll.redElems[k].id,stmp);
			}
			else{
			var stmp=redescriptionElements.get($scope.RedundancyAll.redElems[k].id);
			stmp.add($scope.RedundancyAll.redElems[k].elementID);
			redescriptionElements.set($scope.RedundancyAll.redElems[k].id,stmp);
			}
						
	}
	
		
	for(k=0;k<$scope.RedundancyAll.redAttr.length;k++){
			if(!redescriptionAttributes.has($scope.RedundancyAll.redAttr[k].id)){
					var stmp=new HashSet();
					stmp.add($scope.RedundancyAll.redAttr[k].attributeID);
					redescriptionAttributes.set($scope.RedundancyAll.redAttr[k].id,stmp);
			}
			else{
				var stmp=redescriptionAttributes.get($scope.RedundancyAll.redAttr[k].id);
				stmp.add($scope.RedundancyAll.redAttr[k].attributeID);
				redescriptionAttributes.set($scope.RedundancyAll.redAttr[k].id,stmp);
			}		
	}
	
					GlRedescriptions.sort(function(a, b){
					
					if(a.col3==b.col3){
						
						if(a.col5==b.col5){
							
							if(a.col4==b.col4){
									
									if(a.col5==b.col5){
										return a.col6-b.col6;
									}
									else{
										return a.col5-b.col5;
									}
									
							}
							else{
								return b.col4-a.col4;
							}
						
						}
						else{
							return a.col5-b.col5;
						}
						
					}
					else{
						return b.col3-a.col3;
					}
					
					});
					
					
					var toDelete = new HashSet();

					for(i=0;i<GlRedescriptions.length-1/*$scope.AllReds.redescriptions.length-1*/;i++)
							for(j=i+1;j<GlRedescriptions.length/*$scope.AllReds.redescriptions.length*/;j++){
							
								if(toDelete.contains(GlRedescriptions[j].id))
											continue;
	
								var s1Vals= redescriptionElements.get(GlRedescriptions[i].id/*$scope.AllReds.redescriptions[i].id*/).values();
											var sref=redescriptionElements.get(GlRedescriptions[j].id/*$scope.AllReds.redescriptions[j].id*/);
											var intersection=0; var union=0;
											//var s2Vals = redescriptionElements.get($scope.riGG.selectionReds[j].id).values;
											
											for(z=0;z<s1Vals.length;z++){
													if(sref.contains(s1Vals[z])){
														intersection=intersection+1;
														}
											}
											
											//console.log("set size: "+s1Vals.length);
											//console.log("intersection: "+intersection);
											union=s1Vals.length+sref.size()-intersection;
											//console.log("union: "+union);
												
												var jsEl= intersection/union;
												//console.log("jsEl: "+jsEl);
												if(jsEl*100>=elOv){
												if(GlRedescriptions[i].col3/*$scope.AllReds.redescriptions[i].col3*/> GlRedescriptions[j].col3 /*$scope.AllReds.redescriptions[j].col3*/){
													toDelete.add(GlRedescriptions[j].id/*$scope.AllReds.redescriptions[j].id*/);
													     }
												else
													toDelete.add(GlRedescriptions[i].id/*$scope.AllReds.redescriptions[i].id*/);
													//break;
													}	

									var s1Vals= redescriptionAttributes.get(GlRedescriptions[i].id/*$scope.AllReds.redescriptions[i].id*/).values();
											var sref=redescriptionAttributes.get(GlRedescriptions[j].id/*$scope.AllReds.redescriptions[j].id*/);
											var intersection=0; var union=0;
											//var s2Vals = redescriptionElements.get($scope.riGG.selectionReds[j].id).values;
											
											for(z=0;z<s1Vals.length;z++){
													if(sref.contains(s1Vals[z])){
														intersection=intersection+1;
														}
											}
											
											union=s1Vals.length+sref.size()-intersection;
												
												var jsAt= intersection/union;
												//console.log("jsAt: "+jsAt);
												if(jsAt*100>=atOv){
												if(GlRedescriptions[i].col3/*$scope.AllReds.redescriptions[i].col3*/>GlRedescriptions[j].col3/*$scope.AllReds.redescriptions[j].col3*/){
													toDelete.add(GlRedescriptions[j].id/*$scope.AllReds.redescriptions[j].id)*/);
													     }
												else
													toDelete.add(GlRedescriptions[i].id/*$scope.AllReds.redescriptions[i].id*/);
													//break;
													}
													
							}
							
							var check=new HashSet();
							
							for(z=0;z<GlRedescriptions.length;z++)
								check.add(GlRedescriptions[z].id);

							for(i=0;i<$scope.AllReds.redescriptions.length;i++){
								if(toDelete.contains($scope.AllReds.redescriptions[i].id) || !check.contains($scope.AllReds.redescriptions[i].id)){
									toDelete.remove($scope.AllReds.redescriptions[i].id);
									$scope.AllReds.redescriptions.splice(i,1);
									i--;
								}		
						}
					pload.style.visibility="hidden";						
						});
		} 
		

function choosePlotTypeGP(myRadio) {
	var appElement = document.querySelector('[ng-app=redApp]');
   var $scope = angular.element(appElement).scope();
   console.log($scope);
   console.log("value of radio button");
   console.log(myRadio.value);
   
   if(myRadio.value === 'nbox'){
		if($scope.plotType2==1){
			$scope.plotType2=2;
		}
		else if($scope.plotType2==2)
			$scope.plotType2=1;
		else
			$scope.plotType2 = 1;
		}
   if(myRadio.value === 'viol')
		$scope.plotType2 = 0;
		
		$scope.$apply();
		
}

function addTrandLinesGP(myCheck) {
	var appElement = document.querySelector('[ng-app=redApp]');
   var $scope = angular.element(appElement).scope();
   console.log($scope.Trends2);
   console.log($scope);
   console.log(myCheck.checked);
   
   if(myCheck.checked == true)
		$scope.Trends2 = 1;
   if(myCheck.checked == false)
		$scope.Trends2 = 0;
		
		console.log($scope.Trends2);
		$scope.$apply();
}
		
   </script>

<div class="container">

<div class="header">
<h1 class="header-title">Redescription set exploration</h1>
</div>

<div id="indtroduction" style="margin-top:10px;margin-bottom:10px">
<p>This is the third functionality of the <b> INTERSET tool that </b> allows <b> iterative exploration of redescription sets </b> based on different redescription properties. </p>
<div id="functionality" style="margin-bottom:20px">
<h3> Functionality</h3>
<p> The redescription property based exploration allows user to filter a redescription set based on different <b> redescription criteria </b>. The exploration process can be done in several steps: </p>
<ol>
  <li> <b> Select </b> each criteria you want to filter by and select the range of values of the corresponding redescription measure.</li>
  <li> <b> Scroll </b> through redescription table and <b> select </b> some interesting redescription </li>
  <li> <b> Examine </b> additional information about the selected redescription</li>
</ol>
<p> Clicking on some of the components displays new elements on the page. The elements are placed <b> below currently displayed components</b>, so depending on the screen size, you might need to scroll to use them. </p>
</div>

</div>

    <div id="Prapp" ng-app="redApp" ng-controller="redCtrl">
	      <div id="inputControls" style="height:70px">
			<button ng-model="button" ng-disabled="checked" ng-click="compglInfo()">Create crosfilter on all data</button>
			<button ng-model="button" ng-disabled="checked" ng-click="compglInfoSel()">Create crosfilter on selection</button>
			 <span id="butonWithRadio">
			 <label>
					<input type="radio" ng-model="action.type" value="save" style="margin-left: 40px">
						Save selection
					</label>
			<label>
					<input type="radio" ng-model="action.type" value="load">
						Load and create crossfilter
			</label>
			<button ng-model="button" ng-disabled="checked" ng-click="compglInfoSelSh()" style="margin-left: 500px;">Perform</button>
			</span>
			</div>
		  <red-filter allred-url="http://localhost:8081/allRedescriptions", redinfo-url="http://localhost:8081/redescriptionInfo" shared-url="http://localhost:8081/sharedData" > </red-filter>
		  <selected-redescription style="float:left; margin-top: 50px"> </selected-redescription>
		  <draw-graphg style="float:left; margin-top: 50px" redinfo-url="http://localhost:8081/redescriptionInfo"> </draw-graphg>
    </div>
</body> 

</html>